 
 
 
  
 
  
 
  
  
 
 
  
 
  
 
  
 
  
 
  
 
  
 
 
  
   
 
CUSTOMER EDUCATION SERVICES 
IC Compiler 1  
Workshop 
 
Student Guide 
20-I-071-SSG-008 2008.09  
Synopsys Customer Education Services 
700 East Middlefield Road 
Mountain View, California 94043 
 Workshop Registration: 1-800-793-3448  
 
www.synopsys.com 

Synopsys Customer Education Services  Copyright Notice and Proprietary Information 
Copyright © 2009 Synopsys, Inc. All rights reserved. This software and documentation contain confidential and 
proprietary information that is the property of Synops ys, Inc. The software and documentation are furnished under a 
license agreement and may be used or copied only in accordance wi th the terms of the license agreement. No part of the 
software and documentation may be reproduced, transmitted, or tr anslated, in any form or by any means, electronic, 
mechanical, manual, optical, or otherwise, without prior writt en permission of Synopsys, Inc., or as expressly provided by 
the license agreement. 
 
 Destination Control Statement 
All technical data contained in this publicat ion is subject to the export control la ws of the United States of America. 
Disclosure to nationals of other countries contrary to United States law is prohibited. It is  the reader’s responsibility to 
determine the applicable regulations and to comply with them. 
 
Disclaimer 
SYNOPSYS, INC., AND ITS LICENSORS MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NO T LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  
Registered Trademarks (®) 
Synopsys, AMPS, Cadabra, CATS, CRITIC, CSim, Design Compiler, DesignPower, DesignWare, EPIC, Formality, HSIM, HSPICE, iN-Phase, in-Sync, Leda, MAST, ModelTools, NanoSim, OpenVera, PathMill, Photolynx, Physical Compiler, PrimeTime, SiVL, SNUG, SolvNet, System Compiler, TetraM AX, VCS, Vera, and YIELDirector are registered trademarks 
of Synopsys, Inc.  
 
Trademarks (™) 
AFGen, Apollo, Astro, Astro-Rail, Astr o-Xtalk, Aurora, AvanWaves, Columbia,C olumbia-CE, Cosmos, CosmosEnterprise, 
CosmosLE, CosmosScope, CosmosSE, DC Expert, DC Prof essional, DC Ultra, Design Analyzer, Design Vision, 
DesignerHDL, Direct Silicon Access, Discovery, Encore, Ga laxy, HANEX, HDL Compiler, Hercules, Hierarchical 
Optimization Technology, HSIMplus, H SPICE-Link, iN-Tandem, i-Virtual Stepper, Jupiter, Jupiter-DP, JupiterXT, 
JupiterXT-ASIC, Liberty, Libra-Passport,Library Compiler, Magellan, Mars, Mars-Rail, Milkyway, ModelSource, Module 
Compiler, Planet, Planet-PL, Polaris, Power Compiler, Raph ael, Raphael-NES,Saturn, Scirocco, Scirocco-i, Star-RCXT, 
Star-SimXT, Taurus, TSUPREM-4, VCS Express, VCSi, VHDL  Compiler, VirSim, and VMC are trademarks of Synopsys, 
Inc.  
 
Service Marks (SM) 
MAP-in, SVP Café, and TAP-in are service marks of Synopsys, Inc.  SystemC is a trademark of the Open SystemC Initiative  and is used under license. ARM and AMBA are registered 
trademarks of ARM Limited. Saber is a registered trademark of SabreMark Limited Partnership and is used under license. 
All other product or company names may be trademarks of their respective owners. 
 
 
 Document Order Number: 20-I-071-SSG-008
 
IC Compiler 1 Student Guide 
 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 i IC Compiler 1 Unit i: Introduction & Overview 
Facilities .................................................................................................................... ........ i-2 
Workshop Goal .................................................................................................................  i-3 
Target Audience ............................................................................................................... . i-4 
Workshop Prerequisites .................................................................................................... i-5  
Introductions ................................................................................................................. .... i-6 
Curriculum Flow ...............................................................................................................  i-7 
Agenda ........................................................................................................................ ...... i-8 
Agenda ........................................................................................................................ ...... i-9 
Agenda ........................................................................................................................ .... i-10 
High-Level IC Compiler Flow ........................................................................................ i-11 Lab 0: IC Compiler GUI – MainWindow ....................................................................... i-12 Lab 0: IC Compiler GUI – LayoutWindow .................................................................... i-13 Lab 0A: IC Compiler GUI .............................................................................................. i-14 
Unit 1: Data Setup & Basic Flow 
Unit Objectives ............................................................................................................... . 1-2 
A Word of Caution About Scripts and Flows .................................................................. 1-3 
General IC Compiler Flow ............................................................................................... 1-4 Data Setup .................................................................................................................... .... 1-5 
Logical Libraries ............................................................................................................. . 1-6 
Physical Reference Libraries ........................................................................................... 1-7 Milkyway Structure of Physical Libraries ....................................................................... 1-8 Specify the Logical Libraries ........................................................................................... 1-9 Define ‘logic0’ and ‘logic1’ ........................................................................................... 1-10 IC Compiler Initialization Files ..................................................................................... 1-11 Create a “Container”: Th e Design Library .................................................................... 1-12 
Initial Structure of a Milkyway Design Library ............................................................ 1-13 The Technology File (.tf file) ......................................................................................... 1-14 Example of a Technology File  ...................................................................................... 1-15 The check_library Command ......................................................................................... 1-16 Specify TLU+ Parasitic RC Model Files ....................................................................... 1-17 Timing is Based on Cell and Net Delays ....................................................................... 1-18 TLU+ Models ................................................................................................................ 1- 19 
Mapping file .................................................................................................................. . 1-20 
Read the Netlist and Create a Design CEL .................................................................... 1-21 Must Uniquify Multiply Instantiated Designs ............................................................... 1-22 Linking: Resolving References ...................................................................................... 1-23 Milkyway Design Library with Design Cell .................................................................. 1-24 Shortcut: Import the Netlist ........................................................................................... 1-25 Verify Logical Libraries Are Loaded ............................................................................ 1-26 
Define Logical Power/Ground Connections .................................................................. 1-27 
Apply and Check Timing Constraints ............................................................................ 1-28 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 ii IC Compiler 1 Timing Constraints......................................................................................................... 1-2 9 
Ensure Proper Modeling of Clock Tree ......................................................................... 1-30 Test for Understanding .................................................................................................. 1-31 Apply Timing and Optimization Controls ..................................................................... 1-32 Available Timing and Optimization Controls ................................................................ 1-33 Timing and Optimization Setup Example ...................................................................... 1-34 Enable Multiple Clocks  per Register ............................................................................. 1-35 
Enable Constant Propagation ......................................................................................... 1-36 Enable Multiple Port Net Buffering ............................................................................... 1-37 Enable Constant Net Buffering, if Needed .................................................................... 1-38 Apply Timing Derating for On-Chip Variation ............................................................. 1-39 
Define “Don’t Use” or “P referred” Cells ....................................................................... 1-40 
Keep Spare or Unloaded Cells ....................................................................................... 1-41 Apply Area Constraint for Area Recovery .................................................................... 1-42 Apply a Power and Area Critical Range ........................................................................ 1-43 IC Compiler Organizes Paths into Groups ..................................................................... 1-44 General Problem: Sub-Crit ical Paths Ignored................................................................ 1-45 
Serious Problem: Reg-to-R eg Paths Ignored  ................................................................ 1-46 
Solution: User-Defined Path Groups ............................................................................. 1-47 Define Path Groups for I/O Paths, if needed ................................................................. 1-48 Prevent Buffering of Clock- as-Data Networks .............................................................. 1-49 
Modify Optimization Priority if Needed........................................................................ 1-50 Enable Recovery and Removal Timing Arcs ................................................................. 1-51 Perform a ‘Timing Sanity Check’ .................................................................................. 1-52 Remove Unwanted “Ideal Net/Networks” ..................................................................... 1-53 Save the Design .............................................................................................................. 1-54 
Design Library with New Design Cell ........................................................................... 1-55 UNIX Manipulation of a M ilkyway Database ............................................................... 1-56 
Restoring Variables ........................................................................................................ 1- 57 
Restoring Logical Library and TLU+ Settings .............................................................. 1-58 
Loading an Existing Cell After Exiting ICC .................................................................. 1-59 Data Setup Summary ..................................................................................................... 1-60 Data Setup Example (1 of 3) .......................................................................................... 1-61 Data Setup Example (2 of 3) .......................................................................................... 1-62 Data Setup Example (3 of 3) .......................................................................................... 1-63 Test for Understanding (1 of 2) ..................................................................................... 1-64 Test for Understanding (2 of 2) ..................................................................................... 1-65 General IC Compiler Flow ............................................................................................. 1-66 Design Planning ............................................................................................................. 1 -67 
Load an Existing Floorplan ............................................................................................ 1-68 Placement and Related Optimizations ........................................................................... 1-69 
Clock Tree Synthesis ..................................................................................................... 1-70  
Routing ....................................................................................................................... .... 1-71 
Chip Finishing ................................................................................................................  1-72 
Analyzing the Results (1/2) ........................................................................................... 1-73 Analyzing the Results (2/2) ........................................................................................... 1-74 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 iii IC Compiler 1 Example “run” Script ..................................................................................................... 1-75  
Basic Flow Summary ..................................................................................................... 1-76 Lab 1: Design Setup and Basic Flow ............................................................................. 1-77 
Unit 2: Design Planning 
Unit Objectives ............................................................................................................... . 2-2 
General IC Compiler Flow ............................................................................................... 2-3 Terminology ................................................................................................................... .. 2-4 
ICC Design Planning and Re -Synthesis Flow ................................................................. 2-5 
Select the Design Planning Task GUI ............................................................................. 2-6 Create the Starting Floorplan ........................................................................................... 2-7 Create Physical-only Pad Cells ........................................................................................ 2-8 Specify Pad Cell Locations .............................................................................................. 2-9 Initialize the Floorplan ................................................................................................... 2- 10 
Core Area Parameters .................................................................................................... 2-11 Floorplan After Initialization ......................................................................................... 2-12 
Insert Pad Filler Cells..................................................................................................... 2- 13 
Create P/G Pad Rings..................................................................................................... 2-14 Prior to Virtual Flat Placement ...................................................................................... 2-15 Ignore Extra Routing Layers .......................................................................................... 2-16 Constraining Macros ...................................................................................................... 2-17  
Manual Macro Placement .............................................................................................. 2-18 Macro Constraints: Arrays ............................................................................................. 2-19 Macro Constraints: Legal Orientation Option  .............................................................. 2-20 
Macro Constraints: Anchor Bound Option  ................................................................... 2-21 Macro Constraints: Side  Channel Option  ..................................................................... 2-22 
Macro Constraints: Relative Location ........................................................................... 2-23 Congestion Potential Around Macro Cells .................................................................... 2-24 Apply Global Placement Blockages .............................................................................. 2-25 Apply Specific Placement Blockages ............................................................................ 2-26 Summary: Create the Starting Floorplan ....................................................................... 2-27 Test For Understanding.................................................................................................. 2-28 Perform Virtual Flat Placement ..................................................................................... 2-29 Set Placement Strategy Parameters ................................................................................ 2-30 VF Placement with Virtual IPO (VIPO) ........................................................................ 2-31 Perform Virtual Flat Placement ..................................................................................... 2-32 Hierarchy Aware Placement or Gravity ......................................................................... 2-33 Summary: Virtual Fl at Placement .................................................................................. 2-34 
Reduce Congestion ........................................................................................................ 2-35  
Is the Design Congested? ............................................................................................... 2-36 Understanding the Congestion Calculation ................................................................... 2-37 Congestion Guidelines ................................................................................................... 2-38 Modify Macro Placement Constraints ........................................................................... 2-39 Apply Standard Cell Placement Constraints .................................................................. 2-40 Is High Cell Density Causing Congestion? ................................................................... 2-41 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 iv IC Compiler 1 Reducing Cell Density Hotspots .................................................................................... 2-42 
Coordinate-based Placement Blockages ........................................................................ 2-43 Modify “FP Placement Strategy” Options ..................................................................... 2-44 Placement Strategy Options and Defaults ...................................................................... 2-45 Macro Placement Strategy Examples ............................................................................ 2-46 Perform Congestion-driven Placement .......................................................................... 2-47 Invoke the High Effort C ongestion Strategy ................................................................. 2-48 
Modify the Floorplan ..................................................................................................... 2-49  
“Fix” All Macro Cell Placement .................................................................................... 2-50 Summary: Reduce Congestion ....................................................................................... 2-51 Test For Understanding (1 of 2)..................................................................................... 2-52 Test For Understanding (2 of 2)..................................................................................... 2-53 Synthesize the Power Network (PNS) ........................................................................... 2-54 Power Network Synthesis (PNS) ................................................................................... 2-55 Define Logical Power/Ground Connections .................................................................. 2-56 Apply Power Network Constraints ................................................................................ 2-57 Synthesize and Analyze the Power Network ................................................................. 2-58 Modify Constraints a nd Re-synthesize .......................................................................... 2-59 
Create Virtual Power/Ground Pads if Needed ............................................................... 2-60 Add Additional P/G Pads to TDF and Re-load .............................................................. 2-61 Commit the Power Network .......................................................................................... 2-62 Connect P/G Pins and Create Power Rails .................................................................... 2-63 Analyze the Power Network .......................................................................................... 2-64 Apply Power Net Placement Blockages ........................................................................ 2-65 Perform Incremental Virtual Flat Placement ................................................................. 2-66 Summary: Synthesize the Power Network .................................................................... 2-67 Reduce Delay ................................................................................................................. 2-68 
Global Route and Analyze Congestion .......................................................................... 2-69 Modify Power Net Placement Blockages ...................................................................... 2-70 Return to “Reduce Congestion”, if Needed ................................................................... 2-71 Extract Net Parasitics an d Analyze Timing ................................................................... 2-72 
Perform In-Place Optimization ...................................................................................... 2-73 Modify Floorplan or Re-Synt hesize, if Needed ............................................................. 2-74 
Summary: Reduce Delay ............................................................................................... 2-75 Write Out the Floorplan and DEF Files ......................................................................... 2-76 Write Out Floorplan and DEF Files ............................................................................... 2-77 Re-Synthesize Before Placement ................................................................................... 2-78 Re-Synthesize Before Placement ................................................................................... 2-79 Test For Understanding (1 of 2)..................................................................................... 2-80 Test For Understanding (2 of 2)..................................................................................... 2-81 Summary  ...................................................................................................................... . 2-82 
Lab 2: Design Planning .................................................................................................. 2-83 
Appendix A ....................................................................................................................  2-84 
Floorplan Exploration and Re-Synthesis Flow .............................................................. 2-85 
Floorplan Exploration Objectives .................................................................................. 2-86 Overview: Floorplan Exploration .................................................................................. 2-87 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 v IC Compiler 1 Load the Floorplan Definition (DEF) File ..................................................................... 2-88 
Pre-exploration Setti ngs and Checks ............................................................................. 2-89 
Check Placement Readiness .......................................................................................... 2-90 Perform Low-effort Placem ent Optimization ................................................................ 2-91 
Check and Fix Congestion ............................................................................................. 2-92 Modify the Floorplan ..................................................................................................... 2-93  
Analyze and Fix Timing ................................................................................................ 2-94 Write Out the Floorplan Files ........................................................................................ 2-95 Summary: Floorplan Exploration .................................................................................. 2-96 Summary: 3rd Party Desi gn Planning Flow .................................................................. 2-97 
 
Unit 3: Placement 
Unit Objectives ............................................................................................................... . 3-2 
General IC Compiler Flow ............................................................................................... 3-3 Design Status Prior to Placement ..................................................................................... 3-4 
IC Compiler Placement Flow ........................................................................................... 3-5 
Placement Setup and Checks ........................................................................................... 3-6 “Fix” all Macro Cell Placements ..................................................................................... 3-7 Verify pnet Options and Ignored Layers ......................................................................... 3-8 
Verify Keepout Variable Settings (if used) ..................................................................... 3-9 
Non-Default Clock Routing ........................................................................................... 3-10 Specify Non-Default Routing Rules .............................................................................. 3-11 Check Placement Readiness .......................................................................................... 3-12 Summary: Placement Setup and Checks ........................................................................ 3-13 Design-for-Test (DFT) Setup ......................................................................................... 3-14 Pre-Existing Scan Chains ............................................................................................... 3-15 The Issue with Existing Scan Chains ............................................................................. 3-16 SCANDEF-Based Chain Reordering ............................................................................. 3-17 Re-ordering Chains within Same “Partition” ................................................................. 3-18 Example SCANDEF from Synthesis with DFT ............................................................ 3-19 Example: Placement with Existing Ordering ................................................................. 3-20 Example: Reordering Within Scan-Chains .................................................................... 3-21 Example: Reordering Within Partitions ......................................................................... 3-22 Placement-Based Scan Chain Re-Ordering ................................................................... 3-23 Consider Extreme Block Aspect Ratios ......................................................................... 3-24 Summary: DFT Setup .................................................................................................... 3-25 Power Setup ...................................................................................................................  3-26 
Where Does Power Dissipation Occur? ......................................................................... 3-27 Leakage Power Optimization ......................................................................................... 3-28 Report Multi-Vth Cells .................................................................................................. 3-29 Reducing Dynamic Power Dissipation .......................................................................... 3-30 Switching Activity Terminology ................................................................................... 3-31 SAIF File Provides Switching Activity ......................................................................... 3-32 What if SAIF is Not Available? ..................................................................................... 3-33 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 vi IC Compiler 1 Dynamic Power Optimization: LPP ............................................................................... 3-34 
Dynamic Power Optimization: GLPO ........................................................................... 3-35 Summary: Power Optimization Flow ............................................................................ 3-36 Test For Understanding.................................................................................................. 3-37 Placement and Optimization .......................................................................................... 3-38 Overview: Placement a nd Optimization ........................................................................ 3-39 
The Initial Placement a nd Optimization ........................................................................ 3-40 
Placement and Logic Optimization ................................................................................ 3-41 
Considerations for Using -congestion ............................................................................ 3-42 No Hold Time Fixing ..................................................................................................... 3-43 Post-Placement Analysis ................................................................................................ 3-44 Incremental Optimization .............................................................................................. 3-45 Apply Placement Constraints As Needed ...................................................................... 3-46 Recall Problem: Sub-Critical Paths Ignored .................................................................. 3-47 Solution #1: User-defined Path Groups ......................................................................... 3-48 Solution #2: Apply a Critical Range .............................................................................. 3-49 Solution #3: Prioritizing Path Groups ............................................................................ 3-50 Example: -weight ........................................................................................................... 3- 51 
Complete Example ......................................................................................................... 3-52  
Incremental Logic Optimization: psynopt  .................................................................... 3-53 Summary: Incrementa l Optimization ............................................................................. 3-54 
If the Design is Still Seriously Congested … ................................................................ 3-55 Enable Global Router During Optimization .................................................................. 3-56 Summary: Placement and Optimization ........................................................................ 3-57 Improving Congestion and Setup Timing ...................................................................... 3-58 
Overview: Improve Congestion/Timing ........................................................................ 3-59 refine_placement ............................................................................................................ 3 -60 
psynopt ....................................................................................................................... .... 3-61 
Summary: Improve Conges tion/Setup Timing .............................................................. 3-62 
Test For Understanding (1 of 2)..................................................................................... 3-63 Test For Understanding (2 of 2)..................................................................................... 3-64 Techniques with More User Control.............................................................................. 3-65 Build User-Controlled Balanced Buffer Trees .............................................................. 3-66 Build Skew-Optimized Buffer Trees ............................................................................. 3-67 Relative Placement ......................................................................................................... 3- 68 
What’s Special about Data Path Logic? ......................................................................... 3-69 The Ideal Layout for Data Path ...................................................................................... 3-70 Data Path Layout using Tr aditional P&R Tool.............................................................. 3-71 
Traditional Solution: Custom/Manual Layout ............................................................... 3-72 IC Compiler’s Solution: Relative Placement ................................................................. 3-73 
Features and Benefits of  Relative Placement ................................................................. 3-74 
Candidates for Relative Placement ................................................................................ 3-75 
More Information on Relative Placement ...................................................................... 3-76 Summary  ...................................................................................................................... . 3-77 
Lab 3: Placement............................................................................................................ 3- 78 
 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 vii IC Compiler 1 Unit 4: Clock Tree Synthesis 
Unit Objectives ............................................................................................................... . 4-2 
IC Compiler Flow ............................................................................................................ 4 -3 
Design Status, Start of CTS Phase ................................................................................... 4-4 Is the Design Ready for CTS? ......................................................................................... 4-5 Starting Point before CTS ................................................................................................ 4-6 Clock Tree Synthesis ....................................................................................................... 4- 7 
CTS Goals ..................................................................................................................... ... 4-8 
Clock Tree Synthesis (CTS) (1/2).................................................................................... 4-9 Clock Tree Synthesis (CTS) (2/2).................................................................................. 4-10 Where does the Clock Tree Begin and End? ................................................................. 4-11 Define Clock Root Attributes (1/2)................................................................................ 4-12 Define Clock Root Attributes (2/2)................................................................................ 4-13 Stop, Float and Exclude Pins ......................................................................................... 4-14 Generated and Gated Clocks .......................................................................................... 4-15 
Skew Balancing not Required? ...................................................................................... 4-16 
User-defined or Explicit Stop Pins ................................................................................ 4-17 Defining an Explicit Stop Pin ........................................................................................ 4-18 Defining an Explicit Float Pin ....................................................................................... 4-19 Preserving Pre-Existi ng Clock Trees ............................................................................. 4-20 
Impact of Preexisting Clock Cells ................................................................................. 4-21 Test for Understanding .................................................................................................. 4-22 Specifying Skew / Insertion Delay Targets ................................................................... 4-23 Clock by Clock Settings................................................................................................. 4-24 Set Buffer/Inverter Selection Lists................................................................................. 4-25 When Clock Tree DRCs are Used ................................................................................. 4-26 Non-Default Clock Routing ........................................................................................... 4-27 Specifying Non-Default Rules ....................................................................................... 4-28 Nondefault Rule Options ............................................................................................... 4-29 NDR Recommendations ................................................................................................ 4-30 Invoke CTS: Core Command ......................................................................................... 4-31 clock_opt use recommendation ...................................................................................... 4-32 Effects of Clock Tree Synthesis ..................................................................................... 4-33 Incremental Placement / Optimization ........................................................................... 4-34 
Minimize Hold Time Violations in Scan Paths ............................................................. 4-35 Recommended Flow ...................................................................................................... 4-36 Analysis using the CTS GUI .......................................................................................... 4-37 Analyzing CTS Results .................................................................................................. 4-38 What about CTS Operating Conditions? ....................................................................... 4-39 Clock Tree Optimization ................................................................................................ 4-40 (Embedded) Clock Tree Optimization ........................................................................... 4-41 Balancing Multiple Synchronous Clocks....................................................................... 4-42 Inter-Clock Delay Balancing ......................................................................................... 4-43 Inter-Clock Delay Balanc ing with Offset ...................................................................... 4-44 
SDC Latencies ............................................................................................................... 4 -45 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 viii IC Compiler 1 Core vs. Atomic Commands .......................................................................................... 4-46 
Flow Using Atomic Commands..................................................................................... 4-47 Test for Understanding .................................................................................................. 4-48 Unit Objectives Summary .............................................................................................. 4-49 Lab 4: Clock Tree Synthesis .......................................................................................... 4-50 Appendix A ....................................................................................................................  4-51 
IO Latency Auto Update ................................................................................................ 4-52 Auto Update with Virtual Clocks .................................................................................. 4-53 Appendix B ....................................................................................................................  4-54 
CTS with Logical Hierarchy .......................................................................................... 4-55 Clock Tree Cells Added in Top Hier ............................................................................. 4-56 Appendix C ....................................................................................................................  4-57 
Clock Tree Configuration Control ................................................................................. 4-58 Clock Tree Configuration Syntax .................................................................................. 4-59 Appendix D ....................................................................................................................  4-60 
CTS – Naming Convention ............................................................................................ 4-61  
Unit 5: Multi Scenario Optimization 
Unit Objectives ............................................................................................................... . 5-2 
Timing Analysis during Optimization ............................................................................. 5-3 What about other Situations? ........................................................................................... 5-4 What is the # of Runs? ..................................................................................................... 5- 5 
Corners Represent Delay at Different OpCon ................................................................. 5-6 Multiple Corners – Multiple Modes ................................................................................ 5-7 Scenarios ..................................................................................................................... ..... 5-8 
Multi Scenario Solution in IC Compiler .......................................................................... 5-9 How Are Violations Fixed? ........................................................................................... 5-10 MCMM / Scenario Setup ............................................................................................... 5-11 Defining Scenarios ......................................................................................................... 5- 12 
Global Setup...................................................................................................................  5-13 
Scenario-Specific Setup – S1 ......................................................................................... 5-14 Scenario-Specific Setup – S4 ......................................................................................... 5-15 Switching between Scenarios ........................................................................................ 5-16 CTS Operates with One Scenario .................................................................................. 5-17 Leakage Only Scenario .................................................................................................. 5-18 MCMM Timing Analysis (1/3) ...................................................................................... 5-19 MCMM Timing Analysis (2/3) ...................................................................................... 5-20 MCMM Timing Analysis (3/3) ...................................................................................... 5-21 How Much is Too Much? .............................................................................................. 5-22  MCMM Scenario Reduction Analysis .......................................................................... 5-23  MCMM High Capacity Flow ........................................................................................ 5-24 Analysis Types ............................................................................................................... 5-25 
Launch vs. Capture Path – Use Which Slew?................................................................ 5-26 
Setup is Optimistic in bc_wc ......................................................................................... 5-27 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 ix IC Compiler 1 On Chip Variation Uses Safer Slews ............................................................................. 5-28 
Analysis Types Summary .............................................................................................. 5-29 On-Chip Variation: Single Library ................................................................................ 5-30 On-Chip Variation: Mult iple Libraries .......................................................................... 5-31 
On-Chip Variation: Single  Library + Derating .............................................................. 5-32 
Applying Derating Factors ............................................................................................. 5-33 Global Derating versus Specific Derating ..................................................................... 5-34 
Unit Objectives Summary .............................................................................................. 5-35 Lab 5: Multiple Scenario Optimization ......................................................................... 5-36 Appendix ...................................................................................................................... .. 5-37 
Link Libraries &  PVT Assumptions ............................................................................. 5-38 Unique Identification Of Libraries ................................................................................. 5-39 Library Grouping ........................................................................................................... 5- 40 
Incorrect Library Selected .............................................................................................. 5-41 MCMM Supports up to 3 TLU+ Files ........................................................................... 5-42 Scaling Resistance and Capacitance .............................................................................. 5-43 Filtering Coupling Capacitances .................................................................................... 5-44 TLU+ Temperature Scaling ........................................................................................... 5-45 No Delay Scaling with k-factors in MCMM ................................................................. 5-46  
Unit 6: Routing and Crosstalk 
Unit Objectives ............................................................................................................... . 6-2 
IC Compiler Flow ............................................................................................................ 6 -3 
Design Status, Start of Routing Phase ............................................................................. 6-4 Pre-Route Checks ............................................................................................................. 6-5 
Routing Fundamentals: Goal ........................................................................................... 6-6 Grid-Based Routing System ............................................................................................ 6-7 Routing over Macros ........................................................................................................ 6- 8 
Change the Preferred Routing Direction .......................................................................... 6-9 Routing Operations ........................................................................................................ 6-1 0 
Route Operations: Global Route .................................................................................... 6-11 Route Operations: Global Route Summary ................................................................... 6-12 Route Operations: Track Assignment ............................................................................ 6-13 Route Operations: Detail Routing .................................................................................. 6-14 Route Operations: Search&Repair ................................................................................. 6-15 Test for Understanding .................................................................................................. 6-16 General Flow for Routing .............................................................................................. 6-17 Set Routing Options Prior to Routing Steps .................................................................. 6-18 
Route Clock Nets First ................................................................................................... 6-19  
Core Routing: route_opt ................................................................................................ 6-20 First route_opt Example ................................................................................................. 6-21 Perform Initial Redundant Via ....................................................................................... 6-22 Post Route Optimization Examples ............................................................................... 6-23 Core Routing Strategy .................................................................................................... 6-24  

Table of Contents 
 
Synopsys 20-I-071-SSG-008 x IC Compiler 1 Analysis of the Routing DRC Errors ............................................................................. 6-25 
Fixing DRC Violations .................................................................................................. 6-26 PostRoute Delay Calculation Algorithms ...................................................................... 6-27 Test for Understanding .................................................................................................. 6-28 Galaxy Crosstalk ............................................................................................................ 6 -29 
What is Crosstalk? ......................................................................................................... 6- 30 
Crosstalk-Induced Noise (aka Glitches) ........................................................................ 6-31 Crosstalk-Induced Delay ................................................................................................ 6-32 Crosstalk Prevention in IC Compiler ............................................................................. 6-33 Crosstalk Correction in  IC Compiler ............................................................................. 6-34 
Example Full Cros stalk Flow......................................................................................... 6-35 
Xtalk-Reduction at Work ............................................................................................... 6-36 Wire Sizing (Aka Applying NDRs) ............................................................................... 6-37 Wire Sizing at Work  ..................................................................................................... 6-38  
ECOs: Making Changes Late in the Flow ..................................................................... 6-39 The Two Types of ECO Flows ...................................................................................... 6-40 Functional ECO Flows ................................................................................................... 6-41 Non-Freeze Silicon ECO ............................................................................................... 6-42 Hierarchical ECO Change File Example ....................................................................... 6-43 Inserting Spare Cells for Freeze Silicon ECO ............................................................... 6-44 Protecting Spare Cell Placement .................................................................................... 6-45 Freeze Silicon ECO: Metal Change Only ...................................................................... 6-46 ECO Routing Example .................................................................................................. 6-47 Zroute: Synopsys’ New Routing Technology................................................................ 6-48 State of the Art Routing Technology ............................................................................. 6-49 Concurrent DFM Optimizations  ................................................................................... 6-50 Multi-threaded Throughout ............................................................................................ 6-51 10X Speed-Up On Mainstream Hardware ..................................................................... 6-52 Zroute Is GA in IC Compiler 2008.09! .......................................................................... 6-53 Zroute Users Tell The Story … ..................................................................................... 6-54 Routing & Crosstalk Summary ...................................................................................... 6-55 Lab 6a: Routing & Crosstalk,   Lab 6b: ECO ................................................................ 6-56  
Unit 7: Chip Finishing and DFM 
Unit Objectives ............................................................................................................... . 7-2 
IC Compiler Flow ............................................................................................................ 7 -3 
Design Status, Completion of Routing Phase .................................................................. 7-4 Chip Finishing Flow ........................................................................................................ 7- 5 
Problem: Gate Oxide Integrity ......................................................................................... 7-6 Antenna Rules ................................................................................................................. . 7-7 
Solution 1: Splitting Metal or Layer Jumping ................................................................. 7-8 Solution 2: Inserting Diodes ............................................................................................ 7-9 Antenna Fixing Flow ..................................................................................................... 7-10 Antenna: Misc ................................................................................................................ 7-11 

Table of Contents 
 
Synopsys 20-I-071-SSG-008 xi IC Compiler 1 Random Particle Defects ................................................................................................ 7-12 
Reporting the Critical Area ............................................................................................ 7-13 Solution: Wire Spreading + Widening ........................................................................... 7-14 Controlling Minimum Jog Length ................................................................................. 7-15 Proactive: Density-Driven During GR and TA ............................................................. 7-16 Voids in Vias during Manufacturing ............................................................................. 7-17 Via Control Through Tcl Variables ............................................................................... 7-18 Insert Redundant Vias .................................................................................................... 7-19  
Reporting Redundant Via Count .................................................................................... 7-20 Redundant Via Methodologies ...................................................................................... 7-21 Why Filler Cell Insertion? ............................................................................................. 7-22 Insert Cells to Fill Unused Placement Sites ................................................................... 7-23 Problem: Metal Over-Etching ........................................................................................ 7-24 Solution: Metal Fill inse rt_metal_filler ......................................................................... 7-25 
Timing-Driven Rule-Based Metal Fill ........................................................................... 7-26 Problem: Metal Erosion ................................................................................................. 7-27 Problem: Metal Liftoff ................................................................................................... 7-28  
Solution: Metal Slotting ................................................................................................. 7-29  
DFM Issues and Solutions Summary ............................................................................. 7-30 Final Validation ............................................................................................................. 7-31 
Final Validation: Parasiti cs (SPEF or SBPF) ................................................................ 7-32 
Final Validation: Ne tlist Output..................................................................................... 7-33 
Final Validation: GDS2 Output ..................................................................................... 7-34 Hercules™ VUE Integration .......................................................................................... 7-35 Accessing VUE in IC Compiler ..................................................................................... 7-36 Running VUE................................................................................................................. 7- 37 
Test for Understanding .................................................................................................. 7-38 Summary ....................................................................................................................... . 7-39 
Lab 7: Chip Finishing .................................................................................................... 7-40  
Appendix A ....................................................................................................................  7-41 
Critical Area Definition ................................................................................................. 7-42  
Discrete Defect Size Distribution .................................................................................. 7-43 Appendix B ....................................................................................................................  7-44 
Wire Spreading .............................................................................................................. 7 -45 
Redundant Via Insertion 1/2 .......................................................................................... 7-46 Redundant Via Insertion 2/2 .......................................................................................... 7-47 Filler Cell Insertion ........................................................................................................ 7-48 
Metal Fill Insertion ........................................................................................................ 7 -49 
   
 
  

Table of Contents 
 
Synopsys 20-I-071-SSG-008 xii IC Compiler 1 Unit CS: Customer Support 
Synopsys Support Resources ........................................................................................ CS-2 
SolvNet Online Support Offers ..................................................................................... CS-3 SolvNet Registration is Easy ........................................................................................ CS-4 Support Center: AE-based Support ............................................................................... CS-5 Other Technical Sources ............................................................................................... CS-6 Summary: Getting Support ........................................................................................... CS-7         
 
        

Introduction & Overview 
IC Compiler 1 i-1© 2009 
Synopsys Customer Education Services 
©2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 IC Compiler 1 
2008.09-SP2 

Introduction & Overview 
IC Compiler 1 i-2© 2009 2i-Facilities 
Building Hours 
Restrooms 
Meals Messages 
Smoking 
Recycling Phones 
Emergency EXIT 
Please turn off cell phones and pagers 

Introduction & Overview 
IC Compiler 1 i-3© 2009 3i-Workshop Goal 
Use IC Compiler to perform placement, 
DFT, CTS, routing and optimization, 
achieving timing closure for designs with 
moderate to high design challenges. 

Introduction & Overview 
IC Compiler 1 i-4© 2009 4i-Target Audience 
ASIC, back-end or layout designers 
with experience in standard cell-
based automatic Place&Route. 

Introduction & Overview 
IC Compiler 1 i-5© 2009 5i-Workshop Prerequisites 
/square6You should have knowledge of the following: 
/circle6UNIX and X-Windows 
/circle6A Unix text editor, e.g. Emacs, vi, pine 
/circle6Basic physical design, layout or place&route concep ts 

Introduction & Overview 
IC Compiler 1 i-6© 2009 6i-Introductions 
/square6Name 
/square6Company 
/square6Job Responsibilities 
/square6EDA Experience 
/square6Main Goal(s) and Expectations for this Course 
EDA = Electronic Design Automation 

Introduction & Overview 
IC Compiler 1 i-7© 2009 7i-Curriculum Flow 
Design Compiler 1 IC Compiler 1 
DFT Compiler 1 PrimeTime 1 
PrimeTime: 
Signal Integrity 
TetraMAX 1 You are here 
The Power of Tcl 
3 workshops 
at 3 skill levels The Power of Tcl 
3 workshops 
at 3 skill levels The Power of Tcl 
3 workshops 
at 3 skill levels 
PrimeTime 2: 
Debugging & Constraining 
Custom Clocks 
TetraMAX 2: DSM IC Compiler 2: CTS 
PrimeTime 2: 
Debugging Constraints IC Compiler 2: HDP 
The entire Synopsys Customer Education Services course offering can be f ound at: 
http://training.synopsys.com 
A number of workshops are offered as OnDemand playback training for FREE! Visit the following 
link to view the available workshops: 
http://solvnet.synopsys.com/training 
(see under “Tool and Methodology Training”)

Introduction & Overview 
IC Compiler 1 i-8© 2009 8i-Agenda 
DAY 
11 11
Introduction & Overview i
Data Setup & Basic Flow 1
Design Planning 2


Introduction & Overview 
IC Compiler 1 i-9© 2009 9i-Agenda 
DAY 
22 22
Placement 3
Clock Tree Synthesis 4

Introduction & Overview 
IC Compiler 1 i-10 © 2009 10 i-Agenda 
DAY 
33 33
Multi Scenario Optimization 5
Routing and Crosstalk 6
Chip Finishing and DFM 7
Customer Support CS 

Introduction & Overview 
IC Compiler 1 i-11 © 2009 11 i-High-Level IC Compiler Flow 
Gate-level netlist Synthesis 
Unit 1 
Unit 3 
Unit 4 
Unit 6 
Unit 7 Unit 2 Data Setup 
Design Planning 
Placement 
Clock Tree Synthesis 
Routing 
Chip Finishing 
Unit 5 Multi-Corner/Mode 

Introduction & Overview 
IC Compiler 1 i-12 © 2009 12 i-
Lab 0: IC Compiler GUI – MainWindow 
Command 
Menu Area 
Design View 
Area 
Command 
Prompt and 
Message Area 

Introduction & Overview 
IC Compiler 1 i-13 © 2009 13 i-
Lab 0: IC Compiler GUI – LayoutWindow 
Physical 
command 
Menu Area 
CEL view 
window Context 
Window 
Visibility 
and 
Selection 
control 
Multiple 
tabs 

Introduction & Overview 
IC Compiler 1 i-14 © 2009 14 i-45minutes 
Lab 0A: IC Compiler GUI 
Explore some of IC Compiler’s 
GUI and command line features. 
Note: Lab 0B is an optional lab that 
covers additional GUI features, like 
highlighting layout objects, cross-
probing between the layout and 
schematic, timing analysis, and more. 
Try it if you have some extra time 
during, or after the workshop. Invoke IC Compiler 
Load a saved design 
Configure the 
LayoutWindow 
Navigate the layout 
Use the help 
commands 

Data Setup & Basic Flow 
IC Compiler 1 1-1© 2009 11-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 DAY 
11 11
Introduction & Overview i
Data Setup & Basic Flow 1
Design Planning 2


Data Setup & Basic Flow 
IC Compiler 1 1-2© 2009 21-Unit Objectives 
After completing this unit, you should be able to: 
/square6Perform data setup: 
/circle6Create a Milkyway design library and design cell 
/circle6Load the necessary data required to run IC Compiler
/square6Execute a basic flow for design planning, 
placement, CTS  and routing in IC Compiler 

Data Setup & Basic Flow 
IC Compiler 1 1-3© 2009 31-save_mw_cel ... 
place_opt ... 
Congestion or 
timing violation? No 
... 
group_path ... 
set_power_options ... 
psynopt ... Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel ... 
... A Word of Caution About Scripts and Flows 
This workshop contains many scripts and flow diagra ms 
showing specific commands executed in a specific or der 
/square6These flows DO NOT represent 
“the recommended flow”
/circle6Each flow is just one example 
of many possible flows 
/circle6They help to better organize and 
present the material 
/square6The specific commands and order of 
execution required to achieve the best 
results is completely design dependent 
There is no “golden script” for physical design 

Data Setup & Basic Flow 
IC Compiler 1 1-4© 2009 41-General IC Compiler Flow 
Synthesis 
Data Setup 
Design Planning 
Placement 
Clock Tree Synthesis 
Routing 
Chip Finishing This Unit 
This Unit is primarily about the first step in the IC Compiler flow - Data  Setup. Near the end of the 
Unit we will briefly introduce design planning as well as the “core” com mands for Placement, 
CTS and Routing, for the purposes of performing Lab 1, which takes you through the IC Com piler 
flow (at a high level). 

Data Setup & Basic Flow 
IC Compiler 1 1-5© 2009 51-Data Setup 
Placed, Routed & Optimized Layout with Clock Trees IC 
Compiler 
IP Gate-Level Netlist orca.v Constraints File 
orca.sdc 
Synthesis Data db 
Standard 
cells db 
Macro 
cells db 
Pad 
cells 
Logic/timing Library Files 
Technology File 
abc_6m.tf 
RC Model Files 
(TLU+ )
Physical Data sc          ram32          io 
Physical Library Directories MW 
Standard 
cells MW 
Macro 
cells MW 
Pad 
cells 
These files are not loaded directly into IC Compiler’s “memory”, but must  instead be loaded into a 
project-specific “container”, known as a “design library” (see upcomin g step #3). The next slides 
will cover all the steps associated with data setup. 

Data Setup & Basic Flow 
IC Compiler 1 1-6© 2009 61-Logical Libraries 
/square6Provide timing and functionality information for al l 
standard cells ( and , or , flipflop , …)
/square6Provide timing information for hard macros 
(IP, ROM,  RAM, …)
/square6Define drive/load design rules: 
/circle6Max fanout 
/circle6Max transition 
/circle6Max/Min capacitance 
/square6Are usually the same ones used by Design Compiler 
during synthesis 
/square6Are specified with variables: 
/circle6target_library 
/circle6link_library 
Logical Libraries 
.db 

Data Setup & Basic Flow 
IC Compiler 1 1-7© 2009 71-Physical Reference Libraries 
/square6Contain physical information 
of standard , macro and pad 
cells, necessary for placement 
and routing 
/square6Define placement unit tile 
/circle6Height of placement rows 
/circle6Minimum width resolution 
/circle6Preferred routing directions 
/circle6Pitch of routing tracks 
/circle6…
/square6Are specified with the command: 
/circle6create_mw_lib –mw_reference_library ... reference point 
(typically 0,0) Dimension 
“bounding box”
Pins 
(direction, layer 
and shape) VDD 
GND AB
Y
NAND_1 Blockage 
Symmetry 
(X, Y, or 90º) F
Abstract View 
FF BUF 
INV NOR unit tile 
(site) 
Reference Libraries 
(Milkyway) 

Data Setup & Basic Flow 
IC Compiler 1 1-8© 2009 81-Milkyway Structure of Physical Libraries 
Each physical or reference library is a UNIX direct ory under 
which information is stored in sub-directories call ed views 
/circle6FRAM: Abstract view - Used during P&R 
/circle6LM: (Optional) Logic model view - Contains db logical libraries 1
CEL/ FRAM/ 
and2a1 
and2a2 
….
xor3a27 and2a1 
and2a2 
….
xor3a27 sc 
sc_max.db 
io_max.db 
….LM/ Reference 
library name 
Views Specify with 
link_library 
target_library !ram32 io Specify with 
create_mw_lib 
The CEL view contains cells with the full layout view (all layers). This view i s used when “taping 
out” the design, i.e. writing out the complete stream or GDSII database, which defines all the 
processing layers, and is handed off to the fab for wafer implementation. 
1 The “LM” directory is not required to be present, however, the db libraries are required, whether 
they happen to be stored in the Milkyway reference library structure, or elsewhere in the UNIX file 
structure. 
Even if the Milkyway reference library contains the db or logical libraries, IC Compiler 
does not automatically locate and reference them when the physical lib raries are specified (shown 
later, using the create_mw_lib command). The user must specify logical libraries separately 
with the target_library , link_library and search_path variables (shown on next 
slide). 
If the db files are inside the Milkyway libraries, the search_path points to each LM 
directory inside each Milkyway reference library, otherwise, it point s to whatever other directories 
they happen to be in. !

Data Setup & Basic Flow 
IC Compiler 1 1-9© 2009 91-1. Specify the Logical Libraries 
lappend search_path ./design_data ./scripts $MW_lib s 
lappend search_path [glob $MW_libs/*/LM] 
set link_library "* gates_max.db io_max.db rams_max .db”
set target_library “gates_max.db”
set symbol_library "* gates.sdb io.sdb rams.sdb”Logic/timing Library Files 
.synopsys_dc.setup 
These variables can be entered in the icc_shell environment 
each session , or more conveniently: 
/square6Entered once in the .synopsys_dc.setup file, which is 
automatically read by the tool when ICC is invoked 
/square6Note: Specifying min libraries will be discussed in Unit 5 db 
Standard 
cells db 
Macro 
cells db 
Pad 
cells 
TCL: glob returns files/directories that match the specified pattern
IC Compiler uses the “link library” to resolve all the instantiated component s in a netlist. A 
netlist is resolved if IC Compiler finds a corresponding library cell (in any of the specified 
link_library files) for each leaf cell that is instantiated in the netlist, as wel l as a 
corresponding design in IC Compiler memory (that’s what the * represents) for each sub-design in 
the netlist. This “resolving” happens during the link step, described in a few pages. 
The “target library” usually specifies only the library with basic log ic gates (the standard cells , 
not the IO pads or marcos ). IC Compiler targets this library during logic optimization, when cell 
sizing and logic transformations are performed. The link_library and target_library 
variable settings are usually the same as specified for Design Compil er during synthesis. The 
variables can be conveniently specified in the .synopsys_dc.setup file, which is read 
automatically by IC Compiler (as well as Design Compiler) upon invocat ion, if the file is located 
in the user’s home directory, or more commonly, the “current working direct ory” – the directory in 
which IC Compiler is invoked. 
The search_path variable is a convenient way to shorten file specifications. When a file 
name is specified, IC Compiler looks for that file in the specified list of  search_path 
directories. Without this variable, the user needs to specify the relative pa th to each file, e.g. 
set link_library “* ../db_libs/gates_max.db ../db_libs/io_max... 
After loading the netlist ( read_verilog or import_designs ) you can check what 
libraries are loaded into IC Compiler’s memory with list_libs .
In “lappend search_path [glob $MW_libs/*/LM] ” , $MW_libs represents the 
directory where the reference libraries (like sc , ram32 and io , represented by *) are located. 
The symbol libraries provide icons which are used only when viewing the schematic in the GUI. 
IC Compiler supports the newer CCS (Composite Current Source) libraries. CCS  employs a 
current-based approach that models timing, noise, and power more accurately  for 90 nm and 
smaller designs. 

Data Setup & Basic Flow 
IC Compiler 1 1-10 © 2009 10 1-2. Define ‘ logic0 ’ and ‘logic1 ’
/square6In the netlist, “tie-high”
and “tie-low” inputs may 
be connected to logical 
‘1’ and ‘0’
/square6Define corresponding 
power and ground signal 
names 
/circle6As defined by the names 
of the P/G pre-routes in 
your floorplan P/G assignments 
VDD 
VSS VDD VDD 
VSS VSS 1’b1 
1’b0 Original netlist 
representation 
VDD 
VSS VDD 
VSS 
set mw_logic0_net “VSS”
set mw_logic1_net “VDD”.synopsys_dc.setup 
Set by default in 2008.09-SP2 
In version 2008.09-SP2 the above variables are set by default, as shown above. In some  earlier 
versions (e.g. 2007.12) the variables were required to be explicitly set by th e user every time the 
tool is invoked. 

Data Setup & Basic Flow 
IC Compiler 1 1-11 © 2009 11 1-.synopsys_dc.setup .synopsys_dc.setup .synopsys_dc.setup $SYNOPSYS/admin/setup ~user 
ICC startup directory User’s Specific 
Project Setup User’s General 
Setup 
Standard 
Setup IC Compiler Initialization Files 
Commands in . synopsys_dc.setup are executed upon 
tool startup, in the order shown above. 21
3

Data Setup & Basic Flow
IC Compiler 11-12© 200912 1-3. Create a “Container”: The Design Library
Design Library
design_lib_orcaTechnology File
abc_6m.tfsc          ram32          io
create_mw_lib design_lib_orca -open \
-technology abc_6m.tf \
-mw_reference_library “sc  ram32  io”
set_check_library_options –all
check_library/square6C reate a design library
/square6Specify the tech file
and reference libsMW
Standard
c
ellsMW
Macro
c
ellsMW
Pad
c
ells
Specified files and libraries are assumed to be located in “CWD” or in the search_path directories.
The design library is a Milkyway UNIX-based database structure, created by the user, which will 
eventually contain all the associated input data required for placement, CTS, routing, etc, as well 
as the physical “design cell” or layout. 
The first step in data-setup is to create the design library. This entails giving the library a user-
defined name and specifying the technology file as well as the physical “reference” libraries 
(layout cells for standard cells, macro and IO pad cells). While the technology file is actually 
loaded or read into the design library, the reference libraries are not. The design library creates 
“pointers” to the UNIX location of the libraries – it “references” them instead of loading them.
In the example above the technology file name and the library directory names were specified 
without their UNIX directory “location”. This works if the specified files and directories happen to 
be located in the “current working directory” (CWD) – the directory from which IC Compiler was 
invoked, or, if their location directories are appended to the search_path variable as shown 
previously: lappend search_path ./design_data ./scripts $MW_libs
lappend search_path [glob $MW_libs/*/LM])

Data Setup & Basic Flow 
IC Compiler 1 1-13 © 2009 13 1-Initial Structure of a Milkyway Design Library 
./design_lib_orca/ 
Database 
T.O.C, 
technology 
data etc. ….…MW Design Library 
lib 
lib_1 
lib_bck 
The result of the create_mw_lib command is a Milkyway design library. The design library is 
contained under a UNIX directory which represents the user-defined name of the design library. 
Initially, this library contains only a few lib* files. These files maint ain a table-of-contents of the 
library, the technology file data that was read in, pointers to the refer ence libraries, and more. The 
design library will be populated with additional directories and files  after additional data setup 
steps and eventual P&R steps. 

Data Setup & Basic Flow 
IC Compiler 1 1-14 © 2009 14 1-The Technology File (.tf file) 
/square6The technology file is unique to each technology 
/square6Contains metal layer technology parameters: 
/circle6Number and name designations for each layer/via 
/circle6Physical and electrical characteristics of each lay er/via 
/circle6Design rules for each layer/Via (Minimum wire width s 
and wire-to-wire spacing, etc.) 
/circle6Units and precision for electrical units 
/circle6Colors and patterns of layers for display 
/circle6…

Data Setup & Basic Flow 
IC Compiler 1 1-15 © 2009 15 1-Example of a Technology File 
Technology  { 
unitTimeName = "ns" 
timePrecision = 1000 
unitLengthName = "micron" 
lengthPrecision = 1000 
gridResolution = 5 
unitVoltageName = "v" 
}
... 
Layer  "m1" { 
layerNumber = 16 
maskName = "metal1" 
pitch = 0.56 
defaultWidth = 0.23 
minWidth = 0.23 
minSpacing = 0.23 
... abc_6m.tf 

Data Setup & Basic Flow 
IC Compiler 1 1-16 © 2009 16 1-The check_library Command 
/square6Reports library inconsistencies, for example: 
/circle6Between logic ( link_library ) and physical libraries: 
/rhombus6Missing cells 
/rhombus6Missing or mismatched pins 
/circle6Within physical libraries: 
/rhombus6Missing CEL (layout ) or FRAM (abstract ) view cells 
/rhombus6Duplicate cell name in multiple reference libraries 
/square6Recommended after creating the design library 
create_mw_lib ... 
set_check_library_options –all 
check_library 

Data Setup & Basic Flow 
IC Compiler 1 1-17 © 2009 17 1-4. Specify TLU+ Parasitic RC Model Files 
Design Library 
design_lib_orca Technology File 
abc_6m.tf sc          ram32          io /square6Specify the TLU+ RC model 
files to be used 
/square6Perform sanity check on 
settings and files 
RC Model Files 
(TLU+ )
set_tlu_plus_files \
-max_tluplus abc_max.tlup \
-min_tluplus abc_min.tlup \
-tech2itf_map  abc.map 
check_tlu_plus_files MW 
Standard 
cells MW 
Macro 
cells MW 
Pad 
cells 
TLU+ models are described on the next pages. 
IC Compiler requires TLU+ models for a successful design flow from placement through routing. 
While it may be possible to accomplish some tasks without TLU+ models, successful completion 
of the entire design flow can not be assured without them. 
The check_tlu_plus_files command checks the existence of the specified files and 
performs a sanity check on the TLU+ settings. 

Data Setup & Basic Flow 
IC Compiler 1 1-18 © 2009 18 1-Timing is Based on Cell and Net Delays 
/square6ICC calculates delay for every cell and every net 
/square6To calculate delays, ICC needs to know each net’s 
parasitic Rs and Cs Cell Delay = ƒƒ ƒƒ(Input Transition Time, C net + C pin )
Net Delay = ƒƒ ƒƒ(R net , C net + C pin ) 0.5 ns 
Cnet Cpin Rnet 
Cell delay is calculated using non-linear delay models, which are store d in the logical libraries (.db 
files). NLDM is highly accurate as it is derived from SPICE charac terizations. The delay is a 
function of the input transition time of the cell (TInput) [also called slew ], the driving strength of 
the cell (RCell), the wire capacitance (CNet) and the pin capacit ance of the receivers (CPin). A 
slow  input transition time will slow the rate at which the cell’s transi stors can change state (from 
“on” to “off”), as well as a large output load (Cnet + Cpin), thereby incre asing the “delay” of the 
logic gate. 
There is another NLDM table in the library to calculate output transition. O utput transition of a 
cell becomes the input transition of the next cell down the chain. 
Output Transition (ns ).005 . 05 .10 .15 
0.00 0.10 0.20 0.37 0.60 
0.50 0.18 0.30 0.49 0.80 
1.00 0.25 0.40 0.62 1.00 Output Load (pF) 
Input Trans (ns )
Cell Delay (ns) .005 .05 .10 .15 
0.0 .1 .15 .2 .25 
0.5 .15 . 23 .3 .38 
1.0 .25 .4 .55 .75 Output Load (pF) Input Trans (ns) 


Data Setup & Basic Flow 
IC Compiler 1 1-19 © 2009 19 1-TLU+ Models 
/square6IC Compiler calculates interconnect C and R values 
using net geometry and the TLU+ look-up tables 
/square6Models UDSM process effects 
Single 
Process File 
(ITF) 
TLU+ 
ICC, PC, Astro ICC, PC, Astro ™™
nxtgrd 
Star Star --RCXT RCXT ™™UDSM Process Effects 
/square4Conformal Dielectric 
/square4Metal Fill 
/square4Shallow Trench Isolation 
/square4Copper Dishing: 
•Density Analysis 
•Width/Spacing 
/square4Trapezoid Conductor 
/square6Some vendors provide only 
an ITF process file 
/square6User must then generate 
TLU+ from ITF (see below) 
UDSM = Ultra Deep SubMicron 
ITF = Interconnect Technology Format 
If the vendor did not provide TLU + files, the user can generate TLU + from ITF data. This requires 
a Star-RCXT license: 
unix% grdgenxo -itf2TLUPlus -i <ITF file> -o <TLU+ file >
where: -itf2TLUPlus generates TLU + instead of a nxtgrd file 
-iis the ITF file 
-ois the output, binary TLU+ model file 
When generating TLUPlus models with grdgenxo , the –itf2TLUPlus option must be the first 
option specified. Always use the latest Star-RCXT release to generate th e models. 
More and more ASIC vendors are supporting TLU + models and they may provide the binary cap 
table files for your use. 
If possible, generate TLU+ models for at least two operating corners: min and max. 

Data Setup & Basic Flow 
IC Compiler 1 1-20 © 2009 20 1-Mapping file 
The Mapping File maps the technology file (.tf) 
layer/via names to Star-RCXT (.itf) layer/via names . 
Layer  "METAL" { 
layerNumber = 14 
maskName = " metal1 "
…DIELECTRIC cm_extra3 { THICKNESS=0.06 ER=4.2 } 
CONDUCTOR cm { THICKNESS=0.26 WMIN=0.16 …}
DIELECTRIC diel1d { THICKNESS=0.435 ER=4.2 } 
…abc.itf abc.tf 
conducting_layers 
poly poly 
metal1 cm 
metal2 cm2 
…abc.map 
The itf information is contained in the TLU+ file. 
The map file is needed even when the tf and itf names are matched 1 for 1. 

Data Setup & Basic Flow 
IC Compiler 1 1-21 © 2009 21 1-read_verilog –netlist orca.v 
current_design ORCA 
uniquify 
link 
save_mw_cel –as ORCA 5a. Read the Netlist and Create a Design CEL 
Design Library 
design_lib_orca 
Design ‘CEL’ORCA Technology File 
abc_6m.tf sc          ram32          io 
RC Model Files 
(TLU+ )
Gate-Level Netlist orca.v 
Synthesis Data MW 
Standard 
cells MW 
Macro 
cells MW 
Pad 
cells 
IC Compiler can also read the ddc netlist format using read_ddc . ddc is a format that can be 
written out by Design Compiler after synthesis. It is a binary format w hich can contain design 
constraints and attributes, in addition to the netlist information. 
ICC can read in one complete hierarchical file: read_verilog file_hier.v 
Or multiple files: 
read_verilog top.v; read_verilog sub1.v; ... OR 
read_verilog “top.v sub1.v sub2.v ...”
current_design : Since a netlist can contain a hierarchical design with many sub-desig ns, the 
user should specify which design (usually the top-level Verilog module ) is the current design to be 
worked on by IC Compiler. 
uniquify and link : Described on the next pages. 
save_mw_cel : Creates the starting Milkyway design cell (view name CEL). Initially, prior to 
design planning and placement, the design CEL view consists of yellow recta ngles, which 
represent all of the netlist leaf cells (standard, macro and IO pad ce lls), all stacked on top of each 
other at the origin. The design cell will undergo major “physical” chan ges during the physical 
design steps of design planning, placement, CTS, routing, etc. This command also sav es the logic 
(db) library and TLU+ model information with the CEL. However, by default, thi s information is 
not recalled by ICC once the CEL is closed and later re-opened. 

Data Setup & Basic Flow 
IC Compiler 1 1-22 © 2009 22 1-ORCA Must Uniquify Multiply Instantiated Designs 
/square6IC Compiler does not support non-uniquified 
designs, i.e. designs with multiple instantiations!
/square6If incoming netlist is not uniquified , do so first! 
current_design ORCA 
uniquify 
PARSER PARSER 
PARSER 
PARSER U1 
U2 
U3 ORCA 
PARSER_0 
PARSER_1 
PARSER_2 U1 
U2 
U3 
Pre-uniquify Post-uniquify 
A uniquified design allows IC Compiler to optimize the logic within each instance i ndividually, 
based on its unique environment (i.e. input drivers, output load, input data arrival time s, output 
data required times, etc). 
It is acceptable to always include the uniquify command in your script. If there are no 
multiply-instantiated sub-designs, the command does nothing. 

Data Setup & Basic Flow 
IC Compiler 1 1-23 © 2009 23 1-Linking: Resolving References 
/square6Gate-level netlists contain references to hierarchi cal 
sub-designs, as well as standard cells and macros, 
which are stored in the logical libraries 
/square6The link command loads the specified link libraries 
into ICC memory and ensures that all references in 
the netlist can be “resolved”
link 
rams.db gates.db 
io.db Link 
libraries risc_core 
sdram_if pci_core 
*Designs 
(modules or 
entities) 
Gate-Level 
Netlist(s) pci_cor 
esdram_i 
f
ICC memory 
The asterisk ( *) specified in the link_library variable represents IC Compiler’s memory. 
Any designs that are read in with read_verilog/ddc , or import_designs , are stored in 
ICC memory. During link , ICC tries to “resolve” every instance in the netlist as follows: It  first 
looks for referenced designs in memory (these would be sub-design that were rea d in prior to 
link . If not found in memory, ICC then looks for leaf cells in the specified list of li nk libraries. If 
all instances (or references) are resolved, link simply returns a “1”, signaling a successful link. 
If link is unable to resolve one or more references, warning messages are issued, al lowing the 
user to fix the problem before proceeding. 

Data Setup & Basic Flow 
IC Compiler 1 1-24 © 2009 24 1-Milkyway Design Library with Design Cell 
./design_lib_orca/ 
CEL/ ….…
ORCA:1 Saved Cell 
lib 
lib_1 
lib_bck The save_mw_cel command creates a new CEL view 

Data Setup & Basic Flow 
IC Compiler 1 1-25 © 2009 25 1-5b. Shortcut: Import the Netlist 
import_designs orca.v \
-format verilog  \
-top ORCA 
Replaces: 
read_verilog –netlist orca.v 
current_design ORCA 
uniquify 
link 
save_mw_cel –as ORCA Format can be 
verilog, db, ddc 
By default, the command shown will read the netlist then save the design to a C EL named after the 
top design (ORCA in this example). If you want to choose a different name, use  the “-cel” option. 

Data Setup & Basic Flow 
IC Compiler 1 1-26 © 2009 26 1-6. Verify Logical Libraries Are Loaded 
Ensure that all the required logical libraries (spe cified 
by set link_library ) have been loaded 
/circle6Note: This command can be executed only after readi ng 
and linking the netlist list_libs 
Logical Libraries: 
------------------------------------------------------------------------- 
Library              File                    Path 
------- ---- ---- 
cb13fs120_tsmc_max   sc_max.db          /projects/XYZ_design/ref/db 
cb13io320_tsmc_max   io_max.db          /projects/XYZ_design/ref/db 
ram8x64_max          ram8x64_max.db     /projects/XYZ_design/ref/db 
ram16x128_max        ram16x128_max.db   /projects/XYZ_design/ref/db 
gtech                gtech.db           /global/apps3/icc_2008.09/libraries/syn 
standard.sldb        standard.sldb      /global/apps3/icc_2008.09/libraries/syn 
The gtech and standard libraries are generic libraries that are loaded by def ault – used during synthesis 

Data Setup & Basic Flow 
IC Compiler 1 1-27 © 2009 27 1-7. Define Logical Power/Ground Connections 
Define “logical connection”
between P/G pins and nets 
/circle6Does not make any 
physical connections 
derive_pg_connection -power_net VDD -power_pin VDD \
-ground_net VSS -ground_pin VSS 
check_mv_design –power_nets Pin 
definitions VDD 
VSS VDD VDD 
VSS VSS 
Logical P/G 
connections Power Net: VDD 
Ground Net: VSS 

Data Setup & Basic Flow 
IC Compiler 1 1-28 © 2009 28 1-Design Library 
design_lib_orca 
Design ‘CEL’ORCA Constraints File 
orca.sdc 
create_clock –period 10 …… 
set_input_delay –max 1.2 ….
set_output_delay –max 2.5 
….8. Apply and Check Timing Constraints 
read_sdc orca.sdc 
check_timing 
report_timing_requirements 
report_disable_timing 
report_case_analysis 
Gate-Level Netlist orca.v Technology File 
abc_6m.tf sc          ram32          io 
RC Model Files 
(TLU+ )MW 
Standard 
cells MW 
Macro 
cells MW 
Pad 
cells 
After applying timing constraints, it is recommended to invoke check_timing to ensure that 
the design is completely constrained. IC Compiler places, but will not optimi ze logic paths that are 
not constrained for timing. This check will flag any unconstrained paths - paths missing an input or 
output delay, or register to register paths where the clock is not defined. It does not check for 
missing external loads or drive characteristics! 
The report_timing_requirements command can be used to check if the design contains 
any false or multicycle paths, or any asynchronous min- or max-delay cons traints. 
The report_disable_timing command reports disabled timing arcs in the current design.  
Paths containing one or more disabled timing arcs will not be optimized for ti ming. Timing arcs 
can be disabled by the user ( set_disable_timing ) ,or automatically by the tool during 
timing analysis in order to break timing loops or when propagating constants i n the design. 
The report_case_analysis command reports ports or pins that are set to a constant logic 
value 1 or 0 by the constraint set_case_analysis . Case analysis is a way to specify a given 
“mode” of  a design  without altering  the  netlist structure. 

Data Setup & Basic Flow 
IC Compiler 1 1-29 © 2009 29 1-Timing Constraints 
/square6“Timing Constraints” are required to communicate 
the design’s timing intentions to IC Compiler 
/square6They should be the same ones used for synthesis 
with Design Compiler (preferably in SDC format) 
create_clock –period 10 [get_ports clk] 
set_input_delay 4 –clock clk \
[get_ports sd_DQ[*]] 
set_output_delay 5 –clock clk 
[get_ports sd_LD] 
set_load 0.2 [get_ports pdevsel_n] 
set_driving_cell –lib_cell buf5 \
[get_ports pdevsel_n] 
... 
SDC = Synopsys Design Constraints Not needed if reading in a 
constrained ddc design !
SDC format contains “pure” timing-related constraints – no optimization dir ectives that are 
understood only by Design Compiler, e.g. set_ultra_optimization , 
set_optimize_registers , etc. 

Data Setup & Basic Flow 
IC Compiler 1 1-30 © 2009 30 1-Pre-CTS 
clock 
modeling 9. Ensure Proper Modeling of Clock Tree 
/square6Ensure your SDC constraints model estimates of cloc k 
skew, latency and transition times for all clocks 
/square6Ensure no clocks are defined as 
“propagated” clocks D    Q 
Clk 
D    Q report_clock -skew 
report_clock 
Clock       Period   Waveform   Attrs   Sources 
---------------------------------------------------- 
SDRAM_CLK     7.50   {0 3.75}   p       {sdram_clk} 
SYS_2x_CLK    4.00   {0 2}              {sys_2x_clk} Rise    Fall  Min Rise  Min Fall   Uncertainty 
Object        Delay   Delay  Delay     Delay     Plus  Minus 
------------------------------------------------------------- 
SYS_2x_CLK     0.80    0.80    0.40      0.40    0.10   0.20 
SDRAM_CLK         - - - - 0.10   0.15 
Max Transition   Min Transition 
Object         Rise      Fall   Rise      Fall 
-------------------------------------------------- 
SYS_2x_CLK     0.07      0.07      - -
SDRAM_CLK      0.07      0.07      - -
Uncertainty (plus or minus) models the difference in arrival times of the clock signal at the clo ck 
pins of flip-flops, due to skew, jitter, or margin. Minus uncertainty reduces a path’s maximum 
allowable delay time by being subtracted from the capturing setup cl ock edge. Plus uncertainty 
increases a path’s minimum required delay time by being added to the c apturing hold clock edge. 
Uncertainty is modeled by the SDC command set_clock_uncertainty .
Delay (rise or fall , min or max) models the propagation or insertion delay through the clock 
network. Max delays are used for setup timing checks, and min delays for hold. 
Propagation delay is modeled by the SDC command set_clock_latency .
Transition (rise or fall , min or max) models the transition times at the clock pin of the sequential 
device. Max transitions are used for setup timing checks, and min transitions for hold. 
Transition is modeled by the SDC command set_clock_transition .
Propagated clock forces IC Compiler to calculate the ACTUAL propagated delays through the  
clock network, to find the actual skews, latencies and transitions. This is us eful after clock tree 
synthesis (CTS). Before CTS there is no clock network, so IC Compiler should i nstead use the 
values defined by the clock network modeling commands listed above. 
Propagated clocks are enabled by the SDC command set_propagated_clock ., and if 
necessary can by removed (prior to CTS) by remove_propagated_clock .

Data Setup & Basic Flow 
IC Compiler 1 1-31 © 2009 31 1-Test for Understanding 
1. Why does IC Compiler require logical libraries in  
addition to physical libraries? 
2. What is the difference between a Milkyway design 
library and reference library? What do they have in 
common? 
3. The shortcut import_designs includes reading in 
the timing constraints file. True / False 
4. After importing a Verilog netlist it is not necessary 
to load an SDC file. True / False 
5. Clock uncertainty 
a. Is used to model clock skew pre-CTS 
b. Is used during CTS as the maximum skew constraint 
c. Is used to model clock skew post-CTS 
d. A and B 1. The logical libraries provide ICC with logic functionality and timi ng information which is 
needed during placement, CTS and routing optimizations. This information is NOT st ored in 
the physical libraries. 
2. The design library acts as a container for ALL the design-relate d data used by IC Compiler. A 
reference library, such as a standard cell, IO pad cell, or macro/I P library, contains the physical 
footprints of the leaf cells that are instantiated or referenced in th e netlist, and will be placed 
and routed together to form the final design layout. They are both Milkyway  databases. 
3. False . import_designs performs the following: read_verilog/ddc, current_design, uniquify, 
link, save_mw_cel –as, open_mw_cel . When importing a ddc netlist, the constraints should 
already be part of the ddc database so they don’t need to be explicitly applied. If reading in a 
Verilog netlist you must use read_sdc to apply the constraints. 
4. False . A Verilog netlist does not contain any constraints, so the constraints must be applied 
separately by reading in an SDC constraints file. If the synthesized d esign was saved in ddc 
format and then imported into ICC, the constraints are included in the netl ist and are not 
required to be read in separately. 
5. A . CTS will try to minimize clock skew independent of set_clock_uncertainty , and 
after CTS, the actual “propagated” clock network delays are used to ca lculate the actual skew. 

Data Setup & Basic Flow 
IC Compiler 1 1-32 © 2009 32 1-10. Apply Timing and Optimization Controls 
/square6Timing and optimization in IC Compiler is controlle d 
by many variables and commands, for example: 
set timing_enable_multiple_clocks_per_reg true 
set_fix_multiple_port_nets -all -buffer_constants 
group_path -name INPUTS -from [all_inputs] 
/square6These variables and commands can affect design 
planning, placement, CTS and routing 
/square6Therefore, they should be applied prior to design 
planning 
/square6Learning all the available variables and commands 
can be a challenge – the GUI provides help! source tim_opt_ctrl.tcl 

Data Setup & Basic Flow 
IC Compiler 1 1-33 © 2009 33 1-Available Timing and Optimization Controls 
Use the GUI to find out what timing and 
optimization settings are available 
Use the man pages to learn more 
Use the GUI to perform your initial setup, 
then copy the variables/commands into a 
control setup file for subsequent uses 

Data Setup & Basic Flow 
IC Compiler 1 1-34 © 2009 34 1-Timing and Optimization Setup Example 
The following slides describe some 
common control settings 

Data Setup & Basic Flow 
IC Compiler 1 1-35 © 2009 35 1-Enable Multiple Clocks per Register 
/square6By default timing analysis (TA) will only consider one 
clock per register 
/circle6May pick optimistic or incorrect launching and capt uring clocks 
/square6Always enable multiple clocks per register 
/circle6Set false paths as needed 
/circle6TA will now consider the correct clock timing 
set timing_enable_multiple_clocks_per_reg true 
set_false_path –from [get_clocks C1] –to [get_clock s C2] 
set_false_path –from [get_clocks C2] –to [get_clock s C1] 
Default: TA picks one of four possible 
clock combinations (see notes) With the above settings: TA 
considers C1 /barb2rightC1 and C2 /barb2rightC2 D    Q D    Q 
C1 
C2 0
1
sel 
By default, timing analysis (which happens during placement, CTS, routing and rel ated 
optimizations) can only select one clock per register. In the example  above, since the clock 
selection per register is independent of any other register and doe s not perform any “logic 
analysis”, the launching versus capturing clock may be any one of the f ollowing four possibilities, 
of which the middle two are logically false combinations: 
C1 /barb2rightC1 
C1 /barb2rightC2 
C2 /barb2rightC1 
C2 /barb2rightC2 
With the above settings timing analysis considers both C1 /barb2rightC1 and C2 /barb2rightC2 and uses the faster 
clock for setup timing optimizations. 
Note: The above settings are not needed if set_case_analysis is used instead, to define the 
value of the MUX select input. This will force timing analysis to use the  “selected” clock pair. In 
the example above, with set_case_analysis 1 [get_pins sel] timing analysis will 
only consider C2 /barb2rightC2 timing. 

Data Setup & Basic Flow 
IC Compiler 1 1-36 © 2009 36 1-Enable Constant Propagation 
/square6By default IC Compiler will not propagate constants
/circle6Control and other signals tied high/low are not con sidered 
during timing analysis (TA) – may result in incorrec t TA 
/square6Always enable constant propagation 
set case_analysis_with_logic_constants true 
By default: No constant propagation –
TA picks one of four clock combinations 
With above setting: Constant 
Propagation forces TA to select Clk2 /barb2rightClk2 D    Q D    Q 
0
1Clk1 
Clk2 
Vdd 
Tie-hi 
Note: If the above variable is false , constant propagation will occur on nodes that have 
set_case_analysis applied. 

Data Setup & Basic Flow 
IC Compiler 1 1-37 © 2009 37 1-Enable Multiple Port Net Buffering 
/square6By default IC Compiler will not buffer nets that ar e 
connected to two or more ports 
/circle6Good design practice dictates that each port has a 
unique driver 
/square6Always enable multiple port net buffering 
set_fix_multiple_port_nets -all -buffer_constants 
Default: Multiple port 
nets without buffering With multiple port 
net buffering Block1 Vdd 
Tie-hi 
Block1 Vdd 
Tie-hi 
set_fix_multiple+port_nets arguments: 
[-default] (no fixing of multi-port nets) 
[-all] (fix feedthrough and multiple output port nets – not constants) 
[-feedthroughs] (fix feedthroughs ) 
[-outputs] (fix multiple output port nets) 
[-constants] (duplicate constants driving multiple ports) 
[-buffer_constants] (buffer constants driving multiple ports) 
[design_list] 

Data Setup & Basic Flow 
IC Compiler 1 1-38 © 2009 38 1-Enable Constant Net Buffering, if Needed 
/square6By default place_opt will buffer all nets except: 
/circle6Clock networks (done later by CTS) 
/circle6Constant nets (tied high or low) 
/square6Un-buffered constant nets may be susceptible to cro sstalk 
/square6Constant net buffering can be enabled with: 
set_auto_disable_drc_nets –constant false 
Default tie-high net Tie-high net with buffering NVdd 
Tie-hi 
CLK Vdd 
Vss NVdd 
Tie-hi 
CLK Vdd 
Vss 
By default, “design rule constraint” (DRC) checking and fixing is disa bled for clock and constant 
nets, which in turn means that these nets are not buffered, during place_opt. Bufferi ng on constant 
nets can be enabled with the above command. These are the DRCs – they govern n et buffering: 
max_transition , max_capacitance and/or max_fanout .
In the example above the buffered constant net is much less susceptible to la rge crosstalk glitches 
because the cross-coupling capacitance is greatly reduced due to the short er wire length, and the 
net is being driven by an active buffer, which can usually maintain and rec over a cross-coupled 
signal better than a passive tie-high cell. 

Data Setup & Basic Flow 
IC Compiler 1 1-39 © 2009 39 1-Apply Timing Derating for On-Chip Variation 
/square6By default timing analysis uses the same PVT operat ing 
conditions for data as well as clock paths 
/circle6Local PVT variations are not taken into account 
/circle6May lead to optimistic timing results 
/square6It is recommended to apply some timing derating to the 
data path - ask your vendor what percentage to use 
set_timing_derate -max –early 0.95 
This example speeds up the clock path by 5% during 
setup analysis under maximum PVT operating conditions 
D    Q D    Q 
Data path 
Clock path 
This command is used to add some “timing margin”, which means to reduce the requir ed setup 
time and/or increase the required hold time. The –late option specifies how late a signal (data or 
clock path) could arrive. The  derate factor specified with the -late option multiplies data path 
delays for setup checks and clock path delays for hold checks. The derate factor specified with the 
-early option specifies how early the signal could arrive, and therefore multipli es data paths for 
hold checks and clock paths for setup checks. 
The –max option specifies  that  the derate value is to be applied to setup checks using t he 
maximum PVT operating condition . The –min option specifies  that  the derate value is to be 
applied for hold checks using the minimum PVT operating condition . If neither the -min n or     
-max option is specified, the derate value is applied to both setup and hold, for worst and best 
case operating conditions, respectively. PVT = Process, Voltage and Te mperature. 
The –data option indicates that the derate value is to apply to elements on the data pat h only. 
The –clock option indicates that the derate value is to apply to elements on the cloc k path only. 
If  neither the -clock or -data option is specified, the derate value is applied to both clock 
and data paths. 

Data Setup & Basic Flow 
IC Compiler 1 1-40 © 2009 40 1-Define “Don’t Use” or “Preferred” Cells 
/square6By default all cells available in the library can b e used 
during buffering and optimization 
/square6You may want to restrict the use of specific cells, for 
example: 
/circle6Big drivers (EM issues) and/or very weak drivers 
/circle6Delay cells and/or clock cells 
/square6You may prefer the use of certain cells, when possible: 
/circle6Specific buffers preferred for hold time fixing set_dont_use <off_limit_cells> 
set_prefer -min <hold_fixing_cells> 
EM = Electro-migration 

Data Setup & Basic Flow 
IC Compiler 1 1-41 © 2009 41 1-Keep Spare or Unloaded Cells 
/square6By default any cell with unconnected output(s) will  be 
deleted by IC Compiler 
/square6If you need to keep such cells, spare cells , for example, 
you can turn off auto-deletion: 
set physopt_delete_unloaded_cells false 
EM = Electro-migration 

Data Setup & Basic Flow 
IC Compiler 1 1-42 © 2009 42 1-Apply Area Constraint for Area Recovery 
/square6Area recovery takes advantage of paths with positiv e 
timing slack to reduce or “recover” area 
/circle6Through cell down-sizing and buffer removal 
/square6Area recovery can help to reduce congestion and 
power consumption and is recommended during 
placement ( place_opt –area_recovery) 
/square6To maximize area recovery it is recommended to 
apply a zero maximum area constraint 
set_max_area 0 

Data Setup & Basic Flow 
IC Compiler 1 1-43 © 2009 43 1-Apply a Power and Area Critical Range 
/square6Area and power optimization take 
advantage of paths with positive 
timing slack 
/circle6Slack can be reduced to zero, by default 
/circle6Zero slack or margin may cause 
some near-critical nets to violate 
timing later, during CTS or routing 
/square6Apply a “critical range” to force 
optimization to preserve some 
positive timing slack 
/circle6Margin may reduce timing violations later 
/circle6Guideline: Use ~ 10% of the smallest 
clock period 
set physopt_power_critical_range <t> 
set physopt_area_critical_range <t> A   B   C   D Path Delay 
Timing paths 
Paths B and D can be slowed down to 
optimize for leakage power and/or area. 
Paths A and C will be left alone. t
Maximum Delay Constraint Preserved 
positive slack 
(critical_range) 
Note: The term “critical range” as it refers to power and area optimization above is very different 
than timing “critical range”.
When the physopt_power/area_critical_range variables above are applied, fewer 
paths are optimized for power/area, respectively, which may help timing  in later phases of P&R. 
When a timing critical range is set, more paths are optimized for timing (discussed later). 

Data Setup & Basic Flow 
IC Compiler 1 1-44 © 2009 44 1-IC Compiler Organizes Paths into Groups 
/square6Paths are grouped by the clocks 
controlling their endpoints 
/circle6Path groups inherit the name of the 
related end-point clock, by default 
/square6IC Compiler optimizes each path 
group in turn, starting with the 
critical path in each group D  Q 
QB D  Q 
QB FF2 FF3 MY_DESIGN 
A
CLK2 
CLK3 Z
path4 
Timing Paths path1 path2 path3 D  Q 
QB FF1 CLK1 D  Q 
QB FF1 CLK4 
D  Q 
QB FF1 CLK2 Y
path3 CLK4 
path2 CLK3 
Path Groups CLK2 
path1 
path4 
report_path_group: Reports the path groups which were defined in the current design.

Data Setup & Basic Flow 
IC Compiler 1 1-45 © 2009 45 1-General Problem: Sub-Critical Paths Ignored 
/square6By default, optimization within a path group stops 
when: 
/circle6All paths in the group meet timing, or 
/circle6IC Compiler cannot find a better optimization solut ion for 
the critical path – it reaches a point of diminishin g returns 
/circle6Sub-critical paths are not optimized - to save run t ime! 
Delay 
Paths in same path group Constraint Goal Critical path is optimized as much as possible 
Sub-critical paths are NOT optimized 
What if the 
critical path is an 
I/O path? 
ANSWER: 
See the next slide …

Data Setup & Basic Flow 
IC Compiler 1 1-46 © 2009 46 1-To_Be_Synthesized Serious Problem: Reg-to-Reg Paths Ignored 
In a sub-block with poor logic hierarchy partitioni ng, the I/O 
constraints are usually over-constrained, to be con servative 
D  Q D  Q 
FF1 FF2 A Z
B YRegister-to-Register Paths 
D Q
QB FF 
COMBO CLK D Q
QB FF 
What happens to reg-to-reg path violations if   
IC Compiler  gives up on the I/O “critical path”?
INPUT OUTPUT 
The critical path will most likely be in the I/O logic 
ANSWER: Since this is a single-clock design, all paths are in the same pa th group. If optimization 
gives up on the critical path, no additional optimization is performed on the less c ritical paths, 
including the reg-to-reg paths. The reg-to-reg paths are very accurat ely constrained (since they are 
only dependent on the clock waveform, which is usually well defined), yet they w ill be totally 
ignored due to the poor I/O constraints. This is not good. 

Data Setup & Basic Flow 
IC Compiler 1 1-47 © 2009 47 1-/square6Custom path groups allow more control over optimization 
/circle6Each path group is optimized independently 
/circle6Worst violator in one path group does not prevent o ptimization 
in another group 
/square6Check if user-defined path groups exist for I/O pat hs 
D  Q D  Q 
FF1 FF2 A
CLK Z
B Y
Combinational Paths Register-to-Register Paths 
Output 
Paths Input 
Paths 
COMBO Solution: User-Defined Path Groups 
report_path_group 
Creating user-defined path groups can also facilitate a divide-and-c onquer timing analysis strategy, 
since report_timing reports each path group’s timing separately.  This can help you isolate or 
analyze problems in a certain region of your design. 

Data Setup & Basic Flow 
IC Compiler 1 1-48 © 2009 48 1-# Ensure that the reg-reg paths get optimized 
group_path -name INPUTS -from [all_inputs] 
group_path -name OUTPUTS -to [all_outputs] 
group_path -name COMBO -from [all_inputs] –to [all_ outputs] Define Path Groups for I/O Paths, if needed 
Where are the reg-to-reg paths? 
Are the COMBO paths in three path groups? 
Delay 
Path groups Constraint Goal The critical path in 
COMBO is optimized 
COMBO CLK INPUTS OUTPUTS The critical paths in CLK, 
INPUTS and OUTPUTS 
are also optimized 
The reg-to-reg paths remain in the CLK path group, which is created by defa ult by IC Compiler. 
The group_path command can be used for CLK to assign a non-default weight or critical range 
(to be discussed) to the group, but is not needed not to define the reg-to-reg paths. 
A path can only be in one path group, but according to the path group arguments, the com bo paths 
can be part of the INPUTS, OUTPUTS or COMBO group – so where are they? 
The COMBO paths wind up in the COMBO group.  Assuming the commands are executed in t he 
order listed in the slide, they are first moved from CLK to INPUTS, beca use they match the 
startpoint argument -from [all_inputs] .  They will not be moved to the OUTPUTS group, 
even though their endpoints match -to[all_outputs] , because “–from ” has priority over 
“-to ”. They finally end up in the COMBO group because their startpoints and endpoints match 
the –from AND  –to arguments.  IC Compiler works this way to prevent having different 
results if the command sequence changes! The results are independent of  the order of the 
commands above. 
Use report_path_group to get a summary of the path groups in the design. 

Data Setup & Basic Flow 
IC Compiler 1 1-49 © 2009 49 1-Prevent Buffering of Clock-as-Data Networks 
/square6IC Compiler automatically treats clock signals driv ing 
clock pins as “ideal”
/circle6No buffering until CTS 
/square6Clock signals that are used as “data” are not ideal 
/circle6May be buffered during placement if violating DRCs or timing 
/square6Prevent buffering during placement 
/circle6Remove before CTS 
set_ideal_network [all_fanout –flat –clock_tree] CLK D    Q 
E
D    Q 
ED    Q 
E256 128 
Data network gets buffered, by default 

Data Setup & Basic Flow 
IC Compiler 1 1-50 © 2009 50 1-Modify Optimization Priority if Needed 
/square6Netlist optimization is governed by “cost prioritie s”
/circle6If competing constraints can not all be met, higher  priority 
constraints will be met at the expense of the lower  ones 
/square6Default cost priorities: 
/square6The cost priorities can be modified, for example: 
set_cost_priority –delay; # See notes below 
set_cost_priority {max_transition max_delay} Cost Type Constraints 
Design Rule Max Transition; Max Fanout; Max/Min Capacitance 
Delay (max) Clock; Max Delay 
Delay (min) Clock; Min Delay 
Dynamic Power Max Dynamic Power 
Leakage Power Max Leakage Power 
Area Max Area Highest 
Lowest 
set_cost_priority –delay : Max delay constraints are given higher priority than max 
design_rule constraints. 
set_cost_priority {max_transition max_delay} : Max transition is higher than 
max delay, but max capacitance and max fanout (and all the others) are l ower than max delay (in 
the default order). 
set_cost_priority 
[-default] 
[-delay] 
cost_list 
[-design_rules] 
[-firm_area_limit] 
[-min_delay] 
cost_list specifies a list of  costs  in  decreasing  order  of  priority, selected  fr om  the 
following: max_delay, min_delay, max_transition, max_fanout,   
max_capacitance, cell_degradation, and max_design_rules . Any costs that 
are not in the list are assumed to follow afterwards ,in their default rel ative priority. 

Data Setup & Basic Flow 
IC Compiler 1 1-51 © 2009 51 1-Enable Recovery and Removal Timing Arcs 
/square6Recovery and removal timing arcs define timing 
constraints between asynchronous signals of a 
sequential device ( set , reset ) and its clock 
/circle6If applicable, these constraints are included in th e library 
/square6By default IC Compiler ignores these constraints 
/square6By default Primetime checks these constraints 
/square6To enable IC Compiler to check and optimize for 
recovery and removal constraints, and for consisten cy 
with Primetime :
set enable_recovery_removal_arcs true D    Q D    Q 
Clk 
Reset R R
Primetime is Synopsys’ stand-alone static timing analysis tool, used for “sign-off” .
Recovery or removal timing arcs impose constraints on asynchronous pins of se quential cells. 
Typically, recovery time specifies the time the inactive e dge of the asynchronous signal has to 
arrive before the closing edge of the clock. Removal time specifies  the length of time the active 
phase of the asynchronous signal has to be held after the closing edge of t he clock. 

Data Setup & Basic Flow 
IC Compiler 1 1-52 © 2009 52 1-11. Perform a ‘Timing Sanity Check’
/square6Before starting placement it is important to 
ensure that the design is not over-constrained 
/circle6Constraints should match the design’s specification 
/square6Report ‘ZIC’ timing before placement 
/circle6Check for unrealistic or incorrect constraints 
/circle6Investigate large zero-interconnect timing violatio ns 
set_zero_interconnect_delay_mode true 
Warning: Timer is in zero interconnect delay mode. (TIM-177) 
report_constraint –all 
report_timing 
set_zero_interconnect_delay_mode false 
Information: Timer is not in zero interconnect dela y mode. (TIM-176) 
What should you see in a “zero interconnect” timing report? 
A positive slack for all paths means that the constraints have passed the check. 
Small negative slacks are probably OK as well, since these can be fix ed by IC Compiler’s 
advanced optimization engines. 
You are looking for large violations. If for example a path shows a timing viol ation as large as the 
clock period, then you should investigate whether the constraints were applied c orrectly, or 
whether the design was not synthesized with the correct constraints. L arge violations will most 
likely NOT be able to be fixed by IC Compiler, so the problem must be addre ssed before 
beginning placement. 

Data Setup & Basic Flow 
IC Compiler 1 1-53 © 2009 53 1-12. Remove Unwanted “Ideal Net/Networks”
/square6Your SDC constraints may contain 
either of the following commands: 
/circle6set_ideal_network (preferred) 
/circle6set_ideal_net (obsolete) 
/square6These commands prevent synthesis 
(Design Compiler) from building 
buffer trees on specified signals, 
which is deferred to the physical 
design phase (typically high fanout nets like 
set/reset , enable , select , etc.) 
/square6To allow buffering during 
placement remove the constraints: Enable D    Q 
ED    Q 
E
D    Q 
ED    Q 
E
remove_ideal_network [get_ports Enable Select Reset ] 

Data Setup & Basic Flow 
IC Compiler 1 1-54 © 2009 54 1-It’s good practice to save the design after each ke y 
design phase, for example: data setup, design 
planning, placement, CTS and routing: 
/circle6Note: The open cell is still the original ORCA cell !! save_mw_cel –as ORCA_data_setup 13. Save the Design 
Unlike conventional software behavior, when you perform a “Save As” in IC  Compiler, the 
“current open design” is not automatically switched to the new design CEL  view – it remains the 
originally opened CEL. 

Data Setup & Basic Flow 
IC Compiler 1 1-55 © 2009 55 1-Design Library with New Design Cell 
./design_lib_orca/ 
CEL/ ….…
ORCA:1 
Newly 
Saved Cell lib 
lib_1 
lib_bck 
ORCA_data_setup:1 

Data Setup & Basic Flow 
IC Compiler 1 1-56 © 2009 56 1-UNIX Manipulation of a Milkyway Database 
UNIX%  cd  CEL 
UNIX%  rm ORCA_placed 
UNIX%  cp  ~Joes_Lib/ORCA_placed STOP 
./design_lib_orca/ 
… CEL/ 
ORCA_data_setup 
ORCA_floorplanned 
ORCA_placed 
ORCA_cts 
ORCA_routed lib 
lib_1 
lib_bck 
T.O.C. 
Corrupted! 
In the example above, the UNIX rm and cp commands were used to replace our CEL view 
ORCA_placed with Joe’s version. Doing so will corrupt the database, more specifi cally the lib 
files, which contain the binary Table of Content (T.O.C.) of the library dat abase. 
Likewise the mv and mk_dir commands should not be used to manipulate the directory and file 
structure under the library directory (example: design_lib_orca). 
Instead, use the commands rename_mw_cel , copy_mw_cel , remove_mw_cel .  They are 
Milkyway-aware, UNIX is not. 
Note: It is acceptable to copy (cp –r) or delete (rm –r) the entire library directory and its contents. 
If files are deleted, it is possible to rebuild the table of contents using rebuild_mw_lib .

Data Setup & Basic Flow 
IC Compiler 1 1-57 © 2009 57 1-Restoring Variables 
/square6Variable settings are maintained during the same IC C 
session but are NOT saved with the design CEL 
/circle6If you close a cell and re-open another cell in the  same ICC 
session, previously applied variables settings are maintained 
/circle6If you exit and later re-invoke ICC all previous va riable 
settings are lost - they are set to their defaults 
/square6Suggestion: Include all setup variable settings in the 
.synopsys_dc.setup file, which is read in 
automatically when ICC is invoked 
set timing_enable_multiple_clocks_per_reg true 
set_fix_multiple_port_nets -all -buffer_constants Variable – not saved with cell 
Command – attribute saved with cell 

Data Setup & Basic Flow 
IC Compiler 1 1-58 © 2009 58 1-/square6By default, link_library , search_path , target_library 
and TLU+ settings are stored with the CEL 
/square6However, when you re-open the CEL, the stored 
settings are not re-applied , unless you set: 
/square6Recommendation: Include in .synopsys_dc.setup 
/square6If library or TLU file locations change with respec t to 
the Milkyway library location, the settings have to  
be re-applied. See notes section below! set auto_restore_mw_cel_lib_setup true 
open_mw_cel ORCA_placed Restoring Logical Library and TLU+ Settings 
1st bullet: Whether settings are stored with the design CEL or not is controlled through the variable 
save_mw_cel_lib_setup . This variable is set to true by default. 
2nd bullet: When opening a CEL with the variable auto_restore_mw_cel_lib_setup set to 
false (the default setting), IC Compiler will NOT restore the setting s. The user will need to re-apply 
them when re-invoking IC Compiler, after exiting the current session. 
When opening a CEL with the variable auto_restore_mw_cel_lib_setup set to true , IC 
Compiler will restore the settings and display the following: 
Information: AUTO-RESTORE: Setting variable search_ path to .  /path/to/icc/dw/sim_ver ../ref/db. (UIG- 10) 
Information: AUTO-RESTORE: Setting variable link_li brary to * sc_max.db … ram16x128_max.db. (UIG-10) 
Information: AUTO-RESTORE: Setting variable target_ library to sc_max.db. (UIG-10) 
Information: AUTO-RESTORE: Setting variable itf_tlu _plus_library to ../ref/tlup/abc_6m_max.tluplus…. (U IG-10) 
If the library file locations change, follow this procedure: 
close_mw_lib 
set auto_restore_mw_cel_lib_setup false 
set search_path “new search paths”
set link_library “* link libraries”
set target_library “target libraries”
set_mw_lib_reference –mw_ref “new locations” design_ lib_name 
set_mw_technology_file –tech “new location” design_l ib_name 
open_mw_cel <cell name> -lib <design_lib name> 
link 
set_tlu_plus_files –max_tlu <new_location> –min_tlu  <new..> –tech2itf <> 
set auto_restore_mw_cel_lib_setup true 

Data Setup & Basic Flow
IC Compiler 11-59© 200959 1-Loading an Existing Cell After Exiting ICC
If your .synopsys_dc.setup file contains the appropriate 
variables, then loading an existing cell is simple!
lappend search_path ./scripts ./design ...
lappend search_path [glob $MW_libs/*/LM] 
set symbol_library “sc_icon.sdb io_icon.sdb”
set link_library “* sc_max.db io_max.db ram16x128_max.db”
set target_library “sc_max.db”
set mw_logic0_net “VSS”1
set mw_logic1_net “VDD”
set auto_restore_mw_cel_lib_setup true
...
UNIX% icc_shell –gui
icc_shell> open_mw_lib design_lib_orca
icc_shell> open_mw_cel ORCA_setup
icc_shell> link.synopsys_dc.setup
Good practice – verifies correct library setup

Data Setup & Basic Flow 
IC Compiler 1 1-60 © 2009 60 1-Data Setup Summary 
Design Library 
design_lib_orca Technology File 
abc_6m.tf 
RC Model Files 
(TLU+) 
Design ‘CEL’ORCA Gate-Level Netlist orca.v Constraints File 
orca.sdc 
Synthesis Data Logic/timing Library Files 
Physical Data sc          ram32          io 
Physical Library Directories MW 
Standard 
cells MW 
Macro 
cells MW 
Pad 
cells db 
Standard 
cells db 
Macro 
cells db 
Pad 
cells 

Data Setup & Basic Flow 
IC Compiler 1 1-61 © 2009 61 1-Data Setup Example (1 of 3) 
lappend search_path ./scripts ./design_data $MW_lib s 
lappend search_path [glob $MW_libs/*/LM] 
set symbol_library “sc_icon.sdb io_icon.sdb”
set link_library “* sc_max.db io_max.db ram16x128_m ax.db”
set target_library “sc_max.db”
set mw_logic0_net “VSS”
set mw_logic1_net “VDD”
# Timing and optimization control variables 
set timing_enable_multiple_clocks_per_reg true 
set case_analysis_with_logic_constants true 
set physopt_delete_unloaded_cells false 
set physopt_power_critical_range <t> 
set physopt_area_critical_range <t> 
set enable_recovery_removal_arcs true 
set auto_restore_mw_cel_lib_setup true .synopsys_dc.setup 
The symbol library is an optional library that is used by the schematic GUI to display the l ogic 
symbols of the gates in the schematic. If not specified, IC Compiler uses de fault (rectangular) 
symbols for the gates. 

Data Setup & Basic Flow 
IC Compiler 1 1-62 © 2009 62 1-Data Setup Example (2 of 3) 
set_false_path –from <clock_name> -to <clock_name> 
set_fix_multiple_port_nets -all -buffer_constants 
set_auto_disable_drc_nets -constant false 
set_timing_derate -max –early 0.95 
set_dont_use <off_limit_cells> 
set_prefer –min <hold_fixing_cells> 
set_max_area 0 
group_path -name INPUTS -from [all_inputs] 
group_path -name OUTPUTS -to [all_outputs] 
group_path -name COMBO -from [all_inputs] -to [all_ outputs] 
set_ideal_network [all_fanout –flat –clock_tree] 
set_cost_priority {max_transition max_delay} tim_opt_ctrl.tcl 

Data Setup & Basic Flow 
IC Compiler 1 1-63 © 2009 63 1-create_mw_lib design_lib_orca -open -technology tec hfile.tf \
-mw_reference_library “sc io ram32”
set_check_library_options –all 
check_library 
set_tlu_plus_files –max_tluplus cb13_6m_max.tluplus  \
-min_tluplus cb13_6m_min.tluplus \
-tech2itf_map cb13_6m.map 
check_tlu_plus_files 
import_designs design.v -format verilog -top ORCA; # See below 
list_libs 
derive_pg_connection -power_net VDD -power_pin VDD \
-ground_net VSS -ground_pin VSS 
check_mv_design –power_nets 
read_sdc constraints.sdc; # Omit if importing constrained ddc 
check_timing; report_timing_requirements 
report_disable_timing; report_case_analysis 
report_clock; report_clock -skew 
source tim_opt_ctrl.tcl; # Timing and optimization controls 
set_zero_interconnect_delay_mode true 
report_constraint –all; report_timing 
set_zero_interconnect_delay_mode false 
remove_ideal_network [get_ports Enable Select Reset]
save_mw_cel –as ORCA_data_setup Data Setup Example (3 of 3) 
data_setup.tcl 
import_designs design.v -format verilog -top ORCA is equivalent to: 
read_verilog –netlist design.v 
current_design ORCA 
uniquify 
link 
save_mw_cel –as ORCA 
The example above imports a Verilog netlist file, which does not contain constraints. 
Alternatively, if a ddc file, created by Design Compiler and containing timing constraints is 
imported, the read_sdc step can be omitted. 
The tim_opt_ctrl.tcl file contains the necessary timing and optimization control variable 
settings and commands, which are used during placement, CTS and routing. 

Data Setup & Basic Flow 
IC Compiler 1 1-64 © 2009 64 1-Test for Understanding (1 of 2) 
1. What’s one benefit of buffering tie-high/low nets? 
2. What cells might you want to put a “don’t touch” on 
before placement? 
3. Area recovery can: 
a. Reduce congestion 
b. Increase delay 
c. Reduce power consumption 
d. A and C 
e. A, B and C 
4. During Data Setup it is recommended to apply an 
“ideal network” on high-fanout nets ( enable , reset ), 
and to remove “ideal network” from the clock network . 
True or False ?1. Buffered constant nets are much less susceptible to crosstalk glitches
2. Very strong or very weak drivers, cells reserved for delay lines or cl ock trees. 
3. E. Area recovery can down-size cells and/or remove buffers, which helps to redu ce both 
leakage and dynamic power. Buffer removal can help to reduce congestion. A rea recovery 
works by slowing down timing paths with positive slack 
4. False . Exactly the reverse is true: Remove ideal networks from 
high fanout nets so that they can be buffered during placement; Apply an ideal network on clocks to prevent clock-as-data nets to be buffered. 

Data Setup & Basic Flow 
IC Compiler 1 1-65 © 2009 65 1-Test for Understanding (2 of 2) 
5. Applying a power or area critical range can help to  
reduce power consumption or cell area, respectively . 
True or False ?
6. Defining path groups for I/Os is recommended if the  
I/Os are conservatively constrained. True or False ?
7. Why is it recommended to remove the “ideal network”
property from high fanout nets like enable and reset 
after performing a “zero-interconnect” timing sanity 
check, and not before ?5. False . Applying a critical range forces a larger timing margin (slack) dur ing optimization, so 
that near-critical paths do not become violating critical paths later  during CTS or routing. This 
can result in increased power consumption and/or cell area. 
6. True . 
7. If done before ZIC timing, even though the net parasitics are ignored, these  high fanout nets 
may exhibit unrealistically large transition times, due to the large tot al pin capacitance that 
these nets fan out to, which could generate unrealistically large timing  violations. 

Data Setup & Basic Flow 
IC Compiler 1 1-66 © 2009 66 1-General IC Compiler Flow 
Synthesis 
Data Setup 
Design Planning 
Placement 
Clock Tree Synthesis 
Routing 
Chip Finishing Next: 
A high-level 
overview 
We will briefly introduce design planning as well as the “core” commands  for Placement, CTS and 
Routing, for the purposes of performing Lab 1, which takes you through the IC Compil er flow (at 
a high level). In the subsequent Units you will delve into each step in much more d etail. 

Data Setup & Basic Flow 
IC Compiler 1 1-67 © 2009 67 1-Design Planning 
Data Setup      Design Planning      Placement      Clock Tree Synthesis      Routing    Chip Finishin g Design Planning 
IP 
“Design planning” is the design flow phase 
where the floorplan is defined RAM 
Block-level Floorplan Chip-level Floorplan 
A floorplan defines: IO, filler and corner pad locations, or pin locations aro und the periphery; size 
and shape of standard cell core or placement area; placement of macro cel ls; placement and 
routing blockages; the power grid, which includes all pre-routed VDD/VSS metal, including core 
and periphery rings, vertical and horizontal straps, and standard cell rail s. 

Data Setup & Basic Flow 
IC Compiler 1 1-68 © 2009 68 1-Load an Existing Floorplan 
/square6Read in as a DEF file from ICC or 3 rd party tool 
/square6Read in as a physical constraints file from ICC 
/square6Open an already floorplanned Milkyway cell read_def DESIGN.def 
read_floorplan DESIGN.fp 
open_mw_lib  my_design_lib 
open_mw_cel DESIGN_floorplanned 
Creating a new floorplan with IC Compiler 
will be discussed in Unit 2 
See Appendix A in 
Unit 2 if floorplanning 
with a 3 rd party tool !

Data Setup & Basic Flow
IC Compiler 11-69© 200969 1-Placement and Related Optimizations
place_opt
Logic moved 
closer together 
for shorter nets
Cells upsized 
for optimal 
drive/speedData Setup      Design Planning      Placement      Clock Tree Synthesis      Routing            DFM Placement
1.Set placement options
2.Run
/circle6Performs iterative placement and logic optimization
/circle6Objective: Reduce/eliminate negative timing slack (D TDP)
Placement will be discussed in much greater detail in Unit 3.

Data Setup & Basic Flow
IC Compiler 11-70© 200970 1-Clock Tree Synthesis
1.Set clock tree options/exceptions
2.Run
/circle6Builds the clock trees
/circle6Performs incremental logic and placement optimizatio ns
/circle6Runs clock tree optimizations
/circle6Routes the clock nets
/circle6Can fix hold time violations
/circle6Can perform inter-clock balancingclock_optData Setup      Design Planning      Placement      Clock Tree Synthesis      Routing   Chip Finishing Clock Tree Synthesis
Clock tree synthesis will be discussed in much greater detail in Unit 4.

Data Setup & Basic Flow 
IC Compiler 1 1-71 © 2009 71 1-Routing 
Data Setup      Design Planning      Placement      Clock Tree Synthesis      Routing    Chip Finishin g Routing 
1. Set routing options/exceptions 
2. Run 
Performs 
/circle6Global Route 
/circle6Track Assignment 
/circle6Detailed Route 
/circle6Search and Repair 
Concurrently performs 
/circle6Logic, placement and routing optimizations 
/circle6Objective: Meet timing route_opt 
Routing will be discussed in much greater detail in Unit 6 

Data Setup & Basic Flow 
IC Compiler 1 1-72 © 2009 72 1-Chip Finishing 
/square6Also known as ‘Design for Manufacturing’
/square6Entails: 
/circle6Antenna Fixing 
/circle6Wire Spreading 
/circle6Double Via Insertion 
/circle6Filler Cell Insertion 
/circle6Metal Fill Insertion 
/circle6Metal Slotting Data Setup      Design Planning      Placement      Clock Tree Synthesis      Routing            DFM Chip Finishing 
Discussed in Unit 7 

Data Setup & Basic Flow 
IC Compiler 1 1-73 © 2009 73 1-Analyzing the Results (1/2) 
After each placement, CTS and routing step you 
should: 
/square6Examine the log output for design summaries: 
/circle6Utilization 
/circle6Worst Negative Slack (WNS) 
/circle6Total Negative Slack (TNS) 
/circle6Legality of cell placement 
/circle6Cell count and area 
/circle6Design rule violations 
/square6Use                             to see: 
/circle6WNS/TNS per path group (clock group) 
/circle6Other statistics report_qor 

Data Setup & Basic Flow 
IC Compiler 1 1-74 © 2009 74 1-Analyzing the Results (2/2) 
/square6Generate more detailed reports 
/circle6Show all violating path end points 
/rhombus6report_constraint –all_violators 
/circle6Show details of  the worst violating setup path 
/rhombus6report_timing 
/circle6Report physical design statistics (e.g. utilization ) 
/rhombus6report_design -physical 
/circle6Analyze the congestion 
/rhombus6Congestion map (GUI) 
/rhombus6report_congestion report_constraint –all_violators 
report_timing 
report_design -physical 
report_congestion 

Data Setup & Basic Flow 
IC Compiler 1 1-75 © 2009 75 1-Example “run” Script 
... 
open_mw_cel ORCA_data_setup 
read_def ORCA.def 
save_mw_cel -as ORCA_floorplanned 
place_opt 
save_mw_cel -as ORCA_placed 
report_constraint -all 
remove_clock_uncertainty [all_clocks] 
clock_opt 
save_mw_cel -as ORCA_cts 
report_constraint -all 
route_opt 
save_mw_cel -as ORCA_routed 
report_constraint -all 
report_timing 
close_mw_lib 
exit Commands can be run 
interactively, or in “batch”
mode, shown here run.tcl 
UNIX$ icc_shell –f run.tcl | tee myrun.log !

Data Setup & Basic Flow 
IC Compiler 1 1-76 © 2009 76 1-Basic Flow Summary 
You should now be able to: 
/square6Perform data setup: 
/circle6Create a Milkyway design library and design cell 
/circle6Load the necessary data required to run IC Compiler
/square6Execute a basic flow for design planning, 
placement, CTS  and routing in IC Compiler 

Data Setup & Basic Flow 
IC Compiler 1 1-77 © 2009 77 1-60 minutes 
Lab 1: Design Setup and Basic Flow 
Goals: 
/square6Perform data setup 
/square6Load a floorplan 
/square6Perform placement, CTS 
and routing Perform Data Setup 
place_opt 
clock_opt 
route_opt Load a Floorplan 

Data Setup & Basic Flow 
IC Compiler 1 1-78 © 2009 This page was intentionally left blank 

Design Planning
IC Compiler 12-1© 20091 2-Agenda
© 2009 Synopsys, Inc. All Rights Reserved S ynopsys 20-I-071-SSG-008DAY
11 11
Introduction & Overviewi
Data Setup & Basic Flow1
Design Planning2


Design Planning
IC Compiler 12-2© 20092 2-Unit Objectives
After completing this unit, you should be able to:
/square6Use IC Compiler to create a non-hierarchical chip-
level floorplan
/square6Create a floorplan that is likely to be routable and 
achieve timing closure
Hierarchical design planning is covered in a separate workshop: 
IC Compiler – Hierarchical Design Planning (ICC-HDP).

Design Planning
IC Compiler 12-3© 20093 2-General IC Compiler Flow
Synthesis
Data Setup
Design Planning
Placement
Clock Tree Synthesis
Routing
Chip Finishing/checkbld/checkbld /checkbld/checkbld
This Unit

Design Planning
IC Compiler 12-4© 20094 2-Terminology
/square6Design planning is the iterative process of creating a 
floorplan
/square6A chip-level floorplan entails defining:
/circle6Core size, shape and placement rows
/circle6Periphery: IO, power, corner and filler pad cell loc ations
/circle6Macro cell placement
/circle6Standard cell placement constraints (blockages)
/circle6Power grid (rings, straps, rails)
/square6A
 physical design , or layout , is the result of a 
synthesized netlist that has been placed and routed

Design Planning
IC Compiler 12-5© 20095 2-Re-synthesisICC Design Planning and Re-Synthesis Flow
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T re-synthesis with 
DEF floorplan
Data setup with re-
synthesized netlist
Load floorplan
PlacementDC-T synthesis with 
default floorplan
Data setupDesign planning with a 
2-pass synthesis flow 
/barb2right/barb2right /barb2right/barb2rightImproved QoR
The above flow is recommended for designs with challenging “quality of results” (QoR) 
requirements. By re-synthesizing the design with DC-Topographical using an accurate floorplan 
you are providing IC Compiler with a potentially better starting netlist, which may give better 
results. If QoR is not critical, the re-synthesis step can be skipped and the resulting cell after 
design planning, with its netlist from the first synthesis execution, is taken directly to placement.
The above flow assumes that the RTL code is fairly complete when performing the initial 
synthesis. If the RTL contains a fair number of “black boxes” (i.e. undefined sections) you may 
need to perform additional iterations of design planning and synthesis, as the RTL code is 
solidified.

Design Planning
IC Compiler 12-6© 20096 2-Select the Design Planning Task GUI
DEFAULT
gui_set_current_task –name {Design Planning}This makes 
additional 
menus and 
forms available, 
which are 
otherwise 
hidden

Design Planning
IC Compiler 12-7© 20097 2-Create Starting FloorplanCreate the Starting Floorplan
Initialize the floorplanSpecify pad cell locationsCreate physical-only pad cells
Define known power structureDefine known macro/std cell placementSpecify ignored routing layers
Define known placement blockages
Design PlanningVirtual flat placementCreate starting floorplan
Optimize/analyze timingSynthesize power networkAnalyze/optimize congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
Starting Floorplan Placement          Reduce Congestion         PNS       Reduce Delay        Write FloorplanStarting Floorplan
Create P/G pad ringsInsert pad filler cells

Design Planning
IC Compiler 12-8© 20098 2-Create Physical-only Pad Cells
/square6Physical-only pad cells (VDD/GND, corner cells) are not 
part of the synthesized netlist
/square6Must be created prior to specifying the pad cell locations
open_mw_cel DESIGN_data_setup
create_cell {vss_l vss_r vss_t vss_b} pv0i
create_cell {vdd_l vdd_r vdd_t vdd_b} pvdi
create_cell {CornerLL CornerLR CornerTR CornerTL} \
pfrelrStarting Floorplan

Design Planning
IC Compiler 12-9© 20099 2-Specify Pad Cell Locations
A_1 A_0vss_l
pad_data_0pad_data_2
vdd_l
pad_data_1
CornerLL Clk
2345
1
2 3 1
23
1 …; tdf file
; Place the corner cells
pad "CornerLL" "bottom"
pad "CornerLR" "right"
pad "CornerTR" "top"
pad "CornerTL" "left"
; Place io and power pads
; Left/Right sides start from bottom (excluding corner)
pad "pad_data_0" "left" 1
pad "pad_data_1" "left" 2
pad "vdd_l" "left" 3
pad "vss_l" "left" 4
pad "pad_data_2" "left" 5
; Bottom/Top sides start from left (excluding corner)
pad "Clk" "bottom" 1
pad "A_0" "bottom" 2
pad "A_1" "bottom" 3
read_io_constraints <tdf_file>
Bottom
Left
By default, pads are 
evenly distributed on 
each side
Constraints are honored 
when the floorplan is createdStarting Floorplan
pad pa dName padSide [padOrder ] [padOffset] ["reflect"]
read_io_constraints [-append] [–cel_name] [–child_cel] <TDF_file>
GUI: Floorplan /barb2right Read I/O Constraints ...
The example on the slide uses the padOrder syntax. padOffest can be used (additionally, or 
instead) to specify an absolute offset (in microns) from the bottom edge or left edge of the 
periphery boundary.
Pads that are not defined in tdf are assigned and placed automatically. Pads that defined in tdf are 
considered as constrained pads (unless padOrder = 0 and no padOffset is given). Pads defined in 
tdfare placed first, then the undefined ones are placed into available locations. ICC can dump out 
the tdf for further modification ( write_io_constraints).
The numbering is NOT absolute. For example, with the tdf below, where the smallest padOrder is 
2 and padOrder 4 is not defined, and any number of unconstrained pads (1 or more!) can be placed 
between the corner pad and A1, as well as in between A2 and A3. No additional pads can be 
placed between consecutively numbered pads (e.g. A1 and A2).
pad “A1” “left” 2
pad “A2” “left” 3
pad “A3” “left” 5

Design Planning
IC Compiler 12-10© 200910 2-Initialize the Floorplan
Creates the core and periphery area
/circle6Defines placement or site rows within the core area
/circle6Defines the chip boundary or periphery area
/circle6Places IO pads, as defined in the TDF file
/rhombus6Pads defined in netlist and by c reate_cell
/rhombus6Ordering defined by TDF file
initialize_floorplan ...
Starting Floorplan
GUI: Floorplan /barb2right/barb2right /barb2right/barb2rightInitialize Floorplan …
When you select one of the four Control Type switches at the top of the dialog (e.g. Aspect Ratio 
or Width and Height ), a corresponding subset of the six available parameter fields is highlighted to 
allow for user input (example: Core utilization, Aspect ratio (H/W) , Row/core ratio, etc.)
For rectilinear shapes, use the initialize_rectilinear_block command.

Design Planning
IC Compiler 12-11© 200911 2-Core Area Parameters
Control Type
* Aspect ratio
/barb2rightC ore u tilization
/barb2rightAspect ratio (H/W)
/barb2rightRow/core ratio
*
 Width and height
/barb2rightCore width
/barb2rightCore height
/barb2rightRow/core ratio
*
 ……….
* ……….
Example of a horizontal, no double back, no-flip 
first row and Row/core <1.0Row 1Row 3
Row 2
Top of row key
Core to bottom 
distanceCore to right 
distance Core width
Core
height
CORE AREAStarting Floorplan

Design Planning
IC Compiler 12-12© 200912 2-Floorplan After Initialization
Unplaced 
Macro 
cells
Unplaced 
Standard 
cells
Core area 
with site 
rowsPeriphery 
with I/O 
pad cellsStarting Floorplan

Design Planning
IC Compiler 12-13© 200913 2-Insert Pad Filler Cells
Starting Floorplan
A_1 A_0VSS_LEFT
pad_data_0pad_data_2
VDD_LEFT
pad_data_1
CornerLL ClkMay be needed for 
continuity of N-well, P-well,  
and/or P/G routing
insert_pad_filler –cell “fill5000 fill2000 fill1000  ... "
fill2000
fill500
fill1000
fill500fill500
fill500Pad filler cells
GUI: Finishing /barb2right/barb2right /barb2right/barb2rightInsert Pad Filler ...

Design Planning
IC Compiler 12-14© 200914 2-Create P/G Pad Rings
Starting Floorplan
VDDQ
VDDO
VDD
VSSQ
VSSO
VSS
Route P/G ringsMake logical P/G 
pin connections
derive_pg_connection -power_net VDD -power_pin VDD -ground_net VSS -ground_pin VSS
derive_pg_connection -power_net VDDO -power_pin VDDO -ground_net VSSO -ground_pin VSSO
derive_pg_connection -power_net VDDQ -power_pin VDDQ -ground_net VSSQ -ground_pin VSSQ
create_pad_ringsMay be needed for P/G 
continuity
GUI: Preroute /barb2right/barb2right /barb2right/barb2rightDerive PG Connection ...
GUI: Preroute /barb2right/barb2right /barb2right/barb2rightCreate Pad Rings ...
If no filler cells are used, or if some or all pad cells do not have P/G pre-routes built in, you will 
need to create a pad ring to ensure P/G continuity.

Design Planning
IC Compiler 12-15© 200915 2-Prior to Virtual Flat Placement
/square6By default virtual flat placement (create_fp_placement ):
/circle6Places standard cells and non-fixed macros
/circle6Can place cells anywhere in the core
/circle6Assumes all layers defined in the technology file are used
/circle6Does not consider power structure effects on congestionStarting Floorplan
/square6P rior to placement specify any non-
default constraints
/circle6Routing layers that should not be used
/circle6Pre-defined macro/standard cell locations
/circle6Placement blockages
Create Starting FloorplanCreate P/G pad ringsInsert pad filler cellsInitialize the floorplan
Define known macro/std cell placementSpecify ignored routing layers
Define known placement blockages

Design Planning
IC Compiler 12-16© 200916 2-Ignore Extra Routing Layers
/square6By default IC Compiler will use all metal layers 
defined in your technology 
/square6Prior to detailed routing this can result in:
/circle6Optimistic congestion analysis
/circle6Inaccurate RC parasitic calculations, which affect t iming
/square6Tell IC Compiler to ignore these unused layers
/circle6Accurate congestion and timing analysis prior to rou ting
/circle6No additional “route guides” needed
set_ignored_layers –max_routing_layer M7
report_ignored_layers
rem
ove_ignored_layersStarting Floorplan
This command is useful if you have a technology file which defines, for exa mple, nine metal 
layers, but you plan to use fewer layers, for example, only up to metal 7.
The command can only be applied once a floorplan has been defined (through 
initialize_floorplan, read_def or read_floorplan ).
The example above ignores the layers above m7 for RC and congestion estimation. It also prevents 
the router from routing on layers above m7.
The cleanest solution is to ask your foundry for a 7 layer technology file instead. The reason is that 
your tech data for layer 7, while more accurate using this command, is still not completely 
accurate.
User can check the log during placement for:
Warning: Poly layer CP is ignored during extraction. (RCEX-076)
Information: Layer METAL8 is ignored for resistance and capacitance computation. (RCEX-019)
Information: Layer METAL9 is ignored for resistance and capacitance computation. (RCEX-019)

Design Planning
IC Compiler 12-17© 200917 2-Constraining Macros
/square6After create_fp_placement the
resulting macro placement can be
“disorganized”
/circle6May complicate the power structure
/circle6May use more routing resources
f
or busses
/square6You can define macro placement:
/circle6Manually, using the GUI, prior to placement
/circle6With constraints, which guide placement
/square6P
lacement constraints are “soft”
/circle6Placer will t ryto honor them but is not required to
set_fp_macro_options ...
set_fp_macro_array ...
set_fp_relative_location ...Starting Floorplan
Use sparingly!  
Too many constraints
may hamper cell
placement
If two macros connect to the same bus, and the macros are not “aligned”, additional routing 
resources may be needed to connect these macros to the bus. 

Design Planning
IC Compiler 12-18© 200918 2-Manual Macro Placement
/square6The GUI can be used to “manually” place macros in 
known locations and orientations (will be shown in lab)
/square6Placed macros , if not “fixed”, can be moved by 
create_fp_placement
/circle6To prevent this “fix” the placed macros using the too lbar, or:Fix/Unfix Objects Undo/Redo Rotate/Flip
Align/
Distribute/
Spread
Expand
ObjectsMove ObjectsView Flylines
and Net 
Connectivity
set_dont_touch_placement [get_cells <list_of_cells>]Starting Floorplan
The set _dont_touch_placement attribute will prevent any placement modifications. If, 
later in the design planning flow, you discover that one or more of these manually placed cells are 
causing congestion or other problems and you need to modify their placement, you can “unfix”
placement with remove_dont_touch_placement .

Design Planning
IC Compiler 12-19© 200919 2-set_fp_macro_array –name B_array –elements \
[list [get_cells B1 B2] [get_cells B3 B4] [get_cells B5 B6]] \
–x_offset 4 –y_offset 12 –align_2d rbMacro Constraints: Arrays
set_fp_macro_array –name A_array –elements  \
[list [get_cells A1 A2] [get_cells A3 A4]] \
–x_offset 15 –y_offset 110
set_fp_macro_array –name C_array –elements [get_cells C1 C2] \
–x_offset 4 –align_pins [list [get_pins C1/ctrl] [get_pins C2/ctrl]]Starting Floorplan
A1
A3 A4A2
B1
B3 B4B2
B5 B6
C1C2ctrl c trl
set_fp_macro_array
-na
me string 
[-elements collection_of_macro_cell_objects]
[-align_edge t | b | l | r | c ] 
[-align_2d lb | lc | lt | rb | rc | rt | cb | cc | cr] 
[-align_pins {list of two pin objects}]
[-x_offset float] [-y_offset float] 
[-use_keepout_margin] 
[-vertical]
[-rectilinear]
[-reset]
report_fp_macro_array
Virtual flat placement will, by default, create arrays out of small macros. This comes from the 
default auto-grouping setting: set_fp_placement_strategy –auto_grouping 
low. The above command allows the user more control.
Note: A macro array is treated as a single object during placement - standard cells can not be 
placed inside the array.

Design Planning
IC Compiler 12-20© 200920 2-Macro Constraints: Legal Orientation Option 
Without Constraints -legal_orientations W
Starting Floorplan
E_5
E
_5set_fp_macro_options [get_cells E_5] -legal_orientations W
set_fp_macro_options $list_of_macro_objects
[-legal_orientations {legal_orientations}]
[-anchor_bound t|b|l|r|tl|tr|bl|br|tm|bm|lm|rm|c]
[-x_offset distance_from_core_edge]
[-y_offset distance_from_core_edge]
[-align_pins ref_port_of_block constrained_pin]
[-side_channel {left_dist right_dist top_dist bottom_dist}]
[-reset]
report_fp_macro_options

Design Planning
IC Compiler 12-21© 200921 2-Macro Constraints: Anchor Bound Option 
Cells are placed in specified ½ or ¼ core areas 
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16Starting Floorplan
set_fp_macro_options collection_of_cells \
-anchor_bound <l, r, t, b, bl, tl, br, tr, bm, tm, lm, rm, c>
tm: Boundary regions 2, 3, 6, 7
c: Boundary regions 6, 7, 10, 11t: Boundary regions 
1, 2, 3, 4, 5, 6, 7, 8
bl: Boundary regions 
9, 10, 13, 14
Additional set_fp_macro_options -anchor_bound examples:
t (top) {1-8}
tl (top-left) {1,2,5,6}
b (bottom) {9-16}
bl (bottom-left) {9,10,13,14}
lm (left-middle) {5,6,9,10}
c (center) {6,7,10,11}

Design Planning
IC Compiler 12-22© 200922 2-Macro Constraints: Side Channel Option 
Starting Floorplan
set_fp_macro_array –name ARRAY_A –vertical \
–elements [get_cells “A1 A2 A3”]
set_fp_macro_options array2 \
–side_channel “0 80 30 40”
A1
A2
A3ARRAY_A30
4
080coreCells or arrays are spaced from the core edges

Design Planning
IC Compiler 12-23© 200923 2-Macro Constraints: Relative Location
Starting Floorplan
set_fp_relative_location -name RP1 -target_cell “A1”
-target_orientation “S” -target_corner “tr” \
-anchor_object “B3” -anchor_corner “tl”
-x_offset 30 -y_offset 10set_fp_relative_location s ets a relative location 
constraint on a target cell with respect to an anchor object
/circle6Anchor: A fixed cell, another cell with a relative-l ocation, or a 
corner of the core area
10
30core
B3
anchor
target
set_fp_relative_location
-name constraint_name
-target_cell cell_name
[-target_orientation N | S | E | W | FN | FS | FE | FW]
[-target_corner bl | br | tl | tr]
[-anchor_object object_name]
[-anchor_corner bl | br | tl | tr]
[-x_offset distance]
[-y_offset distance]
extract_fp_relative_location
remove_fp_relative_location
report_fp_relative_location

Design Planning
IC Compiler 12-24© 200924 2-Congestion Potential Around Macro Cells
/square6Routing to standard cells 
can often be difficult near 
edges or corners of macro 
cells
/square6Solution:
Add placement blockages 
around macro cells
/circle6Hard b lockages prevent 
standard cells from ever
being placed there
/circle6Softb lockages prevent 
standard cells from being 
placed during initial coarse 
placement, but are ignored 
by subsequent placement 
legalization or optimizationStarting Floorplan

Design Planning
IC Compiler 12-25© 200925 2-Apply Global Placement Blockages
RAM4RAM2 RAM1 RAM3
RAM5Hard blockage always 
created on all four sides
Soft blockage created 
only for narrow channels 
between macros, or 
between a macro and the 
core boundaryGlobal blockages
/square6Apply to all 
‘fixed’ cells
/square6Consider all cell 
edges
set physopt_hard_keepout_distance 10
set placer_soft_keepout_channel_width 25Also add to 
.synopsys_dc.setup!Starting Floorplan
Use the above variables to avoid/minimize cell placement in t ight areas between RAMs, or between RAMs 
and core boundary. These are areas where it is legal to place cells, but it is very inefficient to do so, due to 
the difficulty of routing in these areas. Typically, routing congestion and timing-driven constraints will 
prevent this from happening during placement. It is more efficient, however, for you to tell the tool about 
these restrictions explicitly, rather than letting the tool spend CPU cycles to figure it out.
The variable physopt_hard_keepout_distance will create a hard placement blockage rectangle 
around each macro (fixed cell), essentially extending each macro’s boundary by the distance specified. 
The variable placer_soft_keepout_channel_width will create a softplacement blockage where 
the distance between two macros, or between the macro and the core boundary, is less than or equal to the 
specified value (i.e. narrow channels). The unit for the above variables is microns.
Note that hard blockages are always created around the entire macro, while soft blockages are not generated 
for every fixed macro in the design, nor around every macro edge . Soft blockage areas are generated only if 
the distance between two macros, or between a macro and the nearest core boundary, is less than the 
channel width specified.
As shown in the example above, it is common to create hard blockages in an area tightly surrounding the 
macros, while including soft blockages in a slightly wider area, surrounding the hard blockages. For areas 
where hard and soft placement blockages overlap, the hard placement blockage takes priority. 
Since the above are variables, their settings will be lost after exiting the current IC Compiler session. The 
simplest way to ensure that these settings are applied during subsequent sessions for placement, CTS and 
routing, is to include them in your .synopsys_dc.setup file.

Design Planning
IC Compiler 12-26© 200926 2-Apply Specific Placement Blockages
RAM5
Pins are on 
left and right
set_keepout_margin -type hard -outer {10 0 10 0} RAM5
{left bottom right top}hard or soft
/square6Pad the macro to reduce congestion around the pinsStarting Floorplan
GUI: Placement /barb2rightS et Keepout Margin…
In the example above, the shown macro is not placed near another macro or the edge of the core. 
However, congestion appears along the left and right edges, where the macro pins are. The above 
command allows you to apply hard or soft blockages around specified edges of specified macro 
cells.
Note: The “left bottom right top” edges which the numbers in parenthesis are associated with, 
correspond with the left, bottom, right and top edges, respectively, of the macro cell in its original
orientation. If, for example, the above macro cell were rotated counter clock-wise by 90 degrees, 
the “left” hard blockage area of 10 would rotate with the macro and would appear, from the core 
area’s point of view, to be on the bottom edge of the macro.
The following commands allow reporting and removal:
report_keepout_margin
remove_keepout_margin
Note: ICC automatically applies a keep-out margin for each macro based on pin-count, if no user-
defined or library-defined margin exists.

Design Planning
IC Compiler 12-27© 200927 2-Summary: Create the Starting Floorplan
open_mw_cel DESIGN_data_setup
create_cell ...
read_io_constraints <TDF_file>
initialize_floorplan ...
insert_pad_filler ...
derive_pg_connection ...
create_pad_rings ...
set_ignored_layers –max M7
# Manually place macro cells, as
# applicable, and “fix” their placement:
set_dont_touch_placement [all_macro_cells]
set_fp_macro_options ...
set_fp_macro_array ...
set_fp_relative_location …
set physopt_hard_keepout_distance <#>
set placer_soft_keepout_channel_width <#>
set_keepout_margin …Data setup
Starting Floorplan         Placement          Reduce Congestion         PNS          Reduce Delay        Write FloorplanStarting Floorplan
Initialize the floorplanSpecify pad cell locationsCreate physical-only pad cells
Define known macro/std cell placementSpecify ignored routing layers
Define known placement blockagesCreate P/G pad ringsInsert pad filler cells

Design Planning
IC Compiler 12-28© 200928 2-Test For Understanding
1.What are “physical-only” cells? What are some 
examples of physical-only pad cells?
2.What does the TDF file define?
3.What does initialize_floorplan do? 
Cirlce all that apply:
a)Defines placement rows within the core area
b)Defines the chip boundary or periphery area
c)Places IO pad cells in their defined locations
d)Places macro cells per their placement constraints
4.A “soft” placement blockage will:
a.Allow only timing-critical cells to be placed
b.Allow only non timing-critical cells to be placed
c.Allow cell placement only during initial coarse placement
d.Prevent cell placement during initial coarse placement1.Cells that are not part of the synthesized netlist, for example VDD/GND, corner and filler pad 
cells.
2.Pad cell locations
3.A, Band C
4.D. Any subsequent legalization, placement and optimization steps are allowed to place cells in 
the soft blockage area.

Design Planning
IC Compiler 12-29© 200929 2-Virtual Flat PlacementPerform Virtual Flat Placement
Perform virtual flat placementSet placement strategy parameters
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
Starting Floorplan         Placement          Reduce Congestion         PNS          Reduce Delay        Write Floorplan Placement

Design Planning
IC Compiler 12-30© 200930 2-Set Placement Strategy Parameters
/square6Placement strategy parameters are used to control the 
following during create_fp_placement :
/circle6How macros are handled
/circle6Optimization algorithms and effort
/square6C
onsider setting a “sliver size” and turning on “virtual 
IPO”:
/circle6In the example above standard cells will not be plac ed in 
channels between macros ( slivers ) of less than 10 microns
/rhombus6Helps to reduce potential congestion between macros
/circle6Next slide: Explanation of v irtual in-place optimization (VIPO )
/circle6Use default settings for the remaining options (see notes 
below) unless you have a specific need to modify themreport_fp_placement_strategy
set_fp_placement_strategy -sliver_size 10
-virtual_IPO onPlacement
set_fp_placement_strategy
-ma
cro_orientation automatic | all | N
-auto_grouping none | user_only | low | high
–macro_setup_only on | off
-macros_on_edge on | off
-sliver_size <0.00>
-snap_macros_to_user_grid on | off
-fix_macros none | soft_macros_only | all
-congestion_effort low | high
-IO_net_weight < 1.0>
-plan_group_interface_net_weight <1.0>
-voltage_area_interface_net_weight <1.0>
-voltage_area_net_weight_LS_only on | off
-spread_spare_cells on | off
-legalizer_effort low | high
-virtual_IPO on | off 
-pin_routing_aware on | off

Design Planning
IC Compiler 12-31© 200931 2-VF Placement with Virtual IPO (VIPO)
4332 25 56Original netlist contains large 
fan-outs along the critical 
path which can contribute 
significantly to delayTiming-critical path
additional
fan-out on netPlacement
433225 56VF Placement without VIPO Without VIPO, cells along the 
critical path are placed close 
together to reduce delay – this 
can cause congestion and may 
not be necessary, since IPO 
during actual placement 
optimization can easily With VIPO turned ON, 
sizing and buffer 
insertion (which 
mimics more realistic 
placement 
optimization) is 
performed “in 
memory”, thus 
relaxing the need to 
unnecessarily shorten 
the distance between 
the critical cells43VF Placement with VIPO
56 32 25

Design Planning
IC Compiler 12-32© 200932 2-Perform Virtual Flat Placement
Perform quick placement, which will be used to:
/circle6Improve floorplan’s impact on congestion and timing
/circle6Plan the power structure
create_fp_placement –timing_driven –no_hierarchy_gravityTURN OFF this 
option for flat 
design planning
/xrhombusStandard cells and non-fixed macros are legally placed
/xrhombusBy default placement is wirelength-driven /barb2right/barb2right /barb2right/barb2rightenable timing-driven
/xrhombusNo logic optimization is done
/xrhombusBy default clumps cells within same logical hierarchy /barb2right/barb2right /barb2right/barb2rightturn gravity off
Placement
GUI: Placement /barb2right/barb2right /barb2right/barb2rightPlace Macros and Standard Cells …
create_fp_placement
[-effort string]
[-max_fanout integer]
[-no_hierarchy_gravity]
[-no_legalize]
[-incremental string]
[-plan_groups collection of plan groups]
[-voltage_areas collection of voltage areas]
[-congestion_driven]
[-timing_driven]
[-num_cpus integer]
[-optimize_pins]
[-ignore_scan]
The –timing option is used to more closely mimic the timing-driven algorithm used by default during actual 
placement ( place_opt ).
The –num_cpus <#> option allows the use of additional free CPUs on your machine for faster, parallel processing, 
using only one license.
Note: create_fp_placement uses the entire core area as the placement area, not the placement rows. As a result, 
if you have “cut” out part(s) of the placement rows, cells will be still be placed in the cut area(s). To prevent this apply 
a placement blockage on the “cut” area(s): create_placement_blockage .

Design Planning
IC Compiler 12-33© 200933 2-Hierarchy Aware Placement or Gravity
/square6By default create_fp_placement performs 
hierarchy-aware placement (gravity = ON)
/circle6Placement tries to keep cells in the same logical 
h
ierarchy blocks physically close
/circle6The resulting placement becomes a useful guide to 
f
orm physical “partitions” in a hierarchical design flow 
(discussed in the “ IC Compiler 2: HDP ” workshop)
/square6In a non-hierarchical design flow (this workshop) 
“gravity” should be turned off
Hierarchy Gravity Off Hierarchy Gravity On
Hierarchical 
design planningFlat design 
planningPlacement

Design Planning
IC Compiler 12-34© 200934 2-Summary: Virtual Flat Placement
Starting Floorplan         Placement          Reduce Congestion         PNS          Reduce Delay        Write Floorplan Placement
Virtual Flat  PlacementPerform virtual flat placementDefine placement parametersCreate starting floorplan
set_fp_placement_strategy -sliver_size 10 \
-virtual_IPO on
create_fp_placement –no_hierarchy –timing

Design Planning
IC Compiler 12-35© 200935 2-Reduce Congestion
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
Starting Floorplan         Placement          Reduce Congestion         PNS          Reduce Delay        Write Floorplan Reduce Congestion
Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placements

Design Planning
IC Compiler 12-36© 200936 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsIs the Design Congested?
Congestion map (heat map) 
route_global -congestion_map_only; # More accurate
OR
route_fp_proto –congestion_map_only \
–effort medium;     # Runs fasterReduce congestion

Design Planning
IC Compiler 12-37© 200937 2-Understanding the Congestion Calculation
Routing tracks GRC grid29/28
28/2839/35 40/35Number of nets crossing the global routing 
cell (GRC) edge (left #), versus 
Number of available routing tracks (right #)
The size of the ‘overflow’ determines the highlighting 
color – larger overflows are brighter or ‘hotter’Overflow = 
40 – 35 = 5
Congestion map (heat map) Reduce congestion
GRC – The size of a global routing cell in general is double the height of a s tandard cell, squared.
For congestion analysis, the tool works on a congestion grid. Each grid models the routing layers 
that overlap with that grid, producing a density plot that shows the level of routing congestion. To 
generate the congestion map, the tool combines all the declared routing blockages (floorplan and 
standard cell) to produce a single congestion map that is displayed in the GUI.
A textual congestion report is also available with report_congestion+
Routing blockages Cell blockages
Congestion mapOne congestion
gridMetal Routing
Blockages

Design Planning
IC Compiler 12-38© 200938 2-Congestion Guidelines
Congestion can be serious or “un-acceptable” if one or 
more of the following are true:
/square6Large or many “hotspots”
in the congestion map
/circle6Serious routability challenge
/square6A
ny GRC “overflow” larger 
than around 10
/circle6Possible non-routable nets
/square6A
bout ~2%, or more, GRC 
edges have an overflow
/circle6Possible signal integrity or 
t
iming degradation issuesReduce congestion
/square6I f congestion is not a problem move on to “PNS”, 
otherwise ….
In the example below we see part of the log output after creating a global route congestion map. 
Specifically we’re looking in the “Routing result” section, at the line that summarizes the GRC 
overflows for both horizontal and vertical directions. In this example the “Max” overflow is 13. 
This means that there is at least one GRC edge with an overflow of 13, for example “19/6”. This 
means that there are 13 routes that want to route through a specific GRC area which do not have 
any available routing resources. In practice, any maximum GRC overflow of around 10, or larger, 
has a very high probability of resulting in unroutable (shorts or opens) nets in that area.
The total number of GRC overflows is 2.73%. This means that 2.73% of the total number of GRC 
edges in the design have an overflow of 1 or more. In practice, if this number is around 2% or 
more (this is a very rough guideline and is very design-dependent), this can result in poor routing 
overall, which could manifest itself in signal integrity (e.g. crosstalk) problems or poor timing.
---------------------------------------------------------------------------------------------------------
phase5. Routing result:
phase5. Both Dirs: Overflow = 3621 Max = 13 GRCs = 2247 (2.73%)
phase5. H routing: Overflow = 1724 Max = 13 (1 GRCs) GRCs = 1139 (1.38%)
phase5. V routing: Overflow = 1897 Max = 8 (1 GRCs) GRCs = 1108 (1.34%)
phase5. METAL    : Overflow = 1162 Max = 8 (3 GRCs) GRCs = 879 (2.13%)
phase5. METAL2   : Overflow = 1826 Max = 6 (4 GRCs) GRCs = 1079 (2.62%)
phase5. METAL3   : Overflow = 562 Max = 7 (2 GRCs) GRCs = 440 (1.07%)
phase5. METAL4   : Overflow = 71 Max = 4 (1 GRCs) GRCs = 58 (0.14%)
phase5. METAL5   : Overflow = 0 Max = 0 GRCs = 0 (0.00%)
phase5. METAL6   : Overflow = 0 Max = 0 GRCs = 0 (0.00%)

Design Planning
IC Compiler 12-39© 200939 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsModify Macro Placement Constraints
set_fp_macro_options ...
set_fp_macro_array ...
set_fp_relative_location ...
/square6I ncrease spacing between macros
/square6Align bus signal pins between macros
/square6Change orientation (rotate and/or mirror)Modify “fp placement strategy” optionsModify macro placement constraints
Modify std cell placement constraintsReduce congestion

Design Planning
IC Compiler 12-40© 200940 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsApply Standard Cell Placement Constraints
set_congestion_options ...
create_placement_blockage ...Modify “fp placement strategy” optionsModify macro placement constraints
Modify std cell placement constraints
/square6Apply additional placement constraintsset physopt_hard_keepout_distance 10
set placer_soft_keepout_channel_width 25
set_keepout_margin -type hard -outer {10 0 10 0} RAM5/square6M odify existing keepout constraints 
around macro edges
Shown nextDiscussed
earlierReduce congestion
The “keepout” constraints were discussed in detail during the “Create Star ting Floorplan” section, 
so will not be repeated here.

Design Planning
IC Compiler 12-41© 200941 2-Is High Cell Density Causing Congestion?
/square6Cell density can be up to 
95% in any given area of 
the chip or block, by 
default
/square6High cell density may be 
causing high congestion
/square6Look at a cell density map
/circle6If cell density hotspots 
c
oincide with congestion 
hotspots /barb2rightLower cell 
density in that areaCongestion map
Cell density map
Reduce congestion

Design Planning
IC Compiler 12-42© 200942 2-Reducing Cell Density Hotspots
x1 y1x2 y2Reduce congestion
set_congestion_options -max_util 0.4 \
-coordinate {x1 y1 x2 y2}
The argument to –m ax_util is specified as 0.0 – 1.0, corresponding to 0-100%. The 
maximum utilization is 95% by default.
In the example above, set_congestion_options is used on a specific region that was 
identified as congested in a previous placement run. The tool can be forced to reduce the 
placement density in this region using the command as shown above (coordinates are in microns ). 
Note however that areas around this region may in turn become more congested.
When using set_congestion_options without –coordinate, the density level is applied 
to the entire standard cell placement area.  For example: Assume the initial overall placement 
utilization is 80%. This means that, by default, you can have "local" high density areas of up to 
95%, and other areas of less than 80% density (peaks/valleys). If you lower the max_uitl to 
something less than 95%, but greater or equal to the overall uitlization percentage, the 
peaks/valleys will be smoothed out. It is recommend to allow as HIGH a density as possible, to 
reduce the impact on timing.

Design Planning
IC Compiler 12-43© 200943 2-
Coordinate-based Placement Blockages
Floorplan /barb2right/barb2right /barb2right/barb2rightCreate Placement Blockage…
create_placement_blockage –name LL_CORNER -type hard \
-bbox {345.540 355.790 392.280 400.070}
Reduce congestion
The following commands allow reporting and removal:
get
_placement_blockages
remove_placement_blockage

Design Planning
IC Compiler 12-44© 200944 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsModify “FP Placement Strategy” Options
/square6Up to now default options were used, except for 
set_fp_placement_strategy –sliver_size 10
/square6Modify macro placement strategy options, as 
appropriate, to help reduce congestionReduce congestion
Modify “fp placement strategy” optionsModify macro placement constraints
Modify std cell placement constraints
/square6Placement of non-fixed macros 
during virtual flat placement are 
affected by “fp placement 
strategy” options
*********************************************
Report     : report_fp_placement_strategy
Design CEL : ORCA.CEL;1
Date       : Mon Nov 19 12:49:01 2007
*********************************************
*** Macro related parameters ***
set_fp_placement_strategy -macro_orientation automatic | all | N
current setting: automatic
default setting: automatic
set_fp_placement_strategy -auto_grouping none | user_only | low | high
current setting: low
default setting: low
set_fp_placement_strategy -macro_setup_only on | off
current setting: off
default setting: off
set_fp_placement_strategy -macros_on_edge on | off
current setting: off
default setting: off
…
1

Design Planning
IC Compiler 12-45© 200945 2-Placement Strategy Options and Defaults
set_fp_placement_strategy
-macro_orientation automatic | all | N
-auto_grouping none | user_only | low | high
–macro_setup_only on | off
-macros_on_edge on | off
-sliver_size < 0.00>
-snap_macros_to_user_grid on | off
-fix_macros none | soft_macros_only | all
-congestion_effort low | high
-IO_net_weight < 1.0>
-plan_group_interface_net_weight < 1.0>
-voltage_area_interface_net_weight < 1.0>
-voltage_area_net_weight_LS_only on | off
-spread_spare_cells on | off
-legalizer_effort low | high
-virtual_IPO on | offReduce congestion
Some examples 
shown next

Design Planning
IC Compiler 12-46© 200946 2-Macro Placement Strategy Examples
/square6Push macros to core edges for congestion control
/square6Group related macros into an array to improve timing 
and congestion
set_fp_placement_strategy -auto_grouping highset_fp_placement_strategy -macros_on_edge on
Macros on the 
edge and auto 
grouping enabled
-auto_grouping none     -auto_grouping highReduce congestion
“related macros” are macros connected to the same nets.

Design Planning
IC Compiler 12-47© 200947 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsPerform Congestion-driven Placement
/square6After modifying the various 
placement constraints perform 
another virtual flat placement
/square6Enable congestion-driven mode
create_fp_placement –timing -no_hierarchy_gravity \
–congestion 
Do not use congestion-driven 
mode on designs with no 
congestion!!Reduce congestion

Design Planning
IC Compiler 12-48© 200948 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placementsInvoke the High Effort Congestion Strategy
If congestion is still not acceptable, 
perform high-effort congestion-driven 
placement:
route_global -congestion_map_only; # OR
route_fp_proto –congestion_map_only –effort medium
set_fp_placement_strategy -congestion_effort high
create_fp_placement –timing -no_hierarchy_gravity \
–congestion Reduce congestion
The –congestion_effort option is medium by default, if not explicitly set.

Design Planning
IC Compiler 12-49© 200949 2-Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power network
Write out floorplan and DEF 
filesModify the Floorplan
/square6Top-level pads or ports
/circle6Spread, re-order or move to other sides
/circle6Change to a different metal layer
/square6C
ore aspect ratio and size
/circle6Make taller/wider to add more 
h
orizontal/vertical routing resources
/circle6Increase the core area to reduce 
u
tilization (cell density)
/square6Modify power grid structure
/circle6Use higher metal layers
/circle6Change width and/or spacing of strapsI
f congestion is still a problem start 
over with a modified floorplan: Reduce congestion
Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placements
Large, wide power nets may cause problems as they act like barriers to placement. 
You can determine this by running a trial where you ignore the blocking effect of power straps  
and see if placement works. Possible changes: 
Change the power strap metal to a higher layer so that it does not impact cell placement.
Change the location of the power strap routes to avoid the congested area.
Change the power straps to be narrower and/or with more space between them.

Design Planning
IC Compiler 12-50© 200950 2-Reduce   Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-driven
virtual flat placement
Analyze congestion
“Fix” all macro cell placements“Fix” All Macro Cell Placement
After all congestion issues are 
resolved, “fix” the placement of 
all macro cells to prevent any 
subsequent placement steps 
from moving them 
set_dont_touch_placement [all_macro_cells]Reduce congestion

Design Planning
IC Compiler 12-51© 200951 2-Design PlanningReduce     Congestion Perform congestion-driven
virtual flat placementModify placement constraintsAnalyze congestion
Modify the floorplanAnalyze congestion
Perform high-effort congestion-
driven virtual flat placement
Analyze congestionVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power network
Write out floorplan and DEF 
filesSummary: Reduce Congestion
Reduce congestion
# Analyze congestion:
route_global -congestion_map_only; # OR
route_fp_proto –congestion_map_only –effort medium 
# Modify macro placement constraints:
set_fp_macro_options ...
set_fp_macro_array ...
set_fp_relative_location ...
# Modify existing std cell keepout constraints:
set physopt_hard_keepout_distance <#>
set placer_soft_keepout_channel_width <#>
set_keepout_margin ...
# Apply additional std cell placement constraints:
set_congestion_options ...
create_placement_blockage ...
# Modify fp placement strategy options:
set_fp_placement_strategy ...
# Perform congestion-driven placement:
create_fp_placement –timing –no_hier –congestion 
# Analyze congestion, as above. If still congested
# enable high-effort congestion mode:
set_fp_placement_strategy -congestion_effort high
create_fp_placement –timing –no_hier –congestion 
# Analyze congestion and if still a
# problem /barb2right/barb2right /barb2right/barb2rightre-floorplan.
# Fix the placement of all macro cells:
set_dont_touch_placement [all_macro_cells]

Design Planning
IC Compiler 12-52© 200952 2-Test For Understanding (1 of 2)
1.Circle the correct statement(s) about what  
create_fp_placement does by default: 
a.Optimizes logic (cell sizing, buffering) to improve timing
b.Legally places std cells and non-fixed macros to minimize 
wire length
c.Optimizes placement to improve timing
d.Clumps cells from the same logical hierarchy together
2.Comparing “9/1” and “20/12” in a congestion map:
a.They are equally bad
b.20/12 is worse because both numbers are much larger
c.9/1 is worse the ratio is much larger
d.Can not tell without also comparing their “heat” colors
3.What are some common areas for congestion to 
occur?1.B and D . create_fp_placement does not do any logic or netlist optimization, but can 
optimize placement for timing if timing-driven mode is enabled with
–timing. The resulting placement is always legalized. By default “gravity” is enabled, 
which clumps cells from the same logical hierarchy together.
2.A. They both have an overflow of 8, and therefore the same “heat” color (white, by default).
3.Between macro cells, near macro edges and corners, and in high cell density areas.

Design Planning
IC Compiler 12-53© 200953 2-Test For Understanding (2 of 2)
4.Macro placement can be controlled by:
a.Manually placing macros prior to virtual flat placement
b.Specifying general “placement strategy parameters” prior 
to virtual flat placement
c.Applying “macro placement constraints” (options, arrays, 
relative location) after the last virtual flat placement
d.All of the above
5.If you can not achieve acceptable congestion after 
modifying placement constraints and parameters, as 
well as performing high effort congestion-driven 
virtual flat placement, what should you do?4. B. Manually placed macros must also be “fixed” ( set_dont_touch_placement) 
otherwise vf placement is free to move them. Macro placement constraints must also be 
applied prior to vf placement and are implemented during placement, not independently after 
placement.
5. Start over with a modified floorplan: Change the pad or port locations or metal layers; Change 
the core size and/or shape; Change the power grid structure.

Design Planning
IC Compiler 12-54© 200954 2-Synthesize the Power Network (PNS)
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
Starting Floorplan         Placement          Reduce Congestion         PNS          Reduce Delay        Write Floorplan PNS
Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR drop

Design Planning
IC Compiler 12-55© 2009


Design Planning
IC Compiler 12-56© 200956 2-Define Logical Power/Ground Connections
/square6Make sure that logical 
P/G connections are 
defined prior to PNS
/circle6This may have already 
b
een done during Data 
Setup and/or creation of 
pad P/G rings
/square6One command for each 
power/ground netPNS
derive_pg_connection -power_net VDD -power_pin VDD -ground_net VSS -ground_pin VSS
derive_pg_connection -power_net VDDO -power_pin VDDO -ground_net VSSO -ground_pin VSSO
derive_pg_connection -power_net VDDQ -power_pin VDDQ -ground_net VSSQ -ground_pin VSSQ
GUI: Preroute /barb2right D erive PG Connection …
Note: Need to re-run this command each time the user "manually" introduces new cells (e.g. 
create_cell, eco_netlist, read_mw_eco_list, etc.)

Design Planning
IC Compiler 12-57© 200957 2-
Apply Power Network Constraints
set_fp_rail_constraints ...
PNS
set_fp_rail_constraints
[-a
dd_layer | -remove_layer | -remove_all_layers | -set_ring | 
-skip_ring | -set_global]
[-layer layer] [-direction vertical | horizontal]
[-max_strap number] [-min_strap number]
[-max_width distance] [-min_width distance]
[-spacing distance | minimum | interleaving]
[-offset distance]
[-nets nets]
[-horizontal_ring_layer layer] [-vertical_ring_layer layer]
[-ring_width distance]
[-ring_max_width distance] [-ring_min_width distance]
[-ring_spacing distance] [-ring_offset distance]
[-extend_strap core_ring | boundary | pad_ring]
[-keep_floating_segments]
[-no_stack_via] [-no_same_width_sizing]
[-optimize_tracks]
[-keep_ring_outside_core]
[-no_routing_over_hard_macros] [-no_routing_over_soft_macros]
[-ignore_blockages]

Design Planning
IC Compiler 12-58© 200958 2-
Synthesize and Analyze the Power Network
Preview of power plan with IR-drop heat map 
– no actual routes created yet
1
2
3
4PNS calculates the 
required number of straps 
based on provided 
constraints. Heat map aids 
the analysis
synthesize_fp_rail ...PNS
GUI: Preroute /barb2right Synthesize Power Network 
Make sure to specify:
1.Power/Ground net pair and target IR drop
2.Core area power budget of the synthesized nets
3.Power pad information
4.Output directory
Note: If the power network is manually designed, or is designed by a 3rdparty tool and loaded into 
IC Compiler, the user can perform explicit power network analysis (PNA) with:
TCL: analyze_fp_rail ...
GUI: Preroute /barb2right Analyze Power Network

Design Planning
IC Compiler 12-59© 200959 2-Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR dropModify Constraints and Re-synthesize
If the maximum IR drop is 
not acceptable
/circle6Modify power network 
c
onstraints
/circle6Re-synthesize
/circle6Repeat as neededPNS
/checkbld/checkbld/checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Design Planning
IC Compiler 12-60© 200960 2-
Create Virtual Power/Ground Pads if Needed
PNS
create_fp_vitual_pad ...
# Then “Apply” PNS to update heat map Above example indicates that 
additional P/G pads may help
Use the mouse to define the center coordinates of virtual P/G pads, as needed.  
As the virtual pads are created, they appear in the “Virtual power pads” list box.  Add, Remove and 
Remove All buttons allow editing the list of virtual pads. Once the list is complete, Load it to see 
the effect on IR-drop, and/or Save it to a file for future analysis.  
The virtual pads are saved with the CEL when the design is saved.  Virtual pads can be removed 
with remove_fp_virtual_pad.
The .vpad file is useful for editing and documentation of new pads that will later be physically 
instantiated.

Design Planning
IC Compiler 12-61© 200961 2-Add Additional P/G Pads to TDF and Re-load
If additional P/G pads are 
required
/circle6Add them to the TDF file
/circle6Start over and create a 
n
ew starting floorplanPNS
Create starting floorplan
Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR drop/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld
remove_io_constraints
create_cell ...
read_io_constraints <TDF_file>
initialize_floorplan ...
...

Design Planning
IC Compiler 12-62© 200962 2-
Commit the Power Network
Preview (Apply)
Build (Commit) the power network
Straps and rings 
are routed
commit_fp_railPNS

Design Planning
IC Compiler 12-63© 200963 2-Connect P/G Pins and Create Power Rails
PNS
preroute_instances
preroute_standard_cells \
-fill_empty_rows \
-remove_floating_pieces/square6C onnect P/G macro pins 
and pad pins to core rings 
and straps
/square6Create power rails along 
the standard cell 
placement rows
Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR drop/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Design Planning
IC Compiler 12-64© 200964 2-Analyze the Power Network
After “commit” and after P/G pins 
and rails have been pre-routed /barb2right
Analyze the power network for a 
more accurate IR-drop map
analyze_fp_rail ...
# If IR-drop is not acceptable:
close_mw_cel
open_mw_cel DESIGN_pre_pns
# Begin a new PNS flowPNS
GUI: Preroute /barb2right Analyze Power Network 
Make sure to specify:
1.Power/Ground net pair and target IR drop
2.Core area power budget of the synthesized nets
3.Power pad information
4.Output directory

Design Planning
IC Compiler 12-65© 200965 2-Apply Power Net Placement Blockages
Complete pnet blockage
on metal 2 and 3Partial pnet blockage
on metal 2 and 3
metal 2metal 3fmetal 2metal 3
All cells allowed 
under P/G strapsmetal 6Metal 7fNo pnet blockage
Cells allowed under 
P/G nets, with min 
pin-to-strap spacing No cells allowed 
under P/G straps
More uniform cell density /barb2right/barb2right /barb2right/barb2right
Less overall congestionLess congestion
along P/G nets
set_pnet_options -partial {metal2 metal3}
set_pnet_options –complete {metal2 metal3}PNS
No blockage :  In most designs, P/G straps are routed on metal 4 or higher layers. Since most 
standard cell pins are on metal 1 (in rare instances, metal 1 and metal 2), there is usually no reason, 
in these designs, to prevent standard cells from being placed under the P/G routes. The router 
should be able to easily route to the pins under the straps. By allowing cells under the straps, a 
more uniform cell density can be achieved during placement, which helps to reduce overall 
congestion. In a core-limited design, this also allows a smaller die size. 
Partial blockage : Some designs may require the use of lower level metal (e.g. metal 2 and metal 
3) for P/G routes. In order to achieve better overall congestion, the user can specify “partial” pnet 
blockages for these lower metal layers. This allows IC Compiler to place standard cells under the 
metal straps, while ensuring that no DRC violations (minimum spacing, shorts) occur between the 
cell pins and the straps. The trade-off is that this may make it more difficult for the router to access 
the pins near the P/G straps, which would show up as congestion along these straps.
Complete blockage : To prevent congestion issues along the metal straps, the user can specify 
“complete” pnet blockages on the lower-level metal layers. This strategy increases utilization 
(since less of the core area is available for placement), creates less uniform cell density, which 
may increase congestion overall. In the rare case of a design with very low utilization (e.g. a pad-
limited design), congestion is typically not a concern. In this case, if “complete” pnet blockage is 
applied, more optimal routing (fewer vias and/or shorter traces) may be achievable for pins near 
the straps (which would otherwise be placed under the straps). 
Note : These constraints do not affect FIXED cells (e.g. fixed RAM, IP or macro cells). If these 
fixed cells are placed under power nets, applying a “complete” blockage will not move them out 
during placement, and a “partial” blockage will not move them to fix shorts. You must visually 
check macros and fix “manually” during the design planning phase.

Design Planning
IC Compiler 12-66© 200966 2-Perform Incremental Virtual Flat Placement
PNS
create_fp_placement \
-timing_driven \
-no_hierarchy_gravity \
-incremental allPerform an incremental 
p
lacement 
/circle6Standard cells are placed 
t
aking into account the 
power network
Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR drop/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Design Planning
IC Compiler 12-67© 200967 2-Summary: Synthesize the Power Network
Starting Floorplan Placement          Reduce Congestion         PNS       Reduce Delay        Write Floorplan PNS
save_mw_cel –as DESIGN_pre_pns
derive_pg_connection ...
set_fp_rail_constraints ...
synthesize_fp_rail ...
# Analyze IR-drop;
# Modify power network constraints
# and re-synthesize, as needed.
create_fp_virtual_pad; # If needed, then
# edit TDF file to add “real” P/G pads 
# and re-initialize floorplan.
commit_fp_rail
preroute_instances
preroute_standard_cells ...
analyze_fp_rail ...
# If IR-drop is not acceptable start
# over with the “pre_pns” cell.
set_pnet_options ...
create_fp_placement -timing_driven \
-no_hierarchy_gravity -incremental all
Synthesize Power NetworkAnalyze IR dropSynthesize the power networkApply power network constraints
Connect P/G pins to power networkCommit the power networkModify constraints and re-synthesize
Create power rails
Perform incremental placementDefine logical P/G connections
Apply pnet optionsAdd P/G pad cells, if neededSave the cell
Analyze IR drop

Design Planning
IC Compiler 12-68© 200968 2-Reduce Delay
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
Starting Floorplan Placement          Reduce Congestion         PNS       Reduce Delay        Write Floorplan Reduce Delay
Reduce Delay1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion

Design Planning
IC Compiler 12-69© 200969 2-Reduce Delay1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion/square6Before extracting net RC 
parasitics for timing analysis 
perform an actual global route 
(without –congestion_map_only )
/circle6By default timing analysis is 
b
ased on “virtual route”
/circle6Global route allows more 
a
ccurate timing analysis
/square6Analyze the congestion mapGlobal Route and Analyze Congestion
Reduce Delay
route_global; # OR
route_fp_proto –effort medium
GUI: Route /barb2right Global Route ...
Global route is the first of several steps performed during the routing phase of the design:
Global Route; Track Assign; Detail Route; Search and Repair.
By default timing analysis is performed based on a “virtual route”, which is an orthogonal route 
estimate comprised of an “average” RC characteristics of all available metal layers.
With a global route the actual metal layer and routing path through GRC cells are defined, 
enabling more accurate RC extraction, and therefore more accurate timing analysis.

Design Planning
IC Compiler 12-70© 200970 2-Modify Power Net Placement Blockages
Reduce Delay
/square6I f congested, check and modify 
power net ( pnet ) placement 
blockage options, as needed:
/circle6If c omplete blockages exist, 
remove or change to partial
/square6Perform incremental placement
Reduce Delay1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion
report_pnet_options
# Remove blockages:
remove_pnet_options OR
set_pnet_options -none {M6 M7}
# Modify existing options:
remove_pnet_options
set_pnet_options –partial {M2 M3}
c
reate_fp_placement -timing_driven \
-no_hierarchy_gravity -incremental all!
Changing a “complete” blockage to “partial”, or removing it altogether (no blockage), allows 
standard cells to be placed under those power straps, which increases the utilization. This may 
reduce congestion in the core area. It may create some congestion along the power straps.

Design Planning
IC Compiler 12-71© 200971 2-Reduce Delay1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestionReturn to “Reduce Congestion”, if Needed
Reduce Delay
/square6P erform another global route 
and analyze congestion
/square6If modifying pnet options is not 
applicable or does not fix the 
congestion issues, return to 
the “Reduce Congestion” step
/square6Once congestion is under 
control continue with RC 
extraction and timing analysis

Design Planning
IC Compiler 12-72© 200972 2-Reduce DelayExtract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion
1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract Net Parasitics and Analyze Timing
Reduce Delay
/square6Extract net parasitic RCs
/circle6Uses TLU-plus and global routing 
f
or improved timing accuracy
/square6Generate a timing report
/circle6Acceptable timing:
W
NS< 15-20% of required delay
/circle6If acceptable skip to “Write 
F
loorplan”
extract_rc
report_timing
It is advisable to perform a global 
route followed by RC extraction after 
any placement or timing optimization 
/barb2rightmore accurate timing analysis!
GUI: Route /barb2right Extract RC ...
The “acceptable timing” recommendation above is a general recommendation, not a rule. In 
general IC Compiler should be able to eliminate violations of up to 15-20% during placement, 
CTS, routing, and related optimizations.

Design Planning
IC Compiler 12-73© 200973 2-Reduce DelayExtract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion
1. Optimize timing (default effort)
2. Optimize timing (high effort)/square6If the WNS > 15-20% perform 
in-place optimization
/square6Repeat global routing, RC 
extraction and timing analyses
/square6If timing is still not acceptable, 
repeat timing optimization with 
high effort
/square6Repeat timing analyses stepsPerform In-Place Optimization
/xrhombusPerforms cell sizing, buffer insertion and AHFS
/xrhombusImproves timing and DRC violations
/xrhombusLegalizes placementReduce Delay
optimize_fp_timing –fix_design_rule
<-effort high>
GUI: Timing /barb2right In Place Optimization ...
AHFS: Automatic high fanout synthesis is an optimization algorithm for handling nets with large 
fanouts (>= 100).


Design Planning
IC Compiler 12-74© 200974 2-Reduce DelayExtract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan/Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion
1. Optimize timing (default effort)
2. Optimize timing (high effort)Modify Floorplan or Re-Synthesize, if Needed
If the timing violations are 
still unacceptably large after 
high-effort optimization :
/square6Modify the floorplan, or…
/square6Re-synthesize the design 
with
/circle6Better constraints
/circle6Better partitioningReduce Delay
If timing is still “unacceptable”:
1. Analyze and modify the floorplan, if applicable: Timing can sometimes be improved by, for 
example, modifying macro cell placement, or I/O pad  placement. 
2. Analyze the timing reports of the critical paths:
If the violations occur on input or output logic paths, the problem may be that the input/output 
constraints are too aggressive (to be conservative), and should be relaxed. Also, critical paths may 
be “false” violations which can be eliminated by including appropriate set_false_path or 
set_multicycle_path constraints. If the violating paths contain combinational logic that 
cross hierarchical boundaries, the design’s logical hierarchy is poorly partitioned, which can limit 
logic optimization at the sub-block boundaries. The design may be able to be repartitioned, if this 
does not significantly impact verification (for example: Simulation testbenches may be “probing”
the value of specific sub-block pins. If re-partitioned, these probe points may disappear, which 
breaks the verification testbench).
If any constraint- or partitioning-related issues are observed, have the design re-synthesized with 
modified constraints and/or partitioning. Repeat the design planning steps from the beginning.

Design Planning
IC Compiler 12-75© 200975 2-Summary: Reduce Delay
Starting Floorplan Placement          Reduce Congestion         PNS       Reduce Delay        Write Floorplan Reduce Delay
route_global; # OR
route_fp_proto –effort medium
# If congested modify pnet blockages 
# and perform inc’l placem’t, as needed:
report_pnet_options
remove_pnet_options; # OR
set_pnet_options -none {M2 M3} 
set_pnet_options –partial {M2 M3}
create_fp_placement -timing_driven \
-no_hierarchy_gravity -incremental all
route_global; # OR
route_fp_proto –effort medium
# If congested goto “Reduce Congestion”
extract_rc
report_timing
# If timing OK skip to “Write Floorplan”
optimize_fp_timing –fix_design_rule
<–effort high>
# If timing still not OK after
# high-effort optimization then need to
# re-floorplan or re-synthesizeReduce Delay1. Optimize timing (default effort)
2. Optimize timing (high effort)Extract RC/Analyze timingGlobal route/Analyze congestion
3. Modify floorplan or Re-synthesizeCreate starting floorplan
Reduce congestionDC-T synthesis with 
default floorplan
Modify pnet placement blockages
Global route/Analyze congestion

Design Planning
IC Compiler 12-76© 200976 2-Write Out the Floorplan and DEF Files
Write Floorplan and DEF FilesWrite out a DEF fileWrite out a floorplan file
Close the design
Design PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
Starting Floorplan Placement          Reduce Congestion         PNS       Reduce Delay        Write Floorplan Write Floorplan

Design Planning
IC Compiler 12-77© 200977 2-Write Out Floorplan and DEF Files
Write Floorplan
/square6W rite out a DEF file:
/circle6Will be used by D esign Compiler 
Topographical for re-synthesis 
/square6Write out a floorplan file:
/circle6Will be loaded into IC Compiler 
a
fter re-synthesis and data setup
/square6Close the design cell without 
saving it
/circle6Only the above files are needed
write_floorplan -row -track -create_terminal –preroute \
-placement {io hard_macro} DESIGN.fp
write_def –version 5.6 -macro –fixed –blockage \
-routed_nets –specialnets –output DESIGN.def
close_mw_celWrite Floorplan and DEF FilesWrite out a DEF fileWrite out a floorplan file
Close the design

Design Planning
IC Compiler 12-78© 200978 2-Re-synthesisRe-Synthesize Before Placement
DC-T re-synthesis with 
DEF floorplan
Data setup with re-
synthesized netlist
Load floorplan
PlacementDesign PlanningVirtual flat placementCreate starting floorplan
Reduce delaySynthesize power networkReduce congestion
Write out floorplan and DEF filesDC-T synthesis with 
default floorplan
Data setup
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld/square6Initial synthesis used a default DC-T 
floorplan
/square6Re-synthesis with an actual floorplan
provides IC Compiler with a more 
accurate netlist
The above flow is recommended for designs with challenging “quality of results” (QoR) 
requirements. By re-synthesizing the design with DC-Topographical using an accurate floorplan 
you are providing IC Compiler with a potentially better starting netlist, which may give better 
results. If QoR is not critical, the re-synthesis step can be skipped and the resulting cell after 
design planning, with its netlist from the first synthesis execution, is taken directly to placement.
The above flow assumes that the RTL code is fairly complete when performing the initial 
synthesis. If the RTL contains a fair number of “black boxes” (i.e. undefined sections) you may 
need to perform additional iterations of design planning and synthesis, as the RTL code is 
solidified.

Design Planning
IC Compiler 12-79© 200979 2-Re-Synthesize Before Placement
dc_shell-topo> read_verilog ORIGINAL_RTL.v
dc_shell-topo> source ORIGINAL_CONSTRAINTS.cons
dc_shell-topo> extract_physical_constraints DESIGN.def
dc_shell-topo> ...
dc_shell-topo> compile_ultra ...
dc_shell-topo> ...
dc_shell-topo> write –format ddc –output DESIGN_2.ddc
create_mw_lib design_lib_orca_2 ...
set_tlu_plus_files ...
import_designs DESIGN_2.ddc -format ddc -top DESIGN_TOP
derive_pg_connection ...
read_sdc ...
...
read_floorplan DESIGN.fp
# Re-apply pnetoptions and ignored layer constraint 
# (if applicable) since these are not included
# with above floorplan TCL constraints
set_ignored_layers –max M7
set_pnet_options –partial | -complete ...
save_mw_cel –as DESIGN_floorplannedLoad the floorplan
into DC-T
Write out the 2nd
pass netlist
Data Setup: 
Create a 2ndpass 
s
tarting cell
Load the floorplan
Re-apply ignored 
layers and pnet
options
PlacementDesign Planning
The set_ignored_layers and set_pnet_options attributes are not saved with the 
floorplan file, so they need to be re-applied.

Design Planning
IC Compiler 12-80© 200980 2-Test For Understanding (1 of 2)
1.Circle the correct statement(s) about PNS: 
a.Allows what-if analysis based on different user constraints
b.Creates DRC/ERC clean routes with synthesize_fp_rail
c.C an automatically calculate the width and number of straps 
based on power and IR-drop constraints
d.Allows what-if analysis with “virtual” IO signal pads
2.A “partial” pnet blockage allows cells to be placed 
only under the specified metal layers (DRC permitting) 
– all other layers are completely blocked.
True or False?1.A and C . Routes are created with commit_fp_rail. What-if analysis can only be done 
with virtual power/ground pads, not signal IO pads.
2.False . A partial pnet blockage will allow cells to be placed under the specified metal layers, 
DRC permitting. The unspecified layers are not blocked at all .

Design Planning
IC Compiler 12-81© 200981 2-Test For Understanding (2 of 2)
3.Circle the correct statement(s) regarding 
optimize_fp_timing -fix_design_rule :
a.Optimizes placement improve DRC violations 
b.Optimizes the logic to improve timing violations
c.Optimizes placement to reduce congestion
d.Optimizes placement to improve timing violations
4.Why is it recommended to execute route_global
and extract_rc prior to timing analysis?
5.What are the DEF and the TCL floorplan constraints 
files used for?
6.What is the point of doing DC-T re-synthesis
after the floorplan is completely defined?3. B. Placement is legalized, but not optimized.
4. Performing an actual global route (without –congestion_map_only) along with 
extract_rc allows for more accurate RC parasitic extraction and timing analysis.
5. The DEF file is read in by Design Compiler for re-synthesis. The TCL floorplan constraints file 
is read in by IC Compiler after re-synthesis to create a design that is ready for placement.
6. The netlist generated after re-synthesis is based on an actual floorplan, rather than DC-T’s 
“default” floorplan. If the design contains many macros, and/or has a non-square core shape, 
and/or has unusually high or low utilization, and/or has many placement blockages, the re-synthesized netlist will be better optimized, which can reduce the timing violations as well as 
iteration cycles during physical design.

Design Planning
IC Compiler 12-82© 200982 2-Summary 
You should now be able to:
/square6Use IC Compiler to create a non-hierarchical chip-
level floorplan
/square6Create a floorplan that is likely to be routable and 
achieve timing closure

Design Planning
IC Compiler 12-83© 200983 2-Lab 2: Design Planning
100 minutes
Define core and 
periphery areas
Manually place some 
macros
Perform virtual flat 
placement
Analyze congestionDefine pad cell 
locations
Synthesize/analyze 
the power network
Analyze timing

Design Planning
IC Compiler 12-84© 2009Appendix A
Floorplan exploration and re-synthesis for 
floorplans created by 3rdparty tools

Design Planning
IC Compiler 12-85© 200985 2-Re-Synthesis
Floorplan ExplorationDesign Planning
(3rdparty tool)Floorplan Exploration and Re-Synthesis Flow
Floorplan
(DEF)
Floorplan
Exploration
(ICC)
Placement
(ICC)Initial netlist
(ddc)
Physical (floorplan) 
constraints
(TCL)2ndpass 
netlist (ddc)
Data Setup
(ICC)
Starting cell
(Milkyway)Synthesis using 
default floorplan
(DC-T)Synthesis using 
ICC floorplan
(DC-T)
Data Setup
(ICC)
Floorplanned cell
(Milkyway)Load floorplan
(ICC)Starting cell
(Milkyway)
Floorplan
(DEF)

Design Planning
IC Compiler 12-86© 200986 2-Floorplan Exploration Objectives
If so, determine what should be modified to prevent 
these issues:
/square6Standard cell
placement 
constraints
(e.g. blockages)
/square6Floorplan
/square6Synthesized
netlistQuickly determine, before placement, if the final layout 
may run into routability or timing issues
Synthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
Floorplan Exploration    Acceptable
Congestion?YesLow-effort placement
Modify settings and/or std cell placement constraints
Modify macro/pad/port placement, core size, power gridNoPre-exploration 
Settings and Checks
Acceptable
Timing?
YesNoModify the floorplan, or
Re-synthesize the design
Logic optimizationRead DEF
Re-
synthesis
Floorplan exploration is recommended for designs 
that were floor-planned using a 3rd party toolWrite out Floorplan files

Design Planning
IC Compiler 12-87© 200987 2-Overview: Floorplan Exploration
Synthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
Acceptable
Congestion?Yesplace_opt –effort low
•If set_pnet_options is –complete, change to -partial
•Modify/add std cell placement constraints (see notes below)
•place_opt –effort low –congestionNoApply pre-exploration 
Settings and Checks
(see notes below)
If congestion is still not acceptable:
•Modify macro/pad/port placement, core size, power grid Acceptable
Timing?
YesNo2) If timing is still not 
acceptable after psynopt:
•Modify the floorplan, or
•Re-synthesize the design
1) psynoptopen_mw_cel DESIGN_data_setup
read_def FLOORPLAN.def
Re-
synthesisNote: Timing is “acceptable”
if violations are not larger 
than 15%-20% of the 
required path delay
Write out Floorplan files (DEF and TCL)
“Pre-exploration settings and checks” includes the following commands as applicable (shown with 
specific arguments only as an example):
link
set_pnet_options -partial  | -complete {metal2 metal3}
set_ignored_layers –max_routing_layer m7
check_physical_design –for_placement
check_physical_constraints
“Modify/add physical constraints” includes the following commands as applicable:
set physopt_hard_keepout_distance 10
set placer_soft_keepout_channel_width 25
set_keepout_margin -type hard -outer {10 0 10 0} RAM5
set_congestion_options -max_util 0.4 -coordinate {x1 y1 x2 y2}
create_placement_blockage –name LL_CORNER -type hard –no_snap \
-coordinate {{345.540 355.790} {392.280 400.070}}
“Write out Floorplan files” includes the following commands:
write_floorplan -row -track -create_terminal \
–preroute -placement {io hard_macro} DESIGN.fp
write_def –version 5.6 -macro –fixed –blockage \
-routed_nets –specialnets –output DESIGN.def
close_mw_cel

Design Planning
IC Compiler 12-88© 200988 2-Load the Floorplan Definition (DEF) File
Floorplan
Exploration
Acceptable
Congestion?place_opt –effort lowApply pre-exploration 
Settings and Checks
(see notes below)open_mw_cel DESIGN_data_setup
read_def FLOORPLAN.def/square6Perform synthesis with DC-
Topographical
/square6Perform Data Setup in IC 
Compiler with the netlist
from synthesis
/square6Perform design planning with 
a 3rdparty tool
/circle6Write out the floorplan
d
efinition ( DEF) file 
/square6Open the starting cell and 
load the DEF file
/circle6The graphical view is updated 
t
o reflect the floorplanSynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
“DEF” stands for “Design Exchange Format”, which is an industry standard format used to 
describe the floorplan of a physical design (or layout).
Starting with software version 2008.09 the read_def command will read in all DEF data, 
including “physical-only” data (cells, nets or ports that exist in the DEF file but not in the netlist, 
for example corner or filler cells, power pre-routes). 
Prior to 2008.09 the –allow_physical option is required to read in physical-only data as well.

Design Planning
IC Compiler 12-89© 200989 2-Pre-exploration Settings and Checks
Floorplan
Exploration
Acceptable
Congestion?place_opt –effort lowlink
set_pnet_options –partial|complete {M2 M3}
set_ignored_layers –max_routing_layer M7
check_physical_design –for_placement
check_physical_constraintsopen_mw_cel DESIGN_data_setup
read_def FLOORPLAN.def/square6Link the design
/circle6Verifies that any new 
c
ells included in DEF
can be resolved
/square6Define the maximum 
routing layer and 
apply pnet options, 
as needed
/circle6See 2-16 and 2-65
/square6P
erform two checks 
before placement
/circle6Modify the floorplan
t
o correct problems 
(see next slide)Synthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)

Design Planning
IC Compiler 12-90© 200990 2-Check Placement Readiness
checks 
the readiness for placement of:
/circle6Floorplan
/circle6Netlist
/circle6Design constraints
r
eports:
/circle6Cells placed in “hard placement blockage” areas
/circle6Metal layer inconsistencies against the library
/circle6R/Cs for routing layers
/circle6Narrow placement regions (“chimneys”)
/circle6Legal sites for cell placement
/circle6Large RC variations between metal layers
Modify the floorplan, constraints or libraries as neededcheck_physical_constraintscheck_physical_design –stage pre_place_opt

Design Planning
IC Compiler 12-91© 200991 2-Perform Low-effort Placement Optimization
Floorplan
Exploration
Acceptable
Congestion?place_opt –effort lowApply pre-exploration 
Settings and Checks
(see notes below)open_mw_cel DESIGN_data_setup
read_def FLOORPLAN.defplace_opt –effort low
/square6P erforms concurrent 
timing- and congestion-
driven placement and 
logic optimization
/square6The low effort minimizes 
logic optimization runtime
/circle6Ideal for “exploration”
p
urposesSynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)

Design Planning
IC Compiler 12-92© 200992 2-Check and Fix Congestion
Floorplan ExplorationAcceptable
Congestion?place_opt –effort low
•If set_pnet_options is –complete, change to -partial
•Modify/add std cell placement constraints (see notes below)
•place_opt –effort low –congestionNoApply pre-exploration 
Settings and Checks
(see notes below)
If congestion is still not acceptable:
•Modify macro/pad/port placement, core size, power grid open_mw_cel DESIGN_data_setup
read_def FLOORPLAN.defSynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)If the design is congested:
/square6Modify pnet options
See 2-70
/square6Modify/add standard cell
placement constraints
(e.g. blockage,  utilization %)
See 2-24 through 2-26 and 2-41 though 2-44
/square6Perform place_opt with 
additional congestion-driven 
algorithms
“Modify/add physical constraints” includes the following commands as applicable (shown with 
specific arguments only as an example – see Unit 2):
set physopt_hard_keepout_distance 10
set placer_soft_keepout_channel_width 25
set_keepout_margin -type hard -outer {10 0 10 0} RAM5
set_congestion_options -max_util 0.4 -coordinate {x1 y1 x2 y2}
create_placement_blockage –name LL_CORNER -type hard –no_snap \
-coordinate {{345.540 355.790} {392.280 400.070}}

Design Planning
IC Compiler 12-93© 200993 2-Modify the Floorplan
Floorplan ExplorationAcceptable
Congestion?place_opt –effort low
•If set_pnet_options is –complete, change to -partial
•Modify/add std cell placement constraints (see notes below)
•place_opt –effort low –congestionNoApply pre-exploration 
Settings and Checks
(see notes below)
If congestion is still not acceptable:
•Modify macro/pad/port placement, core size, power grid open_mw_cel DESIGN_data_setup
read_def FLOORPLAN.defIf the design is still congested 
you will need to modify the 
floorplan:
/square6Macro placement
/square6Pad/port placement
/square6Core size or shape
/square6Power grid structure
Load the original cell 
from Data Setup 
before loading the 
new DEF fileSynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
Since DEF information can be “cumulatively” applied to a design, you should discard the 
floorplanned design and reload the original cell from Data Setup before loading the new DEF 
information.

Design Planning
IC Compiler 12-94© 200994 2-Analyze and Fix Timing
Acceptable
Congestion?Yesplace_opt –effort lowApply pre-exploration 
Settings and Checks
(see notes below)
Acceptable
Timing?No2) If timing is still not 
acceptable after psynopt:
•Modify the floorplan, or
•Re-synthesize the design
1) psynoptRead DEF
Note: Timing is “acceptable”
if violations are not larger 
than 15%-20% of the 
required path delaySynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
By default psynopt performs incremental logic optimization to improve timing. 
If the design is re-synthesized, you will need to re-do Data Setup to create a new starting cell, 
before loading the floorplan.

Design Planning
IC Compiler 12-95© 200995 2-Write Out the Floorplan Files
Acceptable
Congestion?Yesplace_opt –effort lowApply pre-exploration 
Settings and Checks
(see notes below)
Acceptable
Timing?
YesNo2) If timing is still not 
acceptable after psynopt:
•Modify the floorplan, or
•Re-synthesize the design
1) psynoptRead DEF
Re-
synthesi
sOnce timing is OK, the floorplan is ready for re-synthesis 
and placement /barb2right/barb2right /barb2right/barb2rightWrite out the floorplan files as DEF and 
ICC physical constraints ( TCL)
write_floorplan -row -track -create_terminal \
–preroute -placement {io hard_macro} DESIGN.fp
write_def –version 5.6 -macro –fixed –blockage \
-routed_nets –specialnets –output DESIGN.def
close_mw_celSynthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)

Design Planning
IC Compiler 12-96© 200996 2-Summary: Floorplan Exploration
Synthesis (DC-T)
Design Planning (3rd party) 
Data Setup (ICC)
Acceptable
Congestion?Yesplace_opt –effort low
•If set_pnet_options is –complete, change to -partial
•Modify/add std cell placement constraints (see notes below)
•place_opt –effort low –congestionNoApply pre-exploration 
Settings and Checks
(see notes below)
If congestion is still not acceptable:
•Modify macro/pad/port placement, core size, power grid Acceptable
Timing?
YesNo2) If timing is still not 
acceptable after psynopt:
•Modify the floorplan, or
•Re-synthesize the design
1) psynoptopen_mw_cel DESIGN_data_setup
read_def FLOORPLAN.def
Re-
synthesisNote: Timing is “acceptable”
if violations are not larger 
than 15%-20% of the 
required path delay
Write out Floorplan files (DEF and TCL)
“Pre-exploration settings and checks” includes the following commands as applicable (shown with 
specific arguments only as an example):
link
set_pnet_options -partial  | -complete {metal2 metal3}
set_ignored_layers –max_routing_layer m7
check_physical_design –for_placement
check_physical_constraints
“Modify/add physical constraints” includes the following commands as applicable:
set physopt_hard_keepout_distance 10
set placer_soft_keepout_channel_width 25
set_keepout_margin -type hard -outer {10 0 10 0} RAM5
set_congestion_options -max_util 0.4 -coordinate {x1 y1 x2 y2}
create_placement_blockage –name LL_CORNER -type hard –no_snap \
-coordinate {{345.540 355.790} {392.280 400.070}}
“Write out Floorplan files” includes the following commands:
write_floorplan -row -track -create_terminal \
–preroute -placement {io hard_macro} DESIGN.fp
write_def –version 5.6 -macro –fixed –blockage \
-routed_nets –specialnets –output DESIGN.def
close_mw_cel

Design Planning
IC Compiler 12-97© 200997 2-Re-Synthesis
Floorplan ExplorationDesign Planning
(3rdparty tool)Summary: 3rdParty Design Planning Flow
Floorplan
(DEF)
Floorplan
Exploration
(ICC)
Placement
(ICC)Initial netlist
(ddc)
Physical (floorplan) 
constraints
(TCL)2ndpass 
netlist (ddc)
Data Setup
(ICC)
Starting cell
(Milkyway)Synthesis using 
default floorplan
(DC-T)Synthesis using 
ICC floorplan
(DC-T)
Data Setup
(ICC)
Floorplanned cell
(Milkyway)Load floorplan
(ICC)Starting cell
(Milkyway)
Floorplan
(DEF)

Design Planning
IC Compiler 12-98© 2009This page was intentionally left blank

Placement 
IC Compiler 1 3-1© 2009 13-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 Placement 3
DAY 
2
Clock Tree Synthesis 4

Placement 
IC Compiler 1 3-2© 2009 23-Unit Objectives 
After completing this unit, you should be able to: 
/square6Apply placement, DFT and power optimization 
settings before placement 
/square6Perform placement and optimization 
/square6Analyze congestion maps and reports 
/square6Perform incremental congestion and timing 
optimization 
/square6Perform additional placement techniques which 
allow more user-control 

Placement 
IC Compiler 1 3-3© 2009 33-General IC Compiler Flow 
Synthesis 
Data Setup 
Design Planning 
Placement 
Clock Tree Synthesis 
Routing 
Chip Finishing /checkbld/checkbld /checkbld/checkbld
This Unit /checkbld/checkbld /checkbld/checkbld

Placement 
IC Compiler 1 3-4© 2009 43-Design Status Prior to Placement 
/square6Synthesis is completed 
/circle6Second-pass netlist is generated 
/square6Data Setup is completed 
/circle6“Starting cell” is generated based on 2 nd pass netlist 
/square6Design Planning is completed 
/circle6“Floorplan Exploration” done if using 3 rd party floorplanning 
tool (Refer to “Design Planning” Unit 2) 
/square6“Floorplanned cell” is generated – ready for placemen t 
/circle6Based on 2 nd pass synthesis netlist and verified floorplan 

Placement
IC Compiler 13-5© 2009


Placement 
IC Compiler 1 3-6© 2009 63-Placement Setup and Checks 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup and 
Checks Design Planning 
CTS 

Placement 
IC Compiler 1 3-7© 2009 73-“Fix” all Macro Cell Placements 
/square6In most situations macro cell placement is determin ed 
during design planning and their placement is “fixe d”
/square6It is a good practice to fix all macro placements a gain, 
just in case….
/circle6You may have manually moved a macro after design pl anning 
and have forgotten to fix its placement 
open_mw_cel DESIGN_floorplanned 
link 
set_dont_touch_placement [all_macro_cells] 
EM = Electro-migration 

Placement 
IC Compiler 1 3-8© 2009 83-Verify pnet Options and Ignored Layers 
/square6Ensure that ignored routing layers are defined 
(if applicable) 
/square6Ensure that the appropriate pnet options are applied 
/square6The above settings should have been applied during 
design planning 
/circle6Must be explicitly re-applied after loading the flo orplan 
/square6If missing or incorrect – re-apply (see notes below)report_pnet_options report_ignored_layers 
# Remove and re-apply ignored layers 
remove_ignored_layers –all 
set_ignored_layers –max_routing_layer M7 
# Remove blockages 
remove_pnet_options OR 
set_pnet_options -none {M6 M7} 
# Modify blockage options 
set_pnet_options -complete {M2 M3} 
remove_pnet_options 
set_pnet_options –partial {M2 M3} 

Placement 
IC Compiler 1 3-9© 2009 93-Verify Keepout Variable Settings (if used) 
/square6Any placement keepout variable settings required 
during design planning must be maintained for 
placement, CTS and routing 
/square6Check the keepout variable settings: 
/square6If not correct: 
/circle6Apply the correct values for this session 
/circle6Add the variables to the .synopsys_dc.setup file for 
subsequent sessions 
set physopt_hard_keepout_distance <#> 
set placer_soft_keepout_channel_width <#> printvar physopt_hard_keepout_distance 
printvar placer_soft_keepout_channel_width 

Placement 
IC Compiler 1 3-10 © 2009 10 3-Non-Default Clock Routing 
/square6IC Compiler can route clock nets using non-default 
routing (NDR) rules, e.g. double-spacing, double-
width, shielding 
/square6Non-default rules are often used to “harden” the 
clock, e.g. to make the clock routes less sensitive  
to cross-talk or electro-migration (EM) effects 
/square6RC parasitics are different for NDR nets versus 
default routing nets /barb2right/barb2right /barb2right/barb2rightAffects timing 
/square6This timing difference can and should be taken into  
account before actual routing, during placement 
Default Routing Rule Effect of NDR route on Clk Sig1 
Clk 
Sig2 Sig1 
Clk 
Sig2 

Placement 
IC Compiler 1 3-11 © 2009 11 3-Specify Non-Default Routing Rules 
/square6Define the NDR rules: 
/square6Configure the clock tree routing: define_routing_rule MY_ROUTE_RULES  \
-widths {METAL3 0.4 METAL4 0.6 METAL5 0.6} \
-spacings {METAL3 0.5 METAL4 0.65 METAL5 0.65} 
set CLK_NETS [get_nets –of [all_fanout –flat –clock _tree]] 
set_net_routing_rule -rule MY_ROUTE_RULES $CLK_NETS
set_net_routing_layer_constraint -min_layer METAL3 \
-max_layer METAL5 $CLK_NETS 
You may also specify the 
layers to be used for clock 
tree routing 
You can report on the routing rules that were defined using  report_routing_rule. 
If, in the above example, layers are used for which a non-default routing rule  was not defined, 
these layers will use the default routing rules, as defined by the tec h-file. 
define_routing_rule  rule_name 
-reference_rule_name rule_name 
| -default_reference_rule 
[-widths {routing_layer_name value} ] 
[-snap_to_track] 
[-spacings {routing_layer_name value} ] 
[-shield_widths {routing_layer_name value} ] 
[-shield_spacings {routing_layer_name value} ] 
[-via_cuts {default_via_name value} ] 
[-taper_level tapering_level] 

Placement 
IC Compiler 1 3-12 © 2009 12 3-Check Placement Readiness 
checks 
the readiness for placement of: 
/circle6Floorplan 
/circle6Netlist 
/circle6Design constraints 
reports: 
/circle6Cells placed in “hard placement blockage” areas 
/circle6Metal layer inconsistencies against the library 
/circle6R/Cs for routing layers 
/circle6Narrow placement regions (“chimneys”)
/circle6Legal sites for cell placement 
/circle6Large RC variations between metal layers 
Modify the floorplan, constraints or libraries as n eeded check_physical_constraints check_physical_design –stage pre_place_opt 

Placement 
IC Compiler 1 3-13 © 2009 13 3-Summary: Placement Setup and Checks 
open_mw_cel DESIGN_floorplanned 
link 
set_dont_touch_placement [all_macro_cells] 
report_ignored_layers 
report_pnet_options 
printvar physopt_hard_keepout_distance 
printvar placer_soft_keepout_channel_width 
# Define non-default routing rules, if applicable 
define_routing_rule MY_ROUTE_RULES  \
-widths {METAL3 0.4 METAL4 0.6 METAL5 0.6} \
-spacings {METAL3 0.5 METAL4 0.65 METAL5 0.65} 
set CLK_NETS \
[get_nets –of [all_fanout –flat –clock_tree]] 
set_net_routing_rule -rule MY_ROUTE_RULES $CLK_NETS 
set_net_routing_layer_constraint -min_layer METAL3 \
-max_layer METAL5 $CLK_NETS 
check_physical_design –stage pre_place_opt 
check_physical_constraints Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS 

Placement 
IC Compiler 1 3-14 © 2009 14 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup and 
Checks Design Planning 
CTS Design-for-Test (DFT) Setup 
Skip this if your 
design does not 
include scan chains. 

Placement 
IC Compiler 1 3-15 © 2009 15 3-Pre-Existing Scan Chains 
/square6If your design flow includes “design-for-test”, the  
netlist will contain “scan chains”: 
/circle6Groups of “scan registers” that are serially connect ed 
through SI/SO pins, and inserted during synthesis 
/square6Scan chain paths are active only during “test mode” , 
not during “functional mode”
/square6Registers are typically connected in alphanumeric 
order during synthesis – irrelevant for DFT, but not  
optimal for routing IN[0] 
SCAN_IN OUT[0] SCAN_OUT 
B D
IN[1] OUT[1] E C AF

Placement 
IC Compiler 1 3-16 © 2009 16 3-The Issue with Existing Scan Chains 
What happens if placement is done with the 
pre-existing order of the scan chains? 
/square6Serially connected scan registers may be placed far  
apart which may require a lot more routing resource s IN[0] 
SCAN_IN OUT[0] SCAN_OUT 
B D
IN[1] OUT[1] E C AF
The timing-driven algorithm during placement focuses on eliminating se tup timing violations 
along functional paths. This means that timing-critical register pa irs are placed close together, 
independent of their “scan chain” connection, which may be very far. This gener ally produces 
non-optimal routing of the scan chain, which uses up more routing resources and increa ses 
congestion. The longer scan routes may also prevent testing from being done a t functional speed. 

Placement 
IC Compiler 1 3-17 © 2009 17 3-SCANDEF-Based Chain Reordering 
/square6IC Compiler can perform placement-aware reordering 
of scan cells 
/square6The scan chain information ( SCANDEF ) from synthesis 
can be transferred to IC Compiler in two ways: 
/circle6By loading the netlist in ddc format (imbedded SCANDEF )
/circle6By loading a SCANDEF file (generated after scan insertion) 
/square6Reordering occurs within each scan chain 
/square6Lockup latches or multiplexers break up scan chains  
further into “reordering buckets”
/square6If present, reordering happens within the buckets 
SI SO Reordering 
bucket 1 Reordering 
bucket 2 Reordering 
bucket 3 
Lockup 
Latch MUX 
SCANDEF captures the grouping and ordering of scan chains. 
During data setup, if the netlist from synthesis was read in as ddc , then the SCANDEF information 
is included and is automatically ported over to IC Compiler. If, on the other  hand, the netlist was 
read in as Verilog or VHDL, then an explicit SCANDEF file (ASCII) must be loaded prior to 
placement. This SCANDEF file is typically written out during synthesis , after scan insertion, with 
the command write_scan_def .

Placement 
IC Compiler 1 3-18 © 2009 18 3-Re-ordering Chains within Same “Partition”
/square6To extend flexibility, SCANDEF also supports 
reordering within partitions, across multiple bucke ts 
/square6A PARTITION is a group of “SCANDEF chains” that 
may exchange flip-flops during reordering 
PARTITION 1 PARTITION 2 SCANDEF 
Chain 1 SCANDEF 
Chain 2 SCANDEF 
Chain 3 
Lockup 
Latch MUX 
SI SO 
SCANDEF 
Chain 4 SCANDEF 
Chain 5 SCANDEF 
Chain 6 
Lockup 
Latch MUX 
SI SO 

Placement 
IC Compiler 1 3-19 © 2009 19 3-Example SCANDEF from Synthesis with DFT 
DESIGN my_design ; 
SCANCHAINS 2 ; 
- 1
+ START PIN test_si1 
+ FLOATING A ( IN SI ) ( OUT Q ) 
B ( IN SI ) ( OUT Q ) 
C ( IN SI ) ( OUT Q ) 
D ( IN SI ) ( OUT Q ) 
+ PARTITION CLK_45_45 
+ STOP PIN test_so1 
- 2
+ START PIN test_si2 
+ FLOATING E ( IN SI ) ( OUT Q ) 
F ( IN SI ) ( OUT Q ) 
G ( IN SI ) ( OUT Q ) 
H ( IN SI ) ( OUT Q ) 
+ PARTITION CLK_45_45 
+ STOP PIN test_so2 Design name 
Number of chain stubs in 
the design 
PARTITION keyword in SCANDEF. 
Flipflops can be swapped between two 
partitions with the same name “FLOATING ” indicates that these 
flipflops can be reordered 

Placement 
IC Compiler 1 3-20 © 2009 20 3-Example: Placement with Existing Ordering 
chain-order DC Netlist 
Scan Chain 1 ABCD 
Scan Chain 2 EFGH test_si1 
test_si2 test_so2 test_so1 A C G H
clk E B D F

Placement 
IC Compiler 1 3-21 © 2009 21 3-Example: Reordering Within Scan-Chains 
chain-order DC Netlist SCANDEF w/o 
PARTITION 
Scan Chain 1 ABCD ACBD 
Scan Chain 2 EFGH EGHF test_si1 
test_si2 test_so2 test_so1 A C G H
clk E B D F

Placement 
IC Compiler 1 3-22 © 2009 22 3-Partition_1            Partition_1                      Example: Reordering Within Partitions 
chain-order DC Netlist SCANDEF w/o 
PARTITION SCANDEF with 
PARTITION 
Scan Chain 1 ABCD ACBD ACGH 
Scan Chain 2 EFGH EGHF EBDF test_si1 
test_si2 test_so2 test_so1 A C G H
clk E B D F
check_scan_chain 
report_scan_chain 

Placement 
IC Compiler 1 3-23 © 2009 23 3-Placement-Based Scan Chain Re-Ordering 
Pre-existing Scan Ordering 
 Placement-Based Re-Ordering 
place_opt read_def DESIGN.scandef 
report_scan_chain 
place_opt –optimize_dft 
One of the modes available from the “Visual Mode”
is to display scan chains. It allows you to highlight 
each scan chain in a different color. 


Placement 
IC Compiler 1 3-24 © 2009 24 3-Better to use non-default 
vertical partitioning Consider Extreme Block Aspect Ratios 
Default horizontal partitioning 
Bad when block width >> height 
This creates more 
congestion in 
horizontal direction 
set_optimize_dft_options -partition vertical 
If not specified, the default partitioning direction is “horizontal”.

Placement 
IC Compiler 1 3-25 © 2009 25 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS Summary: DFT Setup 
DFT Setup 
# If the netlist loaded into ICC was NOT ddc :
read_def DESIGN.scandef 
report_scan_chain 
# If need to change the DFT partitioning direction 
set_optimize_dft_options -partition vertical 
place_opt –optimize_dft 
Skip these steps if your design does not include sc an chains. 
The place_opt command with the –optimize_dft option is not part of “DFT setup”. It is 
shown here to summarize all the DFT-related steps in the placement phase. 

Placement 
IC Compiler 1 3-26 © 2009 26 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup and 
Checks Design Planning 
CTS Power Setup 
Skip this if power 
optimization is not 
a priority 
Power optimization 
will generally: 
/circle6Not impact critical path 
delays or congestion 
/circle6Increase run time 

Placement 
IC Compiler 1 3-27 © 2009 27 3-Where Does Power Dissipation Occur? 
/square6Static or leakage power 
dissipation comes from: 
/circle6Current leakage though 
devices that are “OFF”
during static states 
/square6Dynamic or switching 
power dissipation comes 
from: 
/circle6Charging external loads 
/circle6Charging internal loads 
/circle6Short circuit or transient 
current while both devices 
are ON during a logic swing In Out Vdd 
Gnd Cload 
Cload P
NVdd 
Iextsw 
Ileak Ishrt Out 
Cint P
NIintsw Ishrt 
Ileak In 
Gnd Total Power = Static Power +Dynamic Power 
Dynamic power dissipation, also called switching power, can occur external  or internal to a 
standard cell: 
External switching power dissipation comes from current needed to continua lly charge 
external capacitive loads. 
Internal switching power dissipation comes from two sources: Current to charge  internal 
capacitive loads, and short circuit (or transient) current through the “ P” and “N” transistors, 
when both transistors are turned ON. This happens while their input voltage is in transi tion, 
in the range of 20-80% of VDD. During this transition time, the is a direct path (s hort) from 
VDD to VSS, through both transistors. This short circuit current is also referre d to as 
“transient” current. 
Static power dissipation, also called leakage power, comes from the fact t hat, even when voltage 
levels are stable (static, non-switching) at VSS or VDD, and the “N” or t he “P” device, 
respectively, is OFF, there is still a small amount of “leakage” cur rent passing through the “OFF”
transistor. 

Placement 
IC Compiler 1 3-28 © 2009 28 3-Leakage Power Optimization 
Trade Trade --Off Off 
High-Vth Cells 
Slow, Low Leakage Low-Vth Cells 
Fast, High Leakage /square6A multi-Vth library is the key 
to minimize leakage power 
/square6Low V th cells are used on 
critical paths to help timing 
/square6High V th cells are used on 
non-critical paths to save 
leakage power 
set target_library  “hvt.db svt.db lvt.db”
create_mw_lib  ... -mw_reference_library \
"mw/sc_hvt  mw/sc_svt  mw/sc_lvt  mw/io  mw/ram32“
set_power_options -leakage true|false 
Leakage power optimization is enabled by default with 
place_opt –power , or can be explicitly controlled with 
set_power_options –leakage true|false 
Note: IC Compiler can perform some leakage power optimization without a m ulti- Vth library 
(downsizing gates or buffer removal) but having a multi- Vth library allows much better power 
improvement. 
Some vendors include a nominal or medium V th library, sometimes called the “standard” Vth 
library ( svt.db in the example above). 
By default, the maximum allowed leakage is set to 0, in order to achieve best opt imization. 
Alternatively, you may set a higher leakage power goal before start ing the optimization, e.g. 
set_max_leakage_power 10 mW 
This may reduce optimization run-time. 
Prior to version 2007.12 it was recommended to explicitly enable a newer leakage  power 
optimization engine, referred to as “adaptive leakage optimization” ( ALO), by turning on this 
variable in addition to the commands above: set adaptive_leakage_opto true . 
Starting with 2007.12 ALO is always enabled. This variable no longer exists. I f using 2007.12 or 
later and you have an older script that includes this variable setting, remove it before execution. 

Placement 
IC Compiler 1 3-29 © 2009 29 3-Report Multi-Vth Cells 
icc_shell> report_threshold_voltage_group 
*************************************************** ********** 
Threshold Voltage Group Report 
Threshold Voltage Group      Number of Cells     Pe rcentage 
*************************************************** ********** 
LVt                                 90                8.33% 
HVt                                931               86.12% 
SVt                                 59                5.46% 
undefined                            1                0.09% 
*************************************************** ********** Report After placement you can generate a report summarizi ng 
how many of each type of cells were used 
These are typically macro or IP 
cells, which are not defined as 
low or high V th Note: This reporting requires special 
library attributes. See notes below. 
To be able to generate the above data, the library cells must be annotated with an appropriate 
attribute. If they are not annotated, you can do so with the following attrib utes: 
If high and low Vth cells are in separate libraries, use: 
default_threshold_voltage_group 
If high and low Vth cells are in the SAME library, use: 
threshold_voltage_group 
Example: 
set_attribute -type string lib1 default_threshold_v oltage_group HVt 
set_attribute -type string lib2 default_threshold_v oltage_group LVt 
set_attribute -type string lib3 default_threshold_v oltage_group SVt 
…
report_threshold_voltage_group 

Placement 
IC Compiler 1 3-30 © 2009 30 3-Reducing Dynamic Power Dissipation 
/square6Dynamic power optimization reduces power by 
identifying high “toggle rate” nets and: 
/circle6Reducing wire capacitance 
/circle6Downsizing gates 
/square6Two optimization techniques available during placem ent: 
/circle6Low power placement (LPP) 
/circle6Gate-level power optimization (GLPO) 
Cload P
NVdd 
Iextsw Ishrt Out 
Cint P
NIintsw Ishrt In 
Gnd 

Placement 
IC Compiler 1 3-31 © 2009 31 3-Switching Activity Terminology 
/square6Toggle Count (TC): 
A toggle is a logic transition (0 /barb2right1 or 1 /barb2right0). 
Toggle count ( TC ) is the number of toggles. 
/square6Toggle Rate (Tr): 
Number of toggles per unit time (usually the 
simulation duration) 
Tr = TC / duration 
/square6T1 , T0: 
Total time a signal is at logic 1, 0 
/square6Static Probability (Sp): 
Probability of a logic 1 for a signal 
Sp = T1 / duration 
Using the graph on the left, fill in the following: 
TC =      , Tr =      , T1=        , and SP= 0 ns 15 ns      30 ns 
TC = 3, Tr = 1/10, T1 = 20 ns, Sp = 0.667 

Placement 
IC Compiler 1 3-32 © 2009 32 3-SAIF File Provides Switching Activity 
(SAIFILE 
(SAIFVERSION "2.0") 
(DIRECTION "backward") 
(DESIGN ) 
(DATE "Mon May 17 02:33:48 2004") 
(VENDOR "Synopsys, Inc") 
(PROGRAM_NAME "VCS-Scirocco-MX Power 
Compiler") 
(VERSION "1.0") 
(DIVIDER / ) 
(TIMESCALE 1 ns) 
(DURATION 10000.00) 
(INSTANCE I_TOP 
(INSTANCE macinst 
(NET 
(z\[3\]
(T0 6488) (T1 3493) (TX 18) 
(TC 26) (IG 0) 
)        ... ... (z\[32\]
(T0 6488) (T1 3493) (TX 18) 
(TC 26) (IG 0) 
)
... ... 
)
(INSTANCE U3 
(PORT 
(Y 
(T0 4989) (T1 5005) (TX 6) 
(COND ((D1*!D0) | (!D1*D0)) 
(RISE) 
(IOPATH S (TC 22) (IG 0) 
)
COND ((D1*!D0) | (!D1*D0)) 
(FALL) 
(IOPATH S (TC 21) (IG 0) 
)
COND_DEFAULT (TC 0) (IG 0) 
) ... ... 
read_saif –input DESIGN.saif –instance_name I_TOP 
report_saif DESIGN.saif 
SAIF: Switching Activity Interchange Format 
SAIF files are generated by simulators. A SAIF file has header info rmation (in bold font above),  
and the body contains hierarchical switching activity information. 
SAIF is an open standard. The standard can be downloaded from : 
http://www.synopsys.com/tapin/ 
There is another switching activity format called VCD (IEEE st andard). Synopsys has a utility to 
convert VCD into SAIF. 

Placement
IC Compiler 13-33© 200933 3-What if SAIF is Not Available?
/square6Ensure properly defined clocks
/square6Use set _case_analysis for signals that do not toggle
/circle6E.g. reset, test_mode and scan_en signals
/square6Specify a toggle rate on propagation starting points :
/circle6Set any known toggles on primary inputs and black box out puts
/circle6Rest of the starting points will use the default toggle  rate
/square6IC Compiler will propagate the toggles throughout the  designcreate_clock –p 4 [get_ports clk]
set_case_analysis 0 [get_ports "rst se tm"]
set_switching_activity –toggle_rate 0.02 a
set_switching_activity -toggle_rate 0.06 b
set_switching_activity –toggle_rate 0.11 c
set power_default_toggle_rate 0.003
report_power
… …
Black Box
clkrsta
b
cx
source DESIGN_toggle_rate.tclDESIGN_toggle_rate.tcl

Placement 
IC Compiler 1 3-34 © 2009 34 3-Dynamic Power Optimization: LPP 
Low Power Placement (LPP): 
/square6Moves cells closer to shorten 
non-clock high-activity nets 
/circle6Clock tree LPP is done later, after 
place_opt , but pre-CTS 
/square6Must be enabled – OFF by default 
read_saif –input DESIGN.saif –instance_name I_TOP 
# If SAIF is not available: 
# source DESIGN_toggle_rate.tcl 
set_power_options -low_power_placement true 
report_power_options 
... 
place_opt –power Tr  = 0.3 
Tr  = 0.8 
Tr  = 0.3 
Tr  = 0.8 
In general LPP optimizes the placement of cells connected to high toggle r ate nets with the 
purpose of shortening these net lengths. The reduced parasitic capacitanc e reduces the dynamic 
power dissipation of these cells. 
Starting with version 2007.12-SP2 LPP is performed only non-clock cells during plac ement. 
Clock tree LPP will be performed after placement, and just before CTS clock_opt . 

Placement 
IC Compiler 1 3-35 © 2009 35 3-Dynamic Power Optimization: GLPO 
Gate-level power optimization (GLPO) optimizes 
logic to reduce power – must be enabled 
Cell Sizing Cell Sizing a
n2 bn1 
c
dfan2a 
an2a an2c Critical Path 
a
n2 b n1 
c
dfan2c 
an2a an2a Sized Up 
Sized Down 
Buffer Insertion Buffer Insertion n1 AFF1 
FFn ... 
clk n1 AFF1 
FFn ... 
clk n1 aFF1 
FFn ... 
clk n2 bn1 aFF1 
FFn ... 
clk n2 b
Phase Assignment Phase Assignment 12 : 1 
Mux 
6
area = 7 A
BTR = .7 
TR = .3 
area = 6 1
2 : 1 
Mux 
5 BA
TR = .7 
TR = .3 
Pin Swapping Pin Swapping f
Cpin = 1.5C 1Cpin = C 1
Toggle Rate = .4 
Toggle Rate = .8 bba
c
df
Cpin = 1.5C 1Cpin = C 1
Toggle Rate = .8 
Toggle Rate =.4 d
b
c
a
set_power_options -low_power_placement true 
place_opt –power 
... 
set_power_options -dynamic true 
psynopt –power 
*Note: GLPO can also be invoked concurrently with LPP during place_opt 
*While it is possible to concurrently perform GLPO, LPP and leakage power optim ization during 
place_opt , similar results may be obtained if GLPO is performed separately, afte r 
place_opt , during psynopt , with possibly reduced overall runtime. 
GLPO techniques: 
Buffer Insertion : Insert buffers to reduce capacitive load and sharpen input transition tim e 
Sizing : Lower capacitance on high activity nets, sharpen transition times to re duce internal power 
Pin Swapping : Connect high toggle-rate nets to low capacitance pins 
Phase Assignment : Use phase inversion to remove high toggle-rate inverters 
Technology Mapping : Hide high toggle-rate nets inside cells (not shown above) 
Factoring : Reduce the circuit’s switching activity (not shown above) 
The maximum leakage and dynamic power constraints are set to 0, by default,  t o enable 
maximum power optimization. Alternatively, you may set higher maximum l eakage and/or 
dynamic power goals before starting the optimization. This may help to reduce run-time: 
set_max_leakage_power 10 uW 
set_max_dynamic_power 500 mW 

Placement 
IC Compiler 1 3-36 © 2009 36 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS Summary: Power Optimization Flow 
read_saif –input DESIGN.saif –instance_name I_TOP 
# If SAIF is not available: 
# source DESIGN_toggle_rate.tcl 
set_power_options -leakage true 
-low_power_placement true 
report_power_options 
report_saif 
place_opt –power ... 
report_power 
... 
set_power_options -dynamic true 
psynopt –power ... 
report_power set target_library  “hvt.db svt.db lvt.db”
create_mw_lib ... -mw_reference_library \
“mw/sc_hvt  mw/sc_svt  mw/sc_lvt  mw/io  mw/ram32”
GLPO is executed 
concurrently with 
leakage power 
optimization and LPP Leakage power 
optimization and LPP 
are executed 
concurrently Multi-Vth libraries 
specified during 
Data Setup Data Setup 
Skip these steps if power optimization is not a pri ority. 

Placement 
IC Compiler 1 3-37 © 2009 37 3-Test For Understanding 
1. NDR rules define non-default rules for routing . Why 
apply these before placement ?
2. The SCANDEF file contains the scan ordering 
information which will be maintained during placeme nt 
with place_opt –optimize_dft .    True or False ?
3. Leakage power optimization is enabled by default wi th 
place_opt –power , and is more effective with 
multiple V th libraries. True or False ?
4. Low Power Placement (LPP) 
a. Moves cells to shorten high-activity nets 
b. Spreads out high activity cells to reduce power den sity 
c. Is enabled with set_power_options -dynamic true 
d. All of the above 
5. SAIF is preferred over user-defined toggle rates fo r 
accurate leakage power optimization. True or False ?1. Even though no actual routing occurs during placement, interconnect parasitic s and delays are 
calculated to determine path timing, and NDR rules affect timing, whi ch should be taken into 
account during the placement phase. 
2. False . place_opt –optimize_dft uses SCANDEF to identify the “reordering buckets”
within which, and the “partitions” across which, it can re-order the scan cha ins to achieve 
optimal routing. 
3. True . 
4. A.
5. False . Toggle rates (SAIF or user-defined) are only used for dynamic power optimization. 

Placement 
IC Compiler 1 3-38 © 2009 38 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup and 
Checks Design Planning 
CTS Placement and Optimization 

Placement 
IC Compiler 1 3-39 © 2009 39 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS Overview: Placement and Optimization 
# Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 
If place_opt is first executed without –congestion , analyze congestion immediately after 
completion. If the design is congested, discard the previous result and execute a new 
place_opt with –congestion :
save_mw_cel –as DESIGN_preplace_setup 
place_opt –optimize_dft –power -area 
...      # Analyze results – if congested: 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
place_opt –optimize_dft –power -area -congestion 
Use -congestion only if congestion is known to be a serious issue prior to placement. This is 
the case if one of the following is true: 
1) During design planning using IC Compiler, the “high effort” congestion a lgorithm was used to 
reduce congestion: 
set_fp_placement_strategy -congestion_effort high 
create_fp_placement –congestion –timing 
2) During floorplan exploration, after design planning using a 3 rd party tool, -congestion was 
required to reduce congestion: 
place_opt –effort low –congestion 
3) Placement was first performed without –congestion, and the resulting desi gn was congested. 

Placement 
IC Compiler 1 3-40 © 2009 40 3-The Initial Placement and Optimization 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 
If place_opt is first executed without –congestion , analyze congestion immediately after 
completion. If the design is congested, discard the previous result and execute a new 
place_opt with –congestion :
save_mw_cel –as DESIGN_preplace_setup 
place_opt –optimize_dft –power -area 
...      # Analyze results – if congested: 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
place_opt –optimize_dft –power -area -congestion 
Use -congestion only if congestion is known to be a serious issue prior to placement. This is 
the case if one of the following is true: 
1) During design planning using IC Compiler, the “high effort” congestion a lgorithm was used to 
reduce congestion: 
set_fp_placement_strategy -congestion_effort high 
create_fp_placement –congestion –timing 
2) During floorplan exploration, after design planning using a 3 rd party tool, -congestion was 
required to reduce congestion: 
place_opt –effort low –congestion 
3) Placement was first performed without –congestion, and the resulting desi gn was congested. 

Placement 
IC Compiler 1 3-41 © 2009 41 3-Placement and Logic Optimization 
place_opt Performs timing- and congestion-
driven placement and logic optimization 
-area_recovery Enables buffer removal 
and cell down-sizing of 
non-critical paths 
-optimize_dft Performs scan chain re-ordering 
-power Invokes leakage and/or dynamic 
power optimization 
-congestion Invokes additional congestion-
driven algorithms place_opt 
Coarse 
Placement 
AHFS 
Logic 
Optimization 
Placement 
Legalization 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Consider: 
- Using –area_recovery : Can help reduce congestion and power; May impact run time 
- Using –optimize_dft and –power only if DFT and power optimization are required, re sp. 
- Using –congestion only if congestion is known to be a serious issue (see next slide) 
To reduce run time IC Compiler can perform parallel processing during  coarse placement. Specify 
the number of free cpus with the option: –num_cpus <#> .

Placement
IC Compiler 13-42© 2009


Placement 
IC Compiler 1 3-43 © 2009 43 3-No Hold Time Fixing 
/square6By default place_opt tries to fix only setup time 
violations - No hold time fixing 
/square6Hold time will be addressed during clock tree 
synthesis 

Placement 
IC Compiler 1 3-44 © 2009 44 3-Post-Placement Analysis 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE If congestion and setup 
timing are acceptable you 
are ready for CTS! 

Placement 
IC Compiler 1 3-45 © 2009 45 3-Incremental Optimization 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 

Placement
IC Compiler 13-46© 2009


Placement 
IC Compiler 1 3-47 © 2009 47 3-Recall Problem: Sub-Critical Paths Ignored 
/square6By default, optimization within a path group stops if: 
/circle6IC Compiler becomes “stuck” on the critical path 
/circle6Sub-critical paths are not optimized! 
Delay 
Paths in same path group Constraint Goal Critical path is optimized as much as possible 
Sub-critical paths are NOT optimized 
What are some 
advantages of 
optimizing sub-
critical paths? 
ANSWER: 
If the sub-critical paths are intertwined with the critical path (they  share logic), it is possible that 
by improving one or more sub-critical nets this actually helps the criti cal path as well. 
Another advantage is that the design will end up with fewer violations, which ma y be easier to fix 
during CTS and/or routing. 

Placement 
IC Compiler 1 3-48 © 2009 48 3-# Ensure that the reg-reg paths get optimized 
group_path -name INPUTS -from [all_inputs] 
group_path -name OUTPUTS -to [all_outputs] 
group_path -name COMBO -from [all_inputs] -to [all_ outputs] Solution #1: User-defined Path Groups 
The critical path in 
COMBO is optimized The critical paths in CLK, 
INPUTS and OUTPUTS 
are also optimized 
delay 
Path groups: Constraint Goal 
COMBO CLK INPUTS OUTPUTS Near-critical CLK 
paths may still 
be ignored! 
The reg-to-reg paths remain in the CLK path group, which is created by defa ult by IC Compiler. 
The group_path command can be used for CLK to assign a non-default weight or critical range 
(to be discussed) to the group, but is not needed not to define the reg-to-reg paths. 
A path can only be in one path group, but according to the path group arguments, the com bo paths 
can be part of the INPUTS, OUTPUTS or COMBO group – so where are they? 
The COMBO paths wind up in the COMBO group.  Assuming the commands are executed in t he 
order listed in the slide, they are first moved from CLK to INPUTS, beca use they match the 
startpoint argument -from [all_inputs] .  They will not be moved to the OUTPUTS group, 
even though their endpoints match -to[all_outputs] , because “–from ” has priority over 
“-to ”. They finally end up in the COMBO group because their startpoints and endpoints match 
the –from AND  –to arguments.  IC Compiler works this way to prevent having different 
results if the command sequence changes! The results are independent of  the order of the 
commands above. 
Use report_path_group to get a summary of the path groups in the design. 

Placement 
IC Compiler 1 3-49 © 2009 49 3-Solution #2: Apply a Critical Range 
group_path –name CLK –critical 0.3 
0.3 ns 
/square6The critical range is always relative to the critical path delay 
/square6Fixing related sub-critical paths may help the crit ical path 
/square6Should not exceed 10% of the group’s effective cloc k period 
/circle6Will increase run time delay 
Path groups: Constraint Goal 
COMBO CLK INPUTS OUTPUTS All CLK paths within range 
are optimized, reducing the 
“total negative slack” (TNS) 
By default the critical range of all path groups is zero. 
Fixing related sub-critical paths may help the critical path. Since the critical range is with respect 
to the critical path delay, if the critical path delay is improved, the critical range band moves 
lower, along with the improved critical path. Critical range optimizati on will not improve a sub-
critical path if the improvements make the critical path worse. 
With a critical range, optimization will reduce TNS (Total Negative  Slack) in the design even if it 
cannot reduce the WNS (Worst Negative Slack). 
Alternatively you can apply one critical range value globally t o all path groups, for example: 
set_critical_range 0.5 [current_design] . While this approach is a little simpler 
to implement (you need to only decide on one critical range value), it may have a l arger impact on 
run-time. 
All paths within 0.5 ns of the 
WNS path will be optimized 
-1.2 -0.8 -0.4 0 0.4 100 200 300 400 500 
# Paths 
Slack 0.5 ns 

Placement 
IC Compiler 1 3-50 © 2009 50 3-Solution #3: Prioritizing Path Groups 
/square6All path groups have equal priority, by default 
/square6Applying a weight to a select group (e.g. CLK) allows 
delay improvements to its paths, which may degrade 
another, less critical group’s worst violator (e.g.  INPUTS) 
/square6Suggestion: 
/circle6Apply a weight of 5 to the most critical paths (reg -to-reg) 
/circle6Apply a weight of 2 to less critical paths 
/circle6A default weight of 1 is assigned to all other path s (e.g. 
over-constrained I/O paths) -0.4ns              -0.1ns 
D  Q D  Q CLK FFslw 
FF2 A
CLK 
333MHz Z
INPUT 
group_path –name CLK –weight 5 
It is possible to assign weights to different path groups by using the –weight option.  This is a 
way to control the relative priority of optimization. Priority is give n to the path with the highest 
“Cost” = Negative slack X Weight. For example: A path group with a crit ical violation of –2ns and 
a weight of 5 has a cost of 10 and will therefore have higher priority than another path group with 
a critical violation of –3ns but a default weight of only 1 - cost of 3. If these two paths are related 
such that improving one hurts the other, optimization will favor improving the hig her weight path, 
even though its slack is less than the lower weight path. 

Placement 
IC Compiler 1 3-51 © 2009 51 3-Example: -weight 
-0.4ns              -0.1ns 
D  Q D  Q CLK FFslw 
FF2 A
CLK 
333MHz Z
INPUT 
FFslw: T Setup     = 0.1ns 
TCLK /barb2right/barb2right /barb2right/barb2rightQ= 0.2ns -0.6ns               0.0ns 
D  Q D  Q CLK FFfst 
FF2 A
CLK 
333MHz Z
INPUT 
FFfst: T Setup     = 0.3ns 
TCLK /barb2right/barb2right /barb2right/barb2rightQ= 0.1ns Slack = group_path -name INPUTS -from [all_inputs] 
group_path -name OUTPUTS -to [all_outputs] 
group_path -name COMBO -from [all_inputs] -to [all_ outputs] 
group_path –name CLK –weight 5 
INPUTS weight = 1 
CLK   weight = 1 INPUTS weight = 1 
CLK   weight = 5 
The example above illustrates how it is possible that by adding a path gr oup, in this case INPUTS, 
the worst violating path in the design, the input path with a slack of -0.4ns, actually  gets worse (-
0.6ns), in favor of helping the higher priority reg-to-reg path. This happened bec ause this design 
change reduced the overall cost function. The cost function for the cir cuit on the left is [(0.4 x 1) + 
(0.1 x 5)] = 0.9. For the circuit on the right the cost function is 0.6. Optimization was abl e to 
improve the reg-to-reg setup timing path by switching to a register with a faster CLK /barb2rightQ delay 
(FFslw /barb2rightFFfst) , while giving up some setup time. 
Without the –weight option applied to the CLK group both paths have a default weight of 1 and 
optimization will not consider this flip-flop swap, because that would increase the overall cost 
from 0.5 [(0.4 x 1) + (0.1 x 1)]  to  0.6 [(0.6 x 1) + (0 x 1)]. 

Placement 
IC Compiler 1 3-52 © 2009 52 3-# Example: Assign a critical range and weight to cl ock groups 
group_path -name CLK1 -critical_range 0.3 –weight 5
group_path -name CLK2 -critical_range 0.1 –weight 5
group_path –name CLK3 –critical_range 0.2 –weight 5
group_path –name INPUTS –from [all_inputs] 
group_path –name OUTPUTS –to [all_outputs] 
group_path –name COMBO –from [all_inputs] –to [all_ outputs] 
report_path_group Complete Example 

Placement 
IC Compiler 1 3-53 © 2009 53 3-Incremental Logic Optimization: psynopt 
/square6After modifying placement and path group parameters  
(as appropriate) execute psynopt :
/circle6Performs incremental timing-driven logic optimizati on 
/circle6Legalizes placement 
/square6Include -area_recovery 
/circle6May help reduce congestion and power – may impact ru n time 
/square6If power optimization is a priority include -power 
/circle6Enable GLPO dynamic power optimization (if not already 
enabled prior to place_opt –power )
/square6If the design is congested include –congestion 
set_power_options -dynamic true; # GLPO 
psynopt –area_recovery |–power| |–congestion| 

Placement 
IC Compiler 1 3-54 © 2009 54 3-Summary: Incremental Optimization 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 

Placement 
IC Compiler 1 3-55 © 2009 55 3-If the Design is Still Seriously Congested …
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 

Placement 
IC Compiler 1 3-56 © 2009 56 3-Enable Global Router During Optimization 
/square6Setting the variable below to TRUE enables 
congestion optimization using the actual global 
router (instead of a global route estimator )
/square6Most designs will show little change – some may 
show significant congestion improvement 
/square6All designs will see an increase in run time! 
/circle6Try this only if congestion is serious 
/circle6First discard results from previous place_opt 
/circle6Re-run place_opt with -congestion 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
set placer_enable_enhanced_router TRUE 
place_opt –area_recovery –congestion \
|–optimize_dft| |–power| 
By default, place_opt performs both placement and netlist synthesis (or logic optimization). At 
the start of place_opt any previous placement is discarded, but the starting netlist is kept and 
incrementally optimized. Better results may be obtained when allowing  logic optimization to start 
fresh on the original pre- place_opt netlist. It is a good practice to discard previous 
place_opt results and start from the original netlist when performing a subsequent 
place_opt .

Placement 
IC Compiler 1 3-57 © 2009 57 3-Summary: Placement and Optimization 
Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS # Discard previous results when executing a new pla ce_opt. 
# See notes below regarding the use of “-congestion ”.
save_mw_cel –as DESIGN_preplace_setup 
place_opt –area_recovery \
|–optimize_dft| |–power| |-congestion| 
Congestion or 
setup violation? No 
# If congested, add/modify placement blockage and c ell 
# density constraints, as needed. See Design Planni ng. 
create_placement_blockage ... ; # and/or others ... 
# If violating timing apply optimization “focus” as needed 
group_path -name CLK -critical_range <cr> –weight 5
# If power is a priority and GLPO was not already e nabled 
set_power_options -dynamic true 
# If congested use “–congestion”
psynopt –area_recovery |–power| |–congestion| Yes 
Serious congestion? No 
Yes 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
# Try enabling the global router. Increased run tim e! 
set placer_enable_enhanced_router TRUE 
If place_opt is first executed without –congestion , analyze congestion immediately after 
completion. If the design is congested, discard the previous result and execute a new 
place_opt with –congestion :
save_mw_cel –as DESIGN_preplace_setup 
place_opt –optimize_dft –power -area 
...      # Analyze results – if congested: 
close_mw_cel 
open_mw_cel DESIGN_preplace_setup 
place_opt –optimize_dft –power -area -congestion 
Use -congestion only if congestion is known to be a serious issue prior to placement. This is 
the case if one of the following is true: 
1) During design planning using IC Compiler, the “high effort” congestion a lgorithm was used to 
reduce congestion: 
set_fp_placement_strategy -congestion_effort high 
create_fp_placement –congestion –timing 
2) During floorplan exploration, after design planning using a 3 rd party tool, -congestion was 
required to reduce congestion: 
place_opt –effort low –congestion 
3) Placement was first performed without –congestion, and the resulting desi gn was congested. 

Placement 
IC Compiler 1 3-58 © 2009 58 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup and 
Checks Design Planning 
CTS Improving Congestion and Setup Timing 
If setup timing or 
congestion are still a 
problem there are 
additional 
optimizations that can 
be done 

Placement 
IC Compiler 1 3-59 © 2009 59 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS Overview: Improve Congestion/Timing 
No 
Yes 
save_mw_cel –as DESIGN_placed # Execute the following commands with varying 
# options, and in varying order, to try to obtain the 
# best congestion and/or setup timing results. 
# Use the guidelines listed in the notes below: 
refine_placement |–coordinate {X1 Y1 X2 Y2}| \
|–congestion_effort high|   \
|–perturbation_level <high|max>| 
psynopt |–power| |–area_recovery| |-congestion| 
psynopt –no_design_rule | –only_design_rule | -size _only save_mw_cel –as DESIGN_placed_temp 
Congestion or 
setup violation? 
1. Since refine_placement focuses on congestion optimization only it may degrade setup 
timing 
2. Sometimes better congestion results are obtained by discarding the previ ous result and 
reloading DESIGN_placed_temp before executing another refine_placement .
3. By default psynopt performs logic optimization, which tries to  improve setup timing. This 
may impact congestion. When used with –congestion it will also try to improve 
congestion. 
4. Use psynopt with –power , -congestion or –area as you feel is necessary. If timing 
is higher priority try omitting one or more of these options. 
5. Sometimes better timing is obtained by focusing or limiting psynopt with 
–no_design_rule , -only_design_rule or –size_only 
6. It is not necessary to discard previous results before executing a subsequent  psynopt 

Placement 
IC Compiler 1 3-60 © 2009 60 3-refine_placement 
/square6Optimizes placement incrementally to improve conges tion 
/circle6Does not modify the netlist /barb2rightTiming may degrade 
/square6Can be executed back-to-back with different options
/circle6Discarding previous placement may improve results 
/square6Can be followed with psynopt to improve timing 
TOP Incremental run can 
be applied to the 
entire design…
…or to a region using 
XY coordinates 
refine_placement  |–coordinate {X1 Y1 X2 Y2}| \
|–congestion_effort high| 
|–perturbation_level <high|max>|                 
refine_placement 
-coordinate {x1 y1 x2 y2} 
-congestion_effort low|medium |high 
-perturbation_level min|medium |high|max 
-ignore_scan (ignore scan chain connections during placement) 
-num_cpus  number_of_cpus 

Placement 
IC Compiler 1 3-61 © 2009 61 3-psynopt 
/square6Performs incremental timing-driven logic optimizati on 
with placement legalization (setup timing, by defau lt) 
/circle6With –congestion will try to maintain or improve congestion 
/square6Use –power , -congestion or –area as necessary 
/circle6If timing is higher priority try omitting one or mo re of these 
options 
/square6Sometimes better timing is obtained by focusing or 
limiting psynopt with   –no_design_rule , 
-only_design_rule or   –size_only 
/square6It is not necessary to discard previous results bef ore 
executing a subsequent psynopt 
psynopt |–power| |–area_recovery| |–congestion| 
psynopt –no_design_rule | –only_design_rule | -size _only 

Placement 
IC Compiler 1 3-62 © 2009 62 3-Placement and 
Optimization 
Improve 
Congestion/Timing Power Setup DFT Setup Placement Setup 
and Checks Design 
Planning 
CTS Summary: Improve Congestion/Setup Timing 
No 
Yes 
save_mw_cel –as DESIGN_placed # Execute the following commands with varying 
# options, and in varying order, to try to obtain t he 
# best congestion and/or timing results. 
# Use the guidelines listed in the notes below: 
refine_placement |–coordinate {X1 Y1 X2 Y2}| \
|–congestion_effort high|   \
|–perturbation_level <high|max>| 
psynopt |–power| |–area_recovery| |-congestion| 
psynopt –no_design_rule | –only_design_rule | -size _only save_mw_cel –as DESIGN_placed_temp 
Congestion or 
setup violation? 
1. Since refine_placement focuses on congestion optimization only it may degrade setup 
timing 
2. Sometimes better congestion results are obtained by discarding the previ ous result and 
reloading DESIGN_placed_temp before executing another refine_placement .
3. By default psynopt performs logic optimization, which tries to  improve setup timing. This 
may impact congestion. When used with –congestion it will also try to improve 
congestion. 
4. Use psynopt with –power , -congestion or –area as you feel is necessary. If timing 
is higher priority try omitting one or more of these options. 
5. Sometimes better timing is obtained by focusing or limiting psynopt with 
–no_design_rule , -only_design_rule or –size_only 
6. It is not necessary to discard previous results before executing a subsequent  psynopt 

Placement 
IC Compiler 1 3-63 © 2009 63 3-Test For Understanding (1 of 2) 
1. By default, place_opt will 
a. Optimize placement and logic for congestion 
b. Optimize placement and logic for setup timing 
c. Optimize logic for leakage power 
d. A and B 
e. A, B and C 
2. What is the benefit of having separate path groups for 
I/O logic paths? 
3. What does applying a timing critical range do, and 
what is the benefit of this? 
4. Applying a weight  > 1 to a path group may increase a 
design’s critical path delay.   True or False ?1. D. While the parameter set_power_options –leakage is true by default, –power 
must be used to invoke leakage power optimization. 
2. By putting input and output logic paths in their own path groups, all the register-t o-register 
paths remain in their original respective clock groups. The benefit of this i s that, if the WNS 
path is an I/O path and optimization is unable to further improve its delay, the c ritical reg-to-
reg path within each clock group, which may have a smaller violation than the WNS  path, will 
still be optimized. Without the I/O path groups, these reg-to-reg violations may  be totally 
ignored. 
3. Applying a timing critical range allows near-critical paths to be  optimized. These paths may 
otherwise have been ignored if the critical path delay gets “stuck” and ca n’t be optimized 
further. The benefit of optimizing near-critical paths is that you end up with fewer and/or 
smaller violations. Also, if the paths are “related”, fixing a near-c ritical path may also improve 
the critical path delay. 
4. True. The goal of timing optimization is reduce the total negative slack (TNS)  as much as 
possible. TNS is the sum of all “weighted” negative slacks. Every violation i s weighted by its 
path group weight, default of 1. In a group with a weight of 5 for example, a 0.1ns pa th delay 
improvement reduces TNS by 5 x 0.1 = 0.5ns. If this change increases the critic al path delay 
by 0.3ns, and the critical path happens to be in another path group with a default we ight of 1 
(increasing TNS by 0.3), the overall TNS is still reduced by 0.2ns (0.5-0.3), so I C Compiler 
considers this an acceptable trade-off. 

Placement 
IC Compiler 1 3-64 © 2009 64 3-Test For Understanding (2 of 2) 
5. refine_placement performs incremental 
a. Timing-driven placement 
b. Congestion-driven placement 
c. Congestion-driven logic optimization 
d. A and B 
e. A, B and C 
6. By default, psynopt performs incremental 
a. Timing-driven logic optimization 
b. Congestion-driven placement 
c. Congestion-driven logic optimization 
d. A and B 
e. A, B and C 5. B.
6. A. In terms of placement, only placement legalization is performed, by default. C ongestion-
driven logic optimization is invoked with the –congestion option. 

Placement 
IC Compiler 1 3-65 © 2009 65 3-Techniques with More User Control 
Buffer trees 
Relative placement 

Placement 
IC Compiler 1 3-66 © 2009 66 3-Build User-Controlled Balanced Buffer Trees 
/square6AHFS  buffers high fanout nets with little user con trol 
/circle6All types of buffers may be used 
/circle6Buffer tree depth may be unbalanced, since only DRC  focused 
/square6After place_opt analyze the resulting buffer tree(s) 
/square6Remove unwanted buffer tree(s) 
/square6Re-create a balanced buffer tree with more user con trol: 
remove_buffer_tree -from <pins_or_nets> 
set_cbt_options -references <buffer_list> -threshol d <t> 
create_buffer_tree -from <pins_or_nets> 
cbt = create buffer tree 
The create_buffer_tree command applies to the specified pins or nets, independent of fanout 
(the AHFS fanout threshold is not considered). Its main goal is to build a buffer t ree with balanced 
buffer depth, that also meets DRC rules. Timing is not considered. A balanced buf fer tree may 
help to reduce skew, which may help timing. (See next slide for a more direct way  to optimize for 
skew). 
The set_cbt_options command can be used to define a sub-set of buffers to be used. The 
-threshold value can be used if “ -from <pins_or_nets> ” is not used. Only nets whose 
fanout exceeds this threshold are buffered. 
Get information about existing buffer trees with report_buffer_tree . Report cbt options with 
report_cbt_options .

Placement 
IC Compiler 1 3-67 © 2009 67 3-Build Skew-Optimized Buffer Trees 
/square6If skew minimization is important for certain non-
clock high fanout nets, use compile_clock_tree 
/square6Must define the pins or nets as “ideal networks”
prior to place_opt 
/square6Additional commands available to exert more user 
control (see notes below) 
set_ideal_network –no_propagate [get_nets Reset] 
place_opt 
compile_clock_tree –high_fanout_net [get_nets Reset ] 
The user can exert additional control by applying the set_clock_tree_options and 
set_clock_tree_references commands before compile_clock_tree (These 
commands are discussed in the CTS unit; Also see the man pages for more details). 
The compile_clock_tree command ignores “ideal networks”, therefore the ideal network 
does not need to be removed prior to building the buffer tree. 

Placement 
IC Compiler 1 3-68 © 2009 68 3-Relative Placement 
Buffer trees 
Relative placement 

Placement 
IC Compiler 1 3-69 © 2009 69 3-What’s Special about Data Path Logic? 
/square6Bit-wise data operations are 
performed in parallel on each bit 
of a bus 
/circle6Each operation corresponds to a 
dedicated function, e.g. adder , 
multiplier , register , multiplexer , etc 
/square6Two groups of signal flows: 
/circle6Data flow: data-in to data-out 
/circle6Control flow: 
/rhombus6Global: clock , select, enable 
/rhombus6Local: carry-in, carry-out REG X[15:0] 
REG 
SHIFT MUX 
ALU Y[15:0] 
Z[15:0] 
Example data path 
functional module SEL CLK 

Placement 
IC Compiler 1 3-70 © 2009 70 3-The Ideal Layout for Data Path 
/square6Best placed in a bit-sliced structure, for example:
/circle6Cells operating on one bit are placed in one row, a butted next 
to each other horizontally 
/circle6This row is repeated and abutted vertically for eac h bit 
/square6Benefits of this placement structure: 
/circle6Overall placement area of data path cells is minimi zed 
/circle6Control and data signals can be routed vertically a nd 
horizontally, respectively 
/rhombus6Minimizes routing 
congestion 
/rhombus6Minimizes interconnect 
parasitic RCs 
– Reduced delay 
– Reduced power 
/rhombus6Minimizes clock 
and data skew REG MUX ALU REG SHIFT 
Y[0] 
X[0] 
Y[1] 
X[1] 
Y[2] 
X[2] 
Y[3] 
X[3] 
Y[15] 
X[15] …………………………………… .Z[0] 
Z[1] 
Z[2] 
Z[3] 
Z[15] 
SEL CARRY BIT 
Control signals CLK 

Placement 
IC Compiler 1 3-71 © 2009 71 3-Data Path Layout using Traditional P&R Tool 
Traditional layout tools can not take advantage of the 
regular bit-sliced structure, resulting in: 
/circle6Larger placement area and routing congestion 
/circle6Larger delays, skews and power consumption 
BIT 14 BIT 15 
BIT 0 
BIT 1 BIT 2 BIT 3 
BIT 4 BIT 5 
BIT 6 BIT 7 
BIT 8 BIT 9 
BIT 10 
BIT 11 BIT 12 
BIT 13 
Example “traditional” layout with carry-signal connectio ns highlighted 

Placement 
IC Compiler 1 3-72 © 2009 72 3-Traditional Solution: Custom/Manual Layout 
/square6Traditionally one of these layout approaches is use d: 
/circle6Creation of a full-custom data path macro or “hard IP”
/circle6Manual placement of the data path cells in 
the standard cell core area 
/square6Downsides of manual/custom approaches: 
/circle6Very time-consuming - Increased design cycle 
/rhombus6Manual gate size selection 
/rhombus6Manual placement of hard IP or data path cells in the  core area 
/rhombus6Manual/limited logic optimization for timing, power,  area, DRCs 
/rhombus6Re-creation of hard IP and manual re-placement after logic change 
/circle6Increased delay, power and area due to limitation o f manual 
logic optimization DP 
In the full-custom approach, a custom layout tool is used to design the layout of t he data path 
logic. A “FRAM” view is generated for this harp IP which is then supplied to IC Compiler as part 
of a Milkyway IP reference library. The physical designer must t hen place this hard macro in the 
core placement area, along with any other macros, during the design planning  phase. The 
placement of this hard macro is then fixed. 
With manual placement the physical designer manually places each sta ndard cell of the data path 
logic in the core placement area, and then “fixes” the placement. The rem aining standard cells are 
placed around the fixed data path cells. 

Placement 
IC Compiler 1 3-73 © 2009 73 3-IC Compiler’s Solution: Relative Placement 
/square6Each data path functional module is defined once as  a 
relative placement (RP) group 
/square6Each cell of an RP group is assigned a row and column 
/circle6Also known as “tiling”
/circle6Done prior to placement through 
TCL constraints 
row-3
row-2
row-1
row-0col-0 col-2 col-3 col-4 col-1
U1 U1 U6 U6 U11 U11 U15 U15 
U0 U0 U5 U5 U10 U10 U14 U14 
U3 U3 U8 U8 U12 U12 U17 U17 
U4 U4 U9 U9 U13 U13 U18 U18 
U2 U2 U7 U7 U16 U16 
Example relative placement group 
of a data path functional module 
Free Placement 
Relative Placement 
“Relative placement” may also be referred to as “physical datapa th” in our literature and 
documentation. 

Placement
IC Compiler 13-74© 200974 3-Features and Benefits of Relative Placement
/square6RP groups are placed concurrently with standard cells
/circle6Relative placement is maintained through post-route
/square6R
P logic is optimized as needed during placement 
through post-routing phases
/circle6RP groups are re-sized to accommodate cell-sizing
/circle6Placement of RP groups in core is automatically adju sted
/square6Easy to use GUI (Graphical User Interface) for 
visualization and editing
/square6Improved congestion, skew, timing, power and area
/square6Increased design predictability
/square6Shorter design cycleFeatures
Benefits

Placement 
IC Compiler 1 3-75 © 2009 75 3-
Candidates for Relative Placement 
/square6The following functions are good candidates 
for taking advantage of Relative Placement 
/circle6Classic data path structured elements 
/circle6RAMs, FIFOs 
/circle6Clock structures 
/circle6Register banks 
/square6Some key design applications include 
/circle6Processors, DSPs 
/circle6Graphics 
/circle6IP providers 
Relative placement of RAMs with 
clock “pin alignment”
/barb2rightReduced clock skew and power 

Placement 
IC Compiler 1 3-76 © 2009 76 3-More Information on Relative Placement 
/circle6IC Compiler User Guide on SolvNet 
/circle6SNUG 2008 
Structured Methods for Delay, Power Tuning and Vari ation: A Case Study 
https://www.synopsys.com/news/pubs/snug/sanjose08/b inney_pres.pdf
/circle6SNUG 2007 
Efficient Physical DataPath Specification: Streamin g Relative Placement 
https://www.synopsys.com/news/pubs/snug/sanjose07/d unham_pres.pdf
Design of a 1GHz DSP using IC Compiler 
http://www.synopsys.com/news/pubs/snug/sanjose07/hi ll_pres.pdf 
/circle6Contact your local Synopsys Applications Consultant  for 
Relative Placement tutorial and labs 

Placement 
IC Compiler 1 3-77 © 2009 77 3-Summary 
You should now be able to: 
/square6Apply placement, DFT and power optimization 
settings before placement 
/square6Perform placement and optimization 
/square6Analyze congestion maps and reports 
/square6Perform incremental congestion and timing 
optimization 
/square6Perform additional placement techniques which 
allow more user-control 

Placement 
IC Compiler 1 3-78 © 2009 78 3-Lab 3: Placement 
70 minutes 
Perform standard cell placement 
and optimization with the goal 
of meeting the timing targets 
and eliminating congestion. 
Setup for placement 
and timing optimization 
Standard cell placement 
Analyze congestion, 
timing and power 
Incremental placement Setup for DFT and 
power optimization 

Clock Tree Synthesis 
IC Compiler 1 4-1© 2009 
14-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 DAY 
22 22
Placement 3
Clock Tree Synthesis 4

Clock Tree Synthesis 
IC Compiler 1 4-2© 2009 
24-Unit Objectives 
After completing this unit, you should be able to: 
/square6List the status of the design prior to CTS 
/square6Set up the design for clock tree synthesis 
/square6Identify implicit clock tree start/end points and 
when explicit modifications are needed 
/square6Control the constraints and targets used by CTS 
/square6Execute the recommended clock tree synthesis 
and optimization flow 
/square6Analyze timing and clock specifications 
post CTS 

Clock Tree Synthesis 
IC Compiler 1 4-3© 2009 
34-IC Compiler Flow 
Synthesis 
Unit 1 
Unit 3 
Unit 4 
Unit 6 
Unit 7 Unit 2 Design Setup 
Design Planning 
place_opt 
clock_opt 
route_opt 
Chip Finishing /checkbld/checkbld /checkbld/checkbld
/handptright/handptright /handptright/handptright/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Clock Tree Synthesis 
IC Compiler 1 4-4© 2009 
44-Design Status, Start of CTS Phase 
/square6Placement - completed 
/square6Power and ground nets – prerouted 
/square6Estimated congestion – acceptable 
/square6Estimated timing – acceptable (~0ns slack) 
/square6Estimated max cap/transition – no violations 
/square6High fanout nets: 
/circle6Reset, Scan Enable synthesized with buffers 
/circle6Clocks are still not buffered 
Why are there no buffers on clock nets? 
Congestion, timing and max cap/transition are estimated based on virtua l route. 
Answer: 
There are no clock buffers because synthesis designers are asked not to build the  clock tree during 
synthesis. 
CTS is the process of distributing clock signals to clock pins based on physica l/layout information. 
HFN synthesis is used to balance the load but it is not good at balancing skew . 

Clock Tree Synthesis 
IC Compiler 1 4-5© 2009 
54-Is the Design Ready for CTS? 
/square6check_physical_design –stage pre_clock_opt 
checks for: 
/circle6Designs is placed 
/circle6Clocks have been defined 
/circle6Clock roots are not hierarchical pins (see below fo r support) 
/square6check_clock_tree checks and warns if: 
/circle6A clock source pin is a hierarchical pin (see below for support) 
/circle6A generated-clock with improperly specified master- clock 
/circle6A clock tree has no synchronous pins 
/circle6There are multiple clocks per register 
/square6To enable support for clock source on hierarchical pins: 
set cts_enable_clock_at_hierarchical_pin true 
check_clock_tree also checks and warns if: 
* a master-clock does not propagate to a generated-clock source pin 
* a generated-clock with improperly specified master-clock 
* there is a master-clock that terminates at a pin without a correspondin g generated-clock for a 
* generated-clock 
* a clock loops to its source 
* there are cascaded clocks 
* a clock-tree path has ignored exceptions 
Make sure clocks are properly setup prior to CTS is very important. This topic  is covered in IC 
Compiler 2: CTS workshop. 
Before using the command create_clock or set_clock_tree_exceptions to specify 
clock sources or clock tree exceptions on hierarchical pins: 
set cts_enable_clock_at_hierarchical_pin true. The default 
setting of this variable is false. 

Clock Tree Synthesis 
IC Compiler 1 4-6© 2009 
64-Starting Point before CTS 
FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF Clock 
All clock pins are driven by a single clock source.

Clock Tree Synthesis 
IC Compiler 1 4-7© 2009 
74-Clock Tree Synthesis 
clock_opt 
Physical 
Constraints Control 
DRC 
max tran/cap/fanout 
Exceptions 
Analysis report_clock_tree 
report_clock_timing 
report_timing 

Clock Tree Synthesis 
IC Compiler 1 4-8© 2009 
84-CTS Goals 
/square6Meet the clock tree Design Rule Constraints (DRC): 
/circle6Maximum transition delay 
/circle6Maximum load capacitance 
/circle6Maximum fanout 
/circle6Maximum buffer levels 
/square6Meet the clock tree targets: 
/circle6Maximum skew 
/circle6Min/Max insertion delay Constraints are upper bound 
goals. If constraints are not 
met, violations will be reported. 
Targets are "nice to have" 
goals. If targets are not met, 
no violations will be reported. 
DRC has the highest priority then next is skew then insertion delay 

Clock Tree Synthesis 
IC Compiler 1 4-9© 2009 
94-Clock Tree Synthesis (CTS) (1/2) 
A buffer tree is built to balance the loads and min imize the skew. FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF Clock 
This example shows a clock tree with three buffer levels between the clock s ource and the clock 
pins of FFs. Buffers are added to balance the loads (max tran/cap/fanout rul es). The insertion 
delays from the clock source to the clock pin of all FFs are optimized to be  as equal as possible in 
order to minimize the clock skew. 
The clock tree is built from the leafs (registers) up. 

Clock Tree Synthesis 
IC Compiler 1 4-10 © 2009 
10 4-Clock Tree Synthesis (CTS) (2/2) 
A “delay line” is added to meet  the minimum inserti on delay. FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF FF FF FF 
FF FF FF 
FF FF FF 
FF FF FF Clock 
A “delay line” is typically made up of back to back buffers. 

Clock Tree Synthesis 
IC Compiler 1 4-11 © 2009 
11 4-Where does the Clock Tree Begin and End? 
Start D               Q 
FF 
CLK GATED 
CLOCK D               Q 
FF 
CLK 
D               Q 
FF 
CLK STOP 
STOP 
STOP 
Clock Source 
create_clock …Clock Sinks 
(stop, float or 
exclude pins) 
Clock tree begins at SDC-defined clock source: 
create_clock 
Clock tree ends at “sinks”. These are: 
Stop pins 
Float pins 
Exclude pins  (aka ignore pins) 
The command report_clock_tree is a good tool to analyze your clock tree structure before 
actually synthesizing it. The command can output: 
/circle6Overview for each clock 
/circle6A clock tree summary 
/circle6A list of Ignore Pins 
/circle6The overlap of clock domains 
/circle6And more…

Clock Tree Synthesis 
IC Compiler 1 4-12 © 2009 
12 4-Define Clock Root Attributes (1/2) 
/square6When the clock root is a primary port of a block 
/circle6Ensure that an appropriate driving cell is defined 
set_driving_cell 
/circle6The synthesis constraints may include a weak driving cell fo r 
all inputs, including the clock port 
/circle6Because the clock is ideal during synthesis it has no effect on 
design QoR 
/circle6But a weak driver on the clock port affects clock tree QoR 
during CTS 
Clock root defined 
on primary clock port Driving Cell 
External driving cell 
specified for clock port CLK 
Example: 
set_driving_cell -lib_cell buf4 –pin Z [get_ports C LK] 

Clock Tree Synthesis 
IC Compiler 1 4-13 © 2009 
13 4-Define Clock Root Attributes (2/2) 
/square6When the clock root is a primary port, but at the CH IP-
level through an IO-PAD 
/circle6Ensure that an appropriate input transition is defined
set_input_transition 
Clock root defined 
on primary clock port Specify input transition 
IO_PAD CLK 
Example: 
set_input_transition –rise 0.3 [get_ports CLK] 
set_input_transition –fall 0.2 [get_ports CLK] 

Clock Tree Synthesis 
IC Compiler 1 4-14 © 2009 
14 4-Stop, Float and Exclude Pins 
/square6STOP Pins: 
/circle6CTS optimizes for DRC 
and clock tree targets 
(skew, insertion delay) 
/square6FLOAT Pins: 
/circle6Like Stop pins, but with 
delays on clock pin 
/square6EXCLUDE Pins: 
/circle6CTS ignores targets 
/circle6CTS fixes clock tree DRCs D               Q 
FF 
CLK GATED D               Q 
FF 
CLK 
CLOCK 
skew and insertion 
delay are ignored skew and insertion 
delay are optimized 
IP IP_CLK 
D               Q 
FF 
CLK 
CLK_OUT Implicit STOP or FLOAT pins 
Implicit EXCLUDE pins Exceptions 
Implicit STOP (sync) pins are automatically defined by CTS on: 
- Clock pins of sequential cells (FFs and latches) 
- Clock pins of macros 
Implicit EXCLUDE (ignore) pins are automatically defined by CT S on: 
- Non-clock input pins of sequential cells (D, Set, Reset, etc) 
- output ports 
- Pins of combinational cells without any fanout or with disabled timing arc s 
- Pins with 3-state enable arc 
- Select/Control pin of mux used in the data path 
- Input pin of pre-existing gate, if all pins in its fanout are exclude pins 
- Incorrectly defined clock pins (missing or incorrect pin definition in t he standard cell or 
macro cell FRAM view) 
-Clock pins without trigger edge info 
-Clock pins without a timing arc to the corresponding output pin 
When CTS defines implicit EXCLUDE pins these are reported as warnings in t he log file. Since an 
implicit ignore pin may imply a problem with either a reference library  cell or design connectivity, 
it is important to verify that all implicit ignore pins are acceptable  and intended. 

Clock Tree Synthesis 
IC Compiler 1 4-15 © 2009 
15 4-Generated and Gated Clocks 
Skew will be balanced ‘globally’, within each clock  domain, 
across all clock-pins of both master and generated clock. D               Q 
FF1 
CLK 
D               Q 
FF4 
CLK 
D               Q 
FF5 
CLK D               Q 
FF2 
CLK 
CLOCK 
create_clock D               Q 
FFD 
CLK    QN D               Q 
FF3 
CLK GATED 
create_generated_clock All insertion delays 
are matched 0.64 
0.65 
0.63 
create_clock –p 10 [get_ports CLOCK] 
create_generated_clock [get_pins {FFD/Q}] \
–source [get_ports CLOCK] –name DIV_CLK –divide_by 2 
The start point of a generated clock is traced back to the source of the create_clock 
command that the generated clock is derived from. 
By default, CTS will not balance the skew of FFs that cross clock domains. Gene rated clocks are 
considered to be part of the same clock domain as their source clock, and are therefore synthesized 
together with the source clock. In case of generated clocks, a skew repor t of the master clock also 
considers and contains the sinks of the generated clock. Also, ICC generates a s eparate clock tree 
report for the generated clock also. 
By default, CTS will balance the skew ‘globally’. This means that the s kew of all sequential 
devices in the same clock domain, related or not, will be balanced. Two sequentia l devices are 
related if there is a data path connection between them. 

Clock Tree Synthesis 
IC Compiler 1 4-16 © 2009 
16 4-Skew Balancing not Required? 
If the divided clock 
domain is independent 
of the master domain 
(no paths), skew 
balancing may not be 
important. 
CLOCK 
D               Q 
FFD 
CLK    QN D               Q 
FF 
CLK D               Q 
FF 
CLK 
D               Q 
FF 
CLK Define an explicit 
exclude pin here D               Q 
FF 
CLK … …
set_clock_tree_exceptions -exclude_pins [get_pins F FD/CLK] 0.42 
0.67 Exceptions 
By defining an explicit exclude pin, the two “domains” – CLOCK and divided CLO CK – will no 
longer be optimized together for skew. 

Clock Tree Synthesis 
IC Compiler 1 4-17 © 2009 
17 4-Scenario: If a macro cell  
clock pin is defined, CTS will 
treat that pin as an implicit 
stop pin. In this example the 
clock pin is not defined. 
What is the problem here? User-defined or Explicit Stop Pins 
IP (FRAM) IP_CLK CLOCK 
skew and 
insertion 
delay are 
ignored 
Implicit exclude pin 
no clock pin 
definition 
The macro’s clock pin is marked 
as an implicit exclude pin – no 
skew optimization! D               Q 
FF 
CLKn ?D               Q 
FF3 
CLK 
Typically the clock port of a macro cell is defined as: a stop pin with c orrect clock tree delay 
information. CTS would use the internal clock tree delay to decide how much more it n eeds to add 
outside the macro cell during CTS to optimize for skew and insertion delay wi th the rest of the 
stop pins outside the macro cell. 
When a clock pin is not defined or defined incorrectly, CTS does not have enough infor mation to 
optimize it for skew and insertion delay. This forces CTS to assign it an i mplicit exclude pin where 
it gets buffered by a single buffer. 
Incorrectly defined clock pins (missing or incorrect pin definition in the st andard cell or macro cell 
FRAM view): 
-Clock pins without trigger edge info 
-Clock pins without a timing arc to the corresponding output pin 

Clock Tree Synthesis 
IC Compiler 1 4-18 © 2009 
18 4-Defining an Explicit Stop Pin 
CLOCK 
skew and insertion delay 
are now optimized 
Explicit stop pin defined Defining an explicit stop 
pin allows CTS to optimize 
for skew and insertion 
delay targets. 
IP D               Q 
FF 
CLKn 0.17 IP_CLK D               Q 
FF 
CLK 0.42 
0.43 
CTS has no knowledge of the 
IP-internal clock delay – it can 
only “see” up to the stop pin! 
set_clock_tree_exceptions –stop_pins [get_pins IP/I P_CLK] 
In the above example, CTS is doing the right thing – balancing the inserti on delays up to all stop 
pins. CTS doesn’t know that internal to the IP, there is a 0.17 delay to the actual  clock pins of the 
flip flops. 

Clock Tree Synthesis 
IC Compiler 1 4-19 © 2009 
19 4-Defining an Explicit Float Pin 
IP D               Q 
FF 
CLKn 0.15 CLOCK 
skew and insertion delay 
are now optimized 
Explicit float pin defined Defining an explicit float 
pin allows CTS to adjust 
the  insertion delays based 
on specification. 
IP_CLK D               Q 
FF 
CLK 0.42 
0.27 
D               Q 
FF 
CLKn Exceptions 
set_clock_tree_exceptions \
-float_pins IP/IP_CLK \
-float_pin_max_delay_rise 0.15 
The complete list of float-pin related options is as follows: 
set_clock_tree_exceptions \
-float_pins 
-float_pin_max_delay_rise 
-float_pin_min_delay_rise 
-float_pin_max_delay_fall 
-float_pin_min_delay_fall 
The max and min options are used to specify the delays under max (worst) and min (be st) 
operating conditions, if min_max CTS is performed. 

Clock Tree Synthesis 
IC Compiler 1 4-20 © 2009 
20 4-Set a dont_touch_subtrees 
exception at the input pin Pre-existing 
clock tree Preserving Pre-Existing Clock Trees 
CTS will only build 
this part of the tree 
set_clock_tree_exceptions -dont_touch_subtrees buf/ A Delays are balanced 
across pre-existing 
and new clock trees CLOCK 
D               Q 
FFb 
CLK D               Q 
FFn 
CLK …
Custom logic 
hand-built A    Y D               Q 
FF1 
CLK 
D               Q 
FFa 
CLK Exceptions 
Total insertion delay includes the delay of the pre-existing clock tree . 
If you don’t preserve an existing clock tree, CTS will not rip-out the clock tree and rebuild a new 
one for you. Instead, it will use whatever is there to meet its goals and may add more logic. This 
may not always be desirable. Instead, you may want to delete the pre-exi sting clock tree entirely.  
To remove the clock tree instead of preserving it, use the command remove_clock_tree .

Clock Tree Synthesis 
IC Compiler 1 4-21 © 2009 
21 4-Impact of Preexisting Clock Cells 
/square6Any preexisting clock buffers and cells are counted  
as clock gate levels 
/circle6Any clock gate level is considered as a balancing p oint, 
therefore…
/circle6Preexisting clock buffers/inverters might create 
unnecessary clock levels for CTS 
/square6Use remove_clock_tree to remove existing clock 
buffers 
/circle6Will generally lead to higher quality clock trees 

Clock Tree Synthesis 
IC Compiler 1 4-22 © 2009 
22 4-Test for Understanding 
1. What are the two main goals of CTS? 
/barb2right/barb2right /barb2right/barb2right
/barb2right/barb2right /barb2right/barb2right
2. What is the difference between stop and exclude pins ? 
List some examples of implicit stop/exclude pins. 
3. How is a float pin different from a stop pin? 1. /barb2rightMeet DRC (max tran/cap/fanout) 
/barb2rightMeet the clock tree targets (max skew and min insertion delay) 
2. CTS stops at both. CTS optimizes for DRC for both, but only optimizes for clock tree  targets 
to the stop pins. Implicit stop pins: clock pins of FFs, latches and macro cells. Implicit exclude pins: non-clock input pins of sequential cells (data, set, re set, etc); clock 
output ports; clock pins of sequential cells where the output is floating; incor rectly defined 
clock pins. 
3. A float pin allows the user to define when the clock edge is supposed to ar rive at the pin. This 
can be used to give IP blocks or RAMs extra margin/setup time if needed. 

Clock Tree Synthesis 
IC Compiler 1 4-23 © 2009 
23 4-
Specifying Skew / Insertion Delay Targets 
icc_shell> set_clock_tree_options \
-target_early_delay 0.9 \
-target_skew 0.1 
Setting global CTS options... 
1Control 
Options can be set on 
all clocks defined in 
SDC (globally) or on a 
clock-by-clock basis. 
Minimum insertion delay (target early delay) is done by adding a chain of  buffer as needed if the 
insertion of the clock tree is less than the target specified. 
The Max buffer levels constraint is not supported! 

Clock Tree Synthesis 
IC Compiler 1 4-24 © 2009 
24 4-Clock by Clock Settings 
/square6Use the GUI, select the appropriate clock from the 
pull-down, and OK your selections for every clock 
/square6Better: Use the shell. How do you set different targets per clock? 
set_clock_tree_options \
–clock_tree clk1 -target_early_delay 0.9 
set_clock_tree_options \
–clock_tree clk2 -target_skew 0.2 
TIP: Use the GUI preview mode, then cut&paste 
the echo’d commands into your script. 
set_clock_tree_options 
[-clock_tree <pin_name>]     (root of the clock tree) 
[-layer_list <list>]   (layers enabled for clock tree routing) 
[-target_skew ]        (skew constraint) 
[-target_early_delay ] (minimum insertion delay) 
[-routing_rule ]       (name of a non-default routing rule to 
use for clock tree nets) 
[-buffer_sizing boolean-string] 
(whether buffers in one level may have different sizes)
[-buffer_relocation boolean-string] 
(allow to relocate buffers during optimization) 
[-gate_sizing boolean-string] 
(allow to size gates during optimization) 
[-gate_relocation boolean-string] 
(allow to relocate gates during optimization) 
[-delay_insertion boolean-string] 
(allow to insert delay during optimization) 

Clock Tree Synthesis 
IC Compiler 1 4-25 © 2009 
25 4-Set Buffer/Inverter Selection Lists 
/square6To limit CTS to a list of buffers/inverters used fo r 
specific optimizations: 
set_clock_tree_references 
–references list1 
–references list2 –sizing_only 
–references list3 –delay_insertion_only 
/circle6There is no priority on how CTS uses the members 
from each list 
/circle6If a list is not specified, all buffers/inverters i n the 
library without dont_use attributes are used It is recommended 
to define all lists 
Make sure the references are in target_library !
The set_clock_tree_references command allows you to select specific library cells 
(buffers, inverters, delay cells) for clock tree synthesis. In gener al, it is recommended to allow 
CTS to choose the best buffers from the library automatically, but in some cases you may need to 
tell CTS which ones to use!  The following options exist: 
[-clock_trees <list>] (list of clock names or clock root pins or ports) 
-references <list> (list of library cells to be used for buffering) 
[-sizing_only ] (use the specified reference for sizing optimization only) 
[-delay_insertion_only ] (use the specified reference for delay insertion optimization 
only) 
To remove all reference settings, use the command reset_clock_tree_references. 
It is highly recommended to select good cells for CTS from your librar y: 
set_clock_tree_references -references "BEST_PRACTIC E_buffers_for_cts" 
set_clock_tree_references -sizing_only 
-references "BEST_PRACTICE_buffers_for_CTS_CTO_sizi ng" 
set_clock_tree_references -delay_insertion_only 
-references "BEST_PRACTICE_cels_for_CTS_CTO_delay_i nsertion" 
It’s recommended to define each list for each optimization. If a list i s not defined, unspecified cells 
from target libraries maybe used unexpectedly. 

Clock Tree Synthesis 
IC Compiler 1 4-26 © 2009 
26 4-
When Clock Tree DRCs are Used 
/square6Max tran/cap/fanout/buf: 
/circle6Smallest value from library, SDC file and/or GUI is used 
/circle6If (GUI values < SDC or library) 
/barb2rightVerify with vendor/designer and relax GUI values 
/square6If settings are too tight, 
violations may not be fixed 
/square6For DRC , what the GUI 
calls “target” is actually 
a “constraint” as defined 
earlier! DRC 
Where clock 
tree DRC is set 
The SDC DRC constraints are obeyed by CTS: 
set_max_fanout 
set_max_capacitance 
set_max_transition 
These constraints can be applied to design ports or as a global setting. To s et the constraint as a 
global setting, use for example “ set_max_fanout 2 [current_design] ”.
Override 
If you want to force the tool to use CTS-specific design rule constraints using 
set_clock_tree_options , even though they are relaxed compared to the library or SDC, turn 
ON the following variable (default is false): 
set cts_force_user_constraints true 

Clock Tree Synthesis 
IC Compiler 1 4-27 © 2009 
27 4-Non-Default Clock Routing 
/square6IC Compiler can route the clocks using non-default 
routing rules, e.g. double-spacing, double-width, 
shielding 
/square6Non-default rules are often used to “harden” the 
clock, e.g. to make the clock routes less sensitive  
to Cross Talk or EM effects Physical 
Constraints 
Default Routing Rule Effect of NDR route on Clk Sig1 
Clk 
Sig2 Sig1 
Clk 
Sig2 

Clock Tree Synthesis 
IC Compiler 1 4-28 © 2009 
28 4-Specifying Non-Default Rules 
/square6First, define the NDR: 
/square6Then, configure CTS: define_routing_rule my_route_rule  \
-widths {METAL3 0.4 METAL4 0.6 METAL5 0.6} \
-spacings {METAL3 0.5 METAL4 0.65 METAL5 0.65} 
set_clock_tree_options –root clk  \
-routing_rule my_route_rule  \
-layer_list "METAL3 METAL4 METAL5" 
You may also specify 
the layers to use for 
clock tree routing. 
You can report on the routing rules that were defined using  report_routing_rule. 
If, in the above example, layers are used for which a non-default routing rule  was not defined, 
these layers will use the default routing rules, as defined by the tec h-file. 
define_routing_rule  rule_name 
-reference_rule_name rule_name 
| -default_reference_rule 
[-widths {routing_layer_name value} ] 
[-snap_to_track] 
[-spacings {routing_layer_name value} ] 
[-shield_widths {routing_layer_name value} ] 
[-shield_spacings {routing_layer_name value} ] 
[-via_cuts {default_via_name value} ] 
[-taper_level tapering_level] 

Clock Tree Synthesis 
IC Compiler 1 4-29 © 2009 
29 4-Nondefault Rule Options 
set_clock_tree_options \
-routing_rule my_route_rule set_clock_tree_options \
-routing_rule my_route_rule \
-use_default_routing_for_sinks 1 
Default Behavior NDR wires 
NDR wires Default wires 
134
2
use_default_routing_for_sinks 
can only be used globally! 
Since the pin density at the flipflop is higher, it may be better to use defaul t routing when making 
the final connection. This can prevent many Routing DRC violations that may tak e longer to fix. 
The use_default_routing_for_sinks option expects a positive integer, which stands for the 
number of levels to use default routing for. In the example shown above, “1” means  use default 
routing for ONE stage, the final connection. 
This option can only be used globally, meaning all clocks at once. 

Clock Tree Synthesis 
IC Compiler 1 4-30 © 2009 
30 4-NDR Recommendations 
/square6Always route clock on metal 3 and above 
/square6Avoid NDR on clock sinks: 
set_clock_tree_options -use_default_routing_for_sin ks 1 
/square6Avoid NDR on Metal 1 
/circle6may have trouble accessing metal 1 pins 
on buffers and gates 
/square6Put NDR on pitch – try to avoid blind double spacing
/circle6Preserve routing resources/keep preroute RC estimat ion 
accurate 
/square6Consider double width to reduce resistance 
/square6Consider double via to reduce resistance and 
improve yield 
A word on double-spacing: The minimum spacing indicated in the tech file is gen erally not pitch -
width. So if you want double-spaced wires for clocks, you need to use the double pitc h (along with 
width) as your indicator for finding a good spacing value. Wires will end up on pitch – so this 
improves correlation with what you have before detail routing. 

Clock Tree Synthesis 
IC Compiler 1 4-31 © 2009 
31 4-Invoke CTS: Core Command 
clock_opt 
Physical 
Constraints Control 
DRC 
Exceptions /checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld Single Command CTS, 
Optimization and CT routing 
Options: 
-operating_condition 
-inter_clock_balance 
-optimize_dft 
(more later) /checkbld/checkbld /checkbld/checkbld
Menu:  CTS /barb2rightCore CTS and Optimization 


Clock Tree Synthesis 
IC Compiler 1 4-32 © 2009 
32 4-clock_opt use recommendation 
/square6Using clock_opt in the following manner has been 
found to be more flexible across designs and flows:
clock_opt -only_cts -no_clock_route 
analyze…
clock_opt -only_psyn -no_clock_route 
analyze…
route_group -all_clock_nets 

Clock Tree Synthesis 
IC Compiler 1 4-33 © 2009 
33 4-Effects of Clock Tree Synthesis 
/square6Clock buffers added 
/square6Congestion may increase 
/square6Non clock cells may have 
been moved to less ideal 
locations 
/square6Can introduce new timing 
and max tran/cap 
violations 
How do you handle new violations? 
Congestion pattern should be similar to the one before CTS. It is, however, genera lly higher due to 
the extra clock buffers added during CTS. 
If the optimal location for the CTS buffer overlaps with cells placed previo usly then the previously 
placed cells need to be moved to open up space for the clock tree buffers. 

Clock Tree Synthesis 
IC Compiler 1 4-34 © 2009 
34 4-Incremental Placement / Optimization 
/square6clock_opt –only_psyn 
/circle6Reduces disturbances to other cells as much as poss ible 
/circle6Performs logical and placement optimizations to fix  
possible timing and max tran/cap violations, based on 
propagated clock arrivals 
/square6To enable hold time fixing 
/circle6To prioritize TNS over WNS, set: 
/circle6To prioritize min over max, set: set_fix_hold [all_clocks] 
clock_opt –only_psyn 
set_fix_hold_options –prioritize_tns 
set_fix_hold_options –prioritize_min 
The alternative to using fix hold attribute is to use –fix_hold_all_clocks option. However, 
it’s recommended to use set_fix_hold so the fix hold attribute is saved to the Milky way database. 

Clock Tree Synthesis 
IC Compiler 1 4-35 © 2009 
35 4-Minimize Hold Time Violations in Scan Paths 
/square6Reorders to minimize crossings between clock buffer s 
/square6Can reduce unnecessary hold time violations in the 
scan chain 
Without clock tree based reordering With clock tree based reordering clock_opt –only_psyn –optimize_dft 
test_si 
clk 
test_so ACE
BDFtest_si 
clk 
test_so ACE
BDF

Clock Tree Synthesis 
IC Compiler 1 4-36 © 2009 
36 4-Recommended Flow 
place_opt 
# timing ok, congestion ok! 
set_clock_tree_options ... 
set_clock_tree_exceptions ... 
set_clock_tree_references ... 
remove_clock_uncertainty [all_clocks] 
# OR: adjust uncertainty to contain only jitter, not skew component
clock_opt –only_cts –no_clock_route 
#   Analyze 
set_fix_hold [all_clocks] 
clock_opt –only_psyn –optimize_dft –no_clock_route 
All CTS-built clocks are propagated automatically –
no need to use the “ set_propagated_clock ” command! !

Clock Tree Synthesis 
IC Compiler 1 4-37 © 2009 
37 4-Analysis using the CTS GUI 
/square6CTS browser 
/circle6Properties and attributes 
on clock tree objects 
/circle6Traversing clock tree 
levels 
/circle6Symbols for CTS objects 
like buffers, gates and 
sinks 
/square6CTS schematic 
/circle6Trace forward/backward 
in schematic view 
/circle6Collapses all sinks in the 
fanout of a CTS buffer for 
clearer CTS schematic 
/circle6Highlight CTS objects in 
the layout view 
/square6Clock arrival histogram 
CTS /barb2right/barb2right /barb2right/barb2rightNew Clock Tree Synthesis Window 

Clock Tree Synthesis 
IC Compiler 1 4-38 © 2009 
38 4-Analyzing CTS Results 
/square6report_clock_tree 
-summary 
-settings 
-... 
/circle6Reports Max global skew, Late/Early insertion delay , 
Number of levels in clock tree, Number of clock tre e 
references (Buffers), Clock DRC violations 
/square6report_clock_timing 
/circle6Reports actual, relevant skew, latency, interclock latency 
etc. for paths that are related .
/circle6Example:   report_clock_timing –type skew Details covered in the lab! 

Clock Tree Synthesis 
IC Compiler 1 4-39 © 2009 
39 4-What about CTS Operating Conditions? 
/square6What happens when building the CT using min_max? 
/circle6The tree is compiled in –max then analyzed in –min 
/rhombus6If the skew analyzed in –min is not worse than the skew in –max, 
compiling with –min_max will not make much difference 
/rhombus6If the skew analyzed in –min is worse than that in –max,  then 
compile in –min_max will build a tree with a better skew in –min 
at the cost of a possibly worst skew in –max 
/square6In summary, a tree compiled in –min_max will build a tree with 
less skew variation when analyzed in both –min and – max 
/square6The skew will not be better than a tree compiled an d 
analyzed in –max clock_opt –operating_condition min_max 

Clock Tree Synthesis 
IC Compiler 1 4-40 © 2009 
40 4-Clock Tree Optimization 
CTO 
Routing Placed design with clock 
tree synthesized that 
meets setup/hold, tran/cap 
Yes No Clock spec 
met? Clock Analysis Perform additional Clock Tree Optimization as 
necessary to further improve clock skew. 
CT optimization is run 
inside clock_opt , and 
can be run independently 
as well: 
optimize_clock_tree 
Options set on the clock options dialog for clock_opt do not apply to the stand-alone com mand 
optimize_clock_tree! This command uses its own options as shown below. 
optimize_clock_tree 
-delay_insertion [default = on] 
-buffer_sizing [default = on] 
-buffer_relocation [default = on] 
-gate_sizing [default = off] 
-gate_relocation [default = on] 
-operating_condition min|max (default)|min_max 

Clock Tree Synthesis 
IC Compiler 1 4-41 © 2009 
41 4-
After FF FF FF 3X 
2X FF FF FF FF 
FF 
FF FF 4X 
4X 
After 4X 
FF 
FF FF 4X 3X 
FF FF FF FF 
FF 
FF FF 2X 
5X (Embedded) Clock Tree Optimization 
Before 
FF FF FF 3X 
4X 2X FF FF FF FF 
FF FF FF 
4X 
After 3X 
FF 
FF FF 4X 3X 
FF FF 
FF FF 
FF 
FF FF 
4X 
Gate/Buffer Sizing 
Sizes up or down buffers/gates to improve both skew and insertion delay. 
Will not modify the clock tree structure during this optimization process. 
Buffer Relocation 
Physical location of the buffer is moved to reduce skew and insertion delay. 
Will not add or remove hierarchy during optimization process. 
Delay Insertion 
Delay is inserted for shortest paths. 

Clock Tree Synthesis 
IC Compiler 1 4-42 © 2009 
42 4-Balancing Multiple Synchronous Clocks 
As shown here, the path from FF1 to FF3 will have a n 
additional setup penalty of 0.75-0.32=0.43 D               Q 
FF3 
CLK 
D               Q 
FF4 
CLK D               Q 
FF1 
CLK 
CLOCK1 D               Q 
FF2 
CLK 0.75 
0.32 
… …
CLOCK2 WNS=-0.6 

Clock Tree Synthesis 
IC Compiler 1 4-43 © 2009 
43 4-Inter-Clock Delay Balancing 
All insertion delays 
are balanced D               Q 
FF3 
CLK 
D               Q 
FF4 
CLK D               Q 
FF1 
CLK 
CLOCK1 D               Q 
FF2 
CLK 0.75 
0.76 
… …
CLOCK2 WNS=-0.16 set_inter_clock_delay_options \
-balance_group "CLOCK1 CLOCK2" 
clock_opt -inter_clock_balance 
Performs CTS and balances the clocks. 
Clock tree balancing can also be performed stand-alone after CTS using t he command: 
balance_inter_clock_delay-clock_trees "CLOCK1 CLOCK2" 

Clock Tree Synthesis 
IC Compiler 1 4-44 © 2009 
44 4-Inter-Clock Delay Balancing with Offset 
D               Q 
FF3 
CLK 
D               Q 
FF4 
CLK D               Q 
FF1 
CLK 
CLOCK1 D               Q 
FF2 
CLK 0.75 
0.94 
… …
CLOCK2 set_inter_clock_delay_options \
-offset_from CLOCK1 -offset_to CLOCK2 \
-delay_offset 0.2 
clock_opt -inter_clock_balance 
# or stand-alone after CTS: 
# balance_inter_clock_delay -clock_trees "CLOCK1 CL OCK2" 
WNS=+0.02 
The stand-alone after CTS equivalent commands are: 
set_inter_clock_delay_options -offset_from CLOCK1 \
-offset_to CLOCK2 -delay_offset 0.2 
balance_inter_clock_delay -clock_trees "CLOCK1 CLOCK2" 
Clock trees can be balanced using an offset requirement, as shown above, or using tar gets, using 
the syntax below or through SDC set_clock_latency commands. 
The following command performs inter clock delay balancing using the  maximum target delay 
options: 
balance_inter_clock_delay -max_target_delay 0.5 
The following command performs inter clock delay balance for the CL K1 clock tree to 0.5ns and 
CLK2 to 0.8ns: 
set_inter_clock_delay_options -target_delay_clock CLK1 -
target_delay_value 0.5 
set_inter_clock_delay_options -target_delay_clock CLK2 -
target_delay_value 0.8 
balance_inter_clock_delay 
To honor the latencies defined in the SDC file, use 
set_inter_clock_delay_options -honor_sdc true 

Clock Tree Synthesis 
IC Compiler 1 4-45 © 2009 
45 4-SDC Latencies 
/square6CTS does not respect SDC latencies by default! 
/square6If you need your insertion delays to match the SDC 
provided latencies, perform clock tree balancing 
/square6Note: Insertion delay will not be minimized if give n 
SDC latency is less than initial CTS insertion dela y Does CTS respect SDC set_clock_latency ?
set_inter_clock_delay_options -honor_sdc true 
clock_opt -inter_clock_balance 

Clock Tree Synthesis 
IC Compiler 1 4-46 © 2009 
46 4-Core vs. Atomic Commands 
/square6IC Compiler’s clock_opt is very powerful and tries to 
give the best Out-of-Box clock tree results. Finer 
control over clock_opt for specific tweaking is not 
always possible 
/circle6E.g., you can only compile all clocks at once with clock_opt 
/square6For finer control, you can execute a series of “ato mic”
commands 
/square6Please refer to the documentation for details on th e 
atomic commands – Example follows…

Clock Tree Synthesis 
IC Compiler 1 4-47 © 2009 
47 4-Flow Using Atomic Commands 
place_opt 
# timing ok, congestion ok! 
set_clock_tree_options ... 
set_clock_tree_exceptions ... 
set_clock_tree_references ... 
define_routing_rule my_route_rule …
set_clock_tree_options \
-routing_rule my_route_rule \
-use_default_routing_for_sinks 1 
compile_clock_tree –clock_trees "CLOCK2" 
compile_clock_tree –clock_trees "CLOCK1" 
optimize_clock_tree 
remove_clock_uncertainty [all_clocks] 
#OR: adjust uncertainty to contain only jitter, not skew co mponent
set_fix_hold [all_clocks] 
psynopt –area_recovery 
optimize_clock_tree 
route_group -all_clock_nets 

Clock Tree Synthesis 
IC Compiler 1 4-48 © 2009 
48 4-Test for Understanding 
1. CTS tries to: 
a) Minimize skew only 
b) Minimize skew and insertion delay 
c) Minimize skew and maximize insertion delay 
d) Minimize skew and meet minimum insertion delay target
2. How do you set a clock skew target of 0.1 for clk 1, 
and a minimum insertion delay of 0.7 for clk2?  
What is the skew target for clk2? 
3. Write the command(s) to balance the two clock 
trees clk1 and clk2, so clk2 arrives 0.3 earlier! 
4. Why is it important to remove or adjust the clock  
uncertainty before executing clock_opt ?1. d) Minimize skew and meet minimum insertion delay target 2.  set_clock_tree_options -root clk1 -target_skew 0.1 set_clock_tree_options -root clk2 \-target_early_delay 0.7 If no skew target was defined for clk2, the default is 0. 
3. set_inter_clock_delay_options -offset_from clk2 \
-offset_to clk1 -delay_offset 0.3 
clock_opt –inter_clock_balance OR after CTS: balance_inter_clock_delay -clock_trees "clk1 clk2" 
4. Uncertainty should be removed before clock_opt in case post-cts optimizations a re done as 
well. Otherwise, the optimizations will take a very pessimistic skew into account (actual clock 
skew + uncertainty)! 

Clock Tree Synthesis 
IC Compiler 1 4-49 © 2009 
49 4-Unit Objectives Summary 
You should now be able to: 
/square6List the status of the design prior to CTS 
/square6Set up the design for clock tree synthesis 
/square6Identify implicit clock tree start/end points and 
when explicit modifications are needed 
/square6Control the constraints and targets 
used by CTS 
/square6Execute the recommended clock tree 
synthesis and optimization flow 
/square6Analyze timing and clock specifications 
post CTS 

Clock Tree Synthesis 
IC Compiler 1 4-50 © 2009 
50 4-Lab 4: Clock Tree Synthesis 
Perform CTS and 
Optimizations on the 
ORCA Design. 75 minutes 
Examine Clock Trees 
CTS Setup 
CTS 
Analysis 
Hold Time Fixing 
CT Routing 

Clock Tree Synthesis 
IC Compiler 1 4-51 © 2009 
Appendix A 
Automatic IO Latency Calculation 

Clock Tree Synthesis 
IC Compiler 1 4-52 © 2009 
52 4-IO Latency Auto Update 
D               Q 
FF 
CLK 
CLOCK D               Q 
FF 
CLK 
/square6Once clock trees are built, delays are propagated: 
/circle6Latency of the “real” clock path is calculated (lower arro w in diagram) 
/square6Under normal circumstances, the IOs - or more precis ely the 
flipflops driving/capturing the IOs - have zero laten cy, unless it is 
/circle6Specified as source latency in the SDC 
/circle6Included in input delay 
/square6IC Compiler can compute the median insertion delay and apply it as 
clock latency on the IO paths (upper arrow in diagram) 
clock_opt -update_clock_latency 
Or after CTS: update_clock_latency 

Clock Tree Synthesis 
IC Compiler 1 4-53 © 2009 
53 4-Auto Update with Virtual Clocks 
set_input_delay –clock v_clk 
set_clock_latency 1.0 v_clk 
create_clock m_clk 
set_clock_latency 1.0 m_clk 
After clock propagation, median 
insertion delay is 1.2 
set_output_delay –clock m_clk set_clock_latency 1.2 v_clk /square6Latency can also be updated for ports that were constrai ned using 
a virtual clock. First, define the related virtual clock: 
set_latency_adjustment_options \
–from_clock m_clk -to_clock v_clk 
/square6Second, use update_clock_latency 
Updated 
automatically 

Clock Tree Synthesis 
IC Compiler 1 4-54 © 2009 
Appendix B 
CTS with Logical Hierarchy 

Clock Tree Synthesis 
IC Compiler 1 4-55 © 2009 
55 4-CTS with Logical Hierarchy 
/square6Clock tree cells are added at the lowest level of 
common hierarchy 
/square6Ports are added as necessary for the sub-modules 
/circle6Minimal number of new ports created 
Clock Root 
Minimal New Ports 

Clock Tree Synthesis 
IC Compiler 1 4-56 © 2009 
56 4-Clock Tree Cells Added in Top Hier 
/square6New clock tree cells are added at the lowest 
common hierarchy of the sinks and new ports are 
created to connect to them (if required) 
Clock 
Root New ports 
Clock tree cells 

Clock Tree Synthesis 
IC Compiler 1 4-57 © 2009 
Appendix C 
Clock tree configuration control 

Clock Tree Synthesis 
IC Compiler 1 4-58 © 2009 
58 4-Clock Tree Configuration Control 
/square6Provides additional flexibility to control the resu lts 
of clock tree synthesis through a predefined clock 
tree structure (per net basis) 
compile_clock_tree \
–config_file_read <file_name> \
-config_file_write <file_name> 
/square6Flexibility for providing Hard or Soft clock tree 
configuration 
/square6Embedded CTO operations can change the clock 
tree reference, but will retain the clock tree 
structure 

Clock Tree Synthesis 
IC Compiler 1 4-59 © 2009 
59 4-Clock Tree Configuration Syntax 
/square6Hard Configuration 
begin_clock_tree 6 
clock_net core/clk 
buffer_level bufx6 2 
buffer_level invx12 4 
buffer_level bufx12 7 
buffer_level invx12 11 
buffer_level bufx12 48 
buffer_level bufx12 268 
end_clock_tree /square6Soft Configuration 
begin_clock_tree 0 
clock_net core/clk 
buffer_level invx12 4 
buffer_level bufx12 7 
buffer_level invx12 0 
buffer_level bufx12 48 
buffer_level bufx12 268 
end_clock_tree 

Clock Tree Synthesis 
IC Compiler 1 4-60 © 2009 
Appendix D 
CTS Naming Convention 

Clock Tree Synthesis 
IC Compiler 1 4-61 © 2009 
61 4-CTS – Naming Convention 
Instance 
Buffer 
Gate buffername_G#B#I# 
implicit exclude pin (no valid trigger edge) 
explicit exclude pin 
You can further name the clock buffers using: 
set cts_instance_name_prefix "MYPREFIX" 
Which produces: MYPREFIX_clkbuf1x24_G1B1I23 D               Q 
FF 
CLK Bbuf_G2B2I1 
D               Q 
FF 
CLK Bbuf_G2B2I2 
D               Q 
FF 
CLK Bbuf_G3B1I1 Bbuf_G2B1I1 
D               Q 
FF 
CLK Bbuf_G1B2I2 
D               Q 
FF 
CLK Bbuf_G1IP Bbuf_G2B1I2 
Bbuf_G1B2I3 Bbuf_G1B2I1 
Clock 
GxByIz: x=gate-level (after 1 st gate /barb2rightx=2), y=buffer-level, z=uniquified by smallest integer 
(P=in front of ignore pin) 
Leaf net Gate level 
N +1 Gate level 
NTo 
FFs Buffer 
Level 1 Buffer 
Level 1 Buffer 
Level 2 

Clock Tree Synthesis 
IC Compiler 1 4-62 © 2009 
This page was intentionally left blank. 

Multi Scenario Optimization 
IC Compiler 1 5-1© 2009 
15-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 DAY 
33 33
Multi Scenario Optimization 5
Routing and Crosstalk 6
Chip Finishing and DFM 7
Customer Support CS 

Multi Scenario Optimization 
IC Compiler 1 5-2© 2009 
25-Unit Objectives 
After completing this unit, you should be able to: 
/square6Describe the need for Multi-Corner and 
Multi-Mode analysis and optimization 
/square6Specify a scenario in IC Compiler 
/square6Describe the advantages of and 
how to use on chip variation 
/square6Analyze the design under all or some scenarios 

Multi Scenario Optimization 
IC Compiler 1 5-3© 2009 
35-Timing Analysis during Optimization 
/square6Typically, when optimizing with implementation tool s, 
setup and hold are checked in the worst and best 
corner respectively, using one set of constraints Worst 
PVT Best 
PVT Slowest Delays Fastest Delays 
Setup 
Violated? Hold 
Violated? 
PVT: Process, Voltage and Temperature 
PVT refers to a variation in cell delays and cell pin capacitances due t o fabrication process 
variance, power supply voltage variations, and temperature (which could vary be cause of power 
consumption, ambient temperature, package type or cooling method). 

Multi Scenario Optimization 
IC Compiler 1 5-4© 2009 
45-What about other Situations? 
Is min-max analysis under one set of constraints en ough? 
Worst 
PVT Best 
PVT 
Offer one reason to perform setup and hold in 
both corners. Slowest Delays Fastest Delays 
Setup 
Violated? Hold 
Violated? Setup 
Violated? Hold 
Violated? 
Answer: Generally, min-max analysis under one set of SDC constraints is no l onger enough.  A 
good reason to perform setup and hold in both corners: The clock skew can be much worse und er 
slow PVT.  The clock skew has a huge impact on hold.  Therefore – you should check for hold 
under the slow PVT corner. 
Performing setup and hold checks under both PVT extreme corners is sometimes referred to as 
“four-corner analysis ”.

Multi Scenario Optimization 
IC Compiler 1 5-5© 2009 
55-What is the # of Runs? 
Worst 
PVT Best 
PVT 
Functional Mode Test Mode 
How are different 
modes represented? You will have to perform: 
/boxopen2 separate runs. 
/boxopen4 separate runs. Setup, Hold Setup, Hold 
The # of runs = # Modes x # PVT corners. 
How are different modes represented? – Using different design constraints  (and constraint files) 
How many classical runs are necessary? – 4 runs.  Functional and test under bot h slow and fast 
PVT. 
(Setup and hold can be calculated during the same classical “run”.) 
Examples of constraints in test mode while the chip is a device under test (DU T): 
• Tester clock period and clock source 
• Model tester skew on the input ports 
• Different timing exceptions 
• Different setup/hold on the output ports 
• The scan chain is exercised in test mode (but not in functional mode) 

Multi Scenario Optimization 
IC Compiler 1 5-6© 2009 
65-Corners Represent Delay at Different OpCon 
Delay 
Operating Conditions 
~ P / -V / T Worst 
PVT 
Best 
PVT Setup and hold checks 
performed here…
…and here More PVTs (e.g. PVT 2, 
PVT 3) 
And on top of that, all 
modes may be exercised 
in every corner…

Multi Scenario Optimization 
IC Compiler 1 5-7© 2009 
75-XYZ Mode ABC Mode Multiple Corners – Multiple Modes 
/square6IC Compiler’s MCMM allows concurrent 
optimization under multiple corners and modes 
/square6We call a mode + corner a scenario Test Mode Worst 
PVT 
PVT 2 PVT 3 
Best 
PVT 
Functional Mode 
High performance requirements, coupled with extended battery life and in creased system 
integration has made multi-mode design and multiple operating conditions a  requirement for many 
of today's new products. The ability to produce optimized designs that can oper ate in many 
different modes and at many different operating conditions is crucial to th e success products in 
today’s marketplace. 
As a result of these demands in the electronics market, many Synopsys customer s are requesting 
intelligent multi-mode and multi-operating condition (MCMM) handling in t he Galaxy platform. 
The reason for this request is that clearly their current designs have  multiple modes of operation 
and operate at multiple operating conditions. However, the flow used to achieve  these designs 
requires extensive manual intervention, is both time-consuming and error prone, and is not 
extendable to the next generation design and process. 
There have been sequential approaches tried before for this concurrent approach where the 
constraints are merged in order to achieve compliance across all scenar ios, but these approaches 
can lead to convergence problems. The optimal solution to the MCMM problem is there fore to 
perform concurrent analysis & optimization. 
In IC Compiler, we now support concurrent multi-scenario analysis and optimiz ation. 

Multi Scenario Optimization 
IC Compiler 1 5-8© 2009 
85-Scenarios 
Worst 
PVT Functional Mode Scenario 1 = + +Parasitic 
View 1
ABC Mode Worst 
PVT Scenario 2 = + +Parasitic 
View 2
PVT 2 Functional Mode Scenario 3 = + +Parasitic 
View 3
XYZ Mode PVT 3 Scenario n = + +Parasitic 
View n
……
PVT /barb4right/barb4right/barb4right/barb4right Operating Condition 
Mode /barb4right/barb4right/barb4right/barb4right SDC Constraints 
Parasitic View /barb4right/barb4right/barb4right/barb4right TLU+, SPEF 
A scenario refers to a mode and/or corner that can be analyzed or optim ized. A mode is defined by 
a set of clocks, supply voltages, timing constraints, and libraries. It can also have annotation data 
such as SDF or parasitics files. A corner is defined as a set of librarie s characterized for process, 
voltage and temperature variations. Corners are not dependent on functional se ttings, but rather 
result from process variations during manufacturing along with voltage and te mperature variations 
in the environment in which the chip will operate. 
Variation support in MultiCorner: A voltage variation flow implies that the TLU+  and temperature 
is the same for each scenario while only the operating voltage is changed. 
Note: In this example, we are using one operating condition per scenario. Of  course you can use 2 
operating conditions with the set_operating_condition command, in either bc_wc o r on-chip 
variation. 

Multi Scenario Optimization 
IC Compiler 1 5-9© 2009 
95-Multi Scenario Solution in IC Compiler 
Scenario 1 
Scenario 2 Scenario 3 
Scenario n 
Scenario 4 Scenario 5 

Multi Scenario Optimization 
IC Compiler 1 5-10 © 2009 
10 5-How Are Violations Fixed? 
/square6The same violation might be present in multiple 
scenarios (albeit with a different negative slack) 
/square6IC Compiler will work on the path such that it 
improves across all scenarios 
/square6A -2 slack in S1 will have a higher weight 
than a -0.1 slack in S4! Scenario 1 
Scenario 2 Scenario 3 
Scenario n 
Scenario 4 Scenario 5 Violation 1 
Violation 2 
Concurrent MCMM optimization works on all violations across all scenarios and as s uch 
eliminates the convergence problems observed in sequential approaches. Opt imization is 
performed for setup, hold, DRC, area, and power (leakage) . MCMM optimization utiliz es a 
concurrent costing engine, which ensures that every transformation is ac ceptable for all scenarios’
costs. 
As a result, the timing and constraint reports show worst case timing acr oss all scenarios. Timing 
analysis can be performed in one of two ways - a traditional min/max met hodology or via the 
PrimeTime-like early/late analysis approach utilizing the on-c hip variation (OCV) switch in the 
set_operating_conditions command. 

Multi Scenario Optimization 
IC Compiler 1 5-11 © 2009 
11 5-
set constraints 
create scenario 
set opcond 
set TLU+ 
set constraints 
create scenario 
set opcond 
set TLU+ MCMM / Scenario Setup 
/square6Setup falls into two parts: 
/circle6Global Setup 
Applies to all scenarios: 
/rhombus6target_library 
/rhombus6link_library 
/rhombus6(set_min_library) 
/circle6Scenario-specific setup 
For each scenario: 
/rhombus6set_tlu_plus_files 
/rhombus6set_operating_conditions 
/rhombus6Any SDC command (constraints) 
– set_case_analysis 
– create_clock 
– set_input_delay 
– …
set constraints 
create scenario 
set opcond 
optimize 
design setup 
analyze 
set TLU+ 
set_tlu_plus_files 
Each scenario must have TLU+ settings or an error is reported: 
Error: tlu_plus files are not set in this scenario s1. 
RC values will be 0. 
set_operating_conditions 
Each scenario must have operating conditions or a warning is reported: 
Warning: No operating condition was set in scenario  s1 (MV-021) 
Note: 
You need to ensure that the various constraint files do not contain any link or targe t_library 
statements, as these global variables will override each other. 

Multi Scenario Optimization 
IC Compiler 1 5-12 © 2009 
12 5-Defining Scenarios 
/square6Scenarios are created one after the other, each 
describing a mode and a corner 
/square6Example: We will define 4 scenarios, testing for 
functional and test mode, with setup and hold in th e 
worst and the best corner, using on-chip variation 
Functional Mode Worst 
PVT 
Setup, Hold Scenario 1 
Best 
PVT 
Setup, Hold Functional Mode Scenario 3 Test Mode Scenario 2 Worst 
PVT 
Setup, Hold 
Test Mode Scenario 4 Best 
PVT 
Setup, Hold = +
= +
= +
= +
If you have never used on-chip-variation, an explanation will follow. 

Multi Scenario Optimization 
IC Compiler 1 5-13 © 2009 
13 5-Global Setup 
/square6In our example, we use 2 libraries 
/circle6Worst: abclib_max.db:abclib_max, opcond: abc_wc 
/circle6Best: abclib_min.db:abclib_min, opcond: abc_bc 
/square6Set up “global variables”:
lappend search_path ../ref/db 
set target_library “abclib_max.db abclib_min.db”
set link_library “* abclib_max.db abclib_min.db \
ram_max.lib ram_min.lib ...”
/circle6In every scenario, IC Compiler has to be able to “map” t o the 
library and operating condition that is specified in t he “max”
corner – see scenario 4! /barb2right
Libraries have a library name and a file they come in. These don’t have to b e the same. 
Example: 
foo.db:stdcell 
bar.db:stdcell 
Here, we have two libraries with the same name, but they are in different f iles. IC Compiler can 
differentiate between the two, because the “full name” of the library cons ists of the file name, 
colon, library name. Of course, it is helpful to avoid same library names, as it c an be confusing to 
the user. 

Multi Scenario Optimization 
IC Compiler 1 5-14 © 2009 
14 5-Scenario-Specific Setup – S1 
create_scenario func_worst_corner 
read_sdc func_wc.sdc 
set_tlu_plus_files -max_tluplus abcmax.tlup \
-tech2itf_map abc_tlup.map 
set_operating_conditions \
-analysis_type on_chip_variation \
-max abc_wc \
-min abc_wc 
set_case_analysis 0 scan_en 
set_case_analysis 0 test_mode Both setup (max) and hold 
(min) use same wc 
operating condition! SDC constraints for functional 
mode under worst case. 
Setup functional mode Scenario 1 
Each scenario is initialized with create_scenario. 
To get a list of all defined scenarios, use all_scenarios .
To remove a scenario, use remove_scenario .

Multi Scenario Optimization 
IC Compiler 1 5-15 © 2009 
15 5-Scenario-Specific Setup – S4 
create_scenario test_best_corner 
read_sdc test_bc.sdc 
set_tlu_plus_files -max_tluplus abcmin.tlup \
-tech2itf_map abc_tlup.map 
set_operating_conditions \
-analysis_type on_chip_variation \
-max abc_bc \
-min abc_bc 
set_case_analysis 1 test_mode SDC constraints for test 
mode under best case. 
Setup test mode bc operating condition 
specified for “max”
(setup) analysis Scenario 4 
To test the chip under test conditions, test_mode is forced to 1, but scan_en remains 
unconstrained!  For every scenario defined, the slate is clean – no case analysis is active unless 
you set it. 

Multi Scenario Optimization 
IC Compiler 1 5-16 © 2009 
16 5-Switching between Scenarios 
icc_shell> all_scenarios 
func_max func_min test_max test_min 
icc_shell> current_scenario 
Current scenario is: test_min 
test_min 
icc_shell> report_case_analysis 
Pin name                           User case analys is value 
--------------------------------------------------- ------------- 
test_mode                          1 
icc_shell> current_scenario func_max 
Current scenario is: func_max 
func_max 
icc_shell> report_case_analysis 
Pin name                           User case analys is value 
--------------------------------------------------- ------------- 
scan_en                            0 
test_mode                          0 
Note: Concurrent analysis/optimization is 
always performed across all active 
scenarios, independent of current_scenario. !Scenario 1 
Scenario 3 Scenario 2 
Scenario 4 
You can also define more scenarios than you’re using. To activate a subset  of all the defined 
scenarios, use set_active_scenarios , which can be listed using all_active_scenarios .
Scenarios can be removed with the remove_scenario command. 
icc_shell> all_scenarios 
s1 s2 
icc_shell> remove_scenario -all 
Removed scenario 's2' 
Removed scenario 's1' 
icc_shell> all_scenarios 
icc_shell> 
write_parasitics 
Writes out parasitics (in SBPF format only) for the current _scenario: 
icc_shell> write_parasitics –format sbpf -output de s.sbpf 
save_mw_cel -scenario 
Allows for a design containing scenarios to be saved in Milkyway for mat: 
icc_shell> save_mw_cel -scenario s1 -as cel_s1 
Information: Saved design named cel_s1. (UIG-5) 
Multiple scenarios can also be saved: 
icc_shell> save_mw_cel -scenario {s1 s2} -as cel_s1 _s2 
Information: Saved design named cel_s1_s2. (UIG-5) 
If no scenario is specified, all scenarios are saved 

Multi Scenario Optimization 
IC Compiler 1 5-17 © 2009 
17 5-CTS Operates with One Scenario 
During CTS, a single scenario has to be chosen. 
create_scenario S1 
read_sdc S1.sdc 
create_scenario S2 
read_sdc S2.sdc 
... 
place_opt 
create_scenario CTS_scenario 
read_sdc CTS_scenario.sdc 
... 
set_cts_scenario CTS_scenario 
clock_opt / compile_clock_tree 
set_active_scenarios {S1 S2 …}
... 
route_opt MCMM setup 
Select a set of clocks that 
need to be synthesized 
along with constraints. 
Identify the scenario to be 
used for clock tree synthesis. 
Mark all optimization scenarios 
active except the CTS scenario 
before running route_opt 
Since applications for MCMM are commonly related to the clock tree it is  important to understand 
the flow impact as well as the current progress of MCMM within the CTS  context. One example 
of an application between MM (multi mode) and CTS is the case where the modes  of the clock 
tree (e.g. functional clocks vs. test clocks) are defined in separate sc enarios for their respective 
clocks. Another is when the designer wants to consider corner effects pos t-clock tree such as RC 
variation and timing shifts due to time dependent device reliability issue s. Normally the sets of 
scenarios between pre and post CTS are different and therefore need to be  redefined. 
Since currently CTS is limited to only use one scenario for its SDC clock cons traints this means 
there is a conflict with the optimization SDC settings for scenarios and f or SDC settings for the 
clock tree synthesis. This is a general issue and not specifically rela ted to MCMM but does impact 
the flow prescribed when both are used. Currently, IC Compiler's clock tre e synthesis does not use 
the SDC information across the multiple scenarios. 
Since CTS requires that the clocks are defined completely in the SDC t his is normally defined 
outside the scenario context in a CTS only SDC flow step. In addition, since the CTS  methodology 
in IC Compiler allows for either the mega command clock_opt or basic co mmands such as 
compile_clock_tree, we recommend that the basic commands are used only for t he MCMM flow . 
However note that the flow is still possible and requires a bit of dexterity w hen employing post 
CTS and routing optimizations with MCMM. 

Multi Scenario Optimization 
IC Compiler 1 5-18 © 2009 
18 5-Leakage Only Scenario 
/square6You can focus one scenario on leakage 
optimization only: 
/circle6You apply only the leakage optimization constraints
/circle6You significantly reduce the runtime and memory 
footprint as compared with other scenarios 
create_scenario LeakageOnlyScenario 
set_tlu_plus_files -tech2itf_map abc_tlup.map \
-min_tluplus los_min -max_tluplus los_max 
source -v -e leakage.sdc 
set_max_leakage_power 0 
set_scenario_options -leakage_only true 
This feature was added in 2007.03-SP3. 
When you use this command, only leakage optimization is performed in the specified sce nario; 
that is, no other optimizations, such as design rule constraints, timing, or area, ar e carried out in 
the scenario. 

Multi Scenario Optimization 
IC Compiler 1 5-19 © 2009 
19 5-MCMM Timing Analysis (1/3) 
report_qor 
/circle6Command is layered with info for each scenario 
**************************************** 
Report : qor 
Design : DESIGN1 
**************************************** 
Scenario 's1' 
Timing Path Group 'reg2reg' 
----------------------------------- 
Levels of Logic:              33.00 
Critical Path Length:        694.62 
Critical Path Slack:        -144.52 
Critical Path Clk Period:    650.00 
Total Negative Slack:      -4533.01 
No. of Violating Paths:      136.00 
----------------------------------- 
Scenario 's2' 
Timing Path Group 'reg2reg' 
----------------------------------- 
Levels of Logic:              33.00 
Critical Path Length:        393.61 
Critical Path Slack:          61.18 
Critical Path Clk Period:    500.00 
Total Negative Slack:          0.00 
No. of Violating Paths:        0.00 
----------------------------------- 
In MCMM, this command will report QOR metrics for each scenario created.

Multi Scenario Optimization 
IC Compiler 1 5-20 © 2009 
20 5-MCMM Timing Analysis (2/3) 
report_timing –scenario [all_scenarios] 
/circle6Command is layered with info for each scenario 
**************************************** 
Report : timing 
Design : DESIGN1 
**************************************** 
Startpoint: TEST_BUF2En 
Endpoint: TEST1/TEST2_SYN/latch_3 
Scenario: s1 
Path Group: clk 
Point                                       Incr       Path     Lib:OC 
--------------------------------------------------- ----------- 
clock clk (rise edge)                       0.00       0.00 
input external delay                      450.00     450.00 f 
…
/circle6If used without –scenario [all_scenarios] , 
report_timing will report on the current scenario 
In MCMM, this command will report timing on a per scenario basis. Currentl y, the only switch 
implemented is “-scenario [all_scenarios]” where all scenarios a re reported. 

Multi Scenario Optimization 
IC Compiler 1 5-21 © 2009 
21 5-MCMM Timing Analysis (3/3) 
report_constraint –scenario [all_scenarios] 
/circle6Report is layered with info for all active scenario
Weighted 
Group (max_delay/setup)      Cost     Weight     Co st    Scenario 
--------------------------------------------------- --------------
CLK                         10.07      1.00     10. 07    s1 
reg2reg                    171.16      1.00    171. 16    s1 
CLK                         90.60      1.00     90. 60    s2 
reg2reg                      0.00      1.00      0. 00    s2 
--------------------------------------------------- ------------------ 
max_delay/setup                               4404. 52 
Multi-Scenario 
Constraint                                       Co st 
--------------------------------------------------- --------------
max_transition                                  45. 28 (VIOLATED) 
max_fanout                                     150. 00 (VIOLATED) 
max_capacitance                                  0. 00 (MET) 
max_delay/setup                               4404. 52 (VIOLATED) 
critical_range                                4404. 52 (VIOLATED) 
min_delay/hold                                   0. 00 (MET) 
Constraints can be reported in a manner where each scenario’s constraints ar e reported along with 
the multi scenario costs using the –scenario scenario_list option. 
report_constraint -scenario scenario_list 
Reports constraints for given list of scenarios of a multiscenario design. I nactive scenarios 
will be skipped in the report. Each scenario is reported separately. If this op tion is not given, 
report_constraint will report constrinats on all active scenario exce pt -all_violators and -verbose 
option. With these two options and without the -scenario option, report_constraints will onl y report 
constraints on current scenario. 

Multi Scenario Optimization 
IC Compiler 1 5-22 © 2009 
22 5-How Much is Too Much? 
/square6Too many scenarios can lead to high memory and 
CPU demands 
/square6Reduce memory and runtime of analysis and  
optimization by identifying the dominant scenarios 
/circle6Create a subset of essential scenarios for optimiza tion 
get_dominant_scenarios -scenarios “s1 s2 …” 
Identify the set of essential or dominant scenarios
set_active_scenarios [get_dominant_scenarios] 
Automatically direct optimization to dominant scena rio subset 
The –scenarios option for get_dominant_scenarios is optional. If omitted, the defaul t is all 
scenarios. 

Multi Scenario Optimization 
IC Compiler 1 5-23 © 2009 
23 5-MCMM Scenario Reduction Analysis 
******************************************** 
Report : Scenario Reduction Violation Summary 
Design : design1 
Scenarios : 
Column 1 : scen1 (dominant) 
Column 2 : scen2 (dominant) 
Column 3 : scen3 (dominant) 
Column 4 : scen4 (dominant) 
Column 5 : scen5 
Column 6 : scen6 
******************************************** 
Violation: max delay, total: 4969 
# of violations:                          1585        2582    1912        1686           0           0
% of total violations:                 31.90       51.96    38.48       33.93        0.00        0.00 
# of unique violations:                   1580         916    241          21           0           0 
% of this scenarios violations:        99.68       35.48    12.60        1.25         N/A         N/A 
% of total violations:                 31.80       18.43    4.85        0.42        0.00        0.00 
# of critical violations:                    0        1664    1671        1665           0           0
% of this scenarios violations:         0.00       64.45    87.40       98.75         N/A         N/A 
% of total violations:                  0.00       33.49    33.63       33.51        0.00        0.00 
# of worst violations:                       5           2    0           0           0           0 
% of this scenarios violations:         0.32        0.08    0.00        0.00         N/A         N/A 
% of total violations:                  0.10        0.04    0.00        0.00        0.00        0.00 
# of dominating violations:               1585        2582    1912        1686           0           0
% of this scenarios violations:       100.00      1 00.00    100.00      100.00         N/A         N/A
% of total violations:                 31.90       51.96    38.48       33.93        0.00        0.00 
Largest violation:                       -2.86       -5.02       -7.16       -5.02         N/A         N/A 
.
.
.
Active set of scenarios are:  s1 s2 s3 s4 s5 s6 
Dominant set of scenarios are: s1 s2 s3 s4 
Reports max delay, min delay, DRC, leakage/dynamic/tota l power 1 2 3 4 5 6get_dominant_scenarios 
The command get_dominant_scenarios on its own will perform the analysis and issue the 
report seen on this slide - from this you can decide which scenarios you want to mak e active by 
using set_active_scenarios manually or in this case, you could use: 
set_active_scenarios [get_dominant_scenarios] 
So, in this slide we can see that the last two scenarios don't add any unique/crit ical/dominant 
violations and so these scenarios need not be optimized. 

Multi Scenario Optimization 
IC Compiler 1 5-24 © 2009 
24 5-MCMM High Capacity Flow 
/square6Can the dominant scenarios be identified 
automatically? 
set mcmm_enable_high_capacity_flow true 
/circle6Transparently invokes get_dominant_scenarios 
within the mega commands 
/circle6Default is false 
The variable mcmm_high_capacity_effort_level controls the effort level for scenario 
reduction, and is specified as a floating point value between 0 & 10. Default is  0 
What are the recommendations / risks in setting a large value for 
mcmm_high_capacity_effort_level ?
We are not recommending a particular value as such - although the defaul t (0) will carry out 
the ”100%” analysis - the analysis will account for ALL violations acros s all scenarios and 
consider dominance accordingly, but as such, this may not result in any scenario r eduction - for 
example, if a certain scenario contributes only a single ”soft” DRC (like m ax fanout) then this 
scenario will be retained and that may not be what the user wants. 
So, in certain instances the user may want to be more aggressive in his scen ario reduction 
approach and this variable will allow them to do so - But of course, if you're too aggressive you 
may not cover all your violations sufficiently and so what you'll gain in r untime you may lose in 
QOR. 
Q: Are setup vs. hold treated differently in determining dominant scenarios? 
A: Possibly, need to set_fix_hold to get the full view. 

Multi Scenario Optimization 
IC Compiler 1 5-25 © 2009 
25 5-To perform the most accurate timing analysis, 
and especially with PrimeTime sign-off in mind, 
what analysis type should you use: 
On-Chip Variation 
Best-case worst-case (bc_wc) Analysis Types 
?
?

Multi Scenario Optimization 
IC Compiler 1 5-26 © 2009 
26 5-Launch vs. Capture Path – Use Which Slew? 
U6 _RESET         
CLK1       
CLK2       FF1 
U1 U2 
U3 U7 FF2 
U4 U5 Worst 
PVT 
Launch Path 
Capture Path ?
?Two different input pin slews. Which slew gets propagated 
for U7 cell delay calculation? 
Which slew gets propagated 
for U4 cell delay calculation? Setup?  Hold? 

Multi Scenario Optimization 
IC Compiler 1 5-27 © 2009 
27 5-Setup is Optimistic in bc_wc 
/square6Since ‘worst case’ uses all slow delays, setup check s 
experience optimism in the following case: 
/square6Slow slew is propagated from mux output 
/square6Slow delays computed for U4 and U5 
/square6But fastest possible capture path is needed! 
/circle6Setup analysis is optimistic for paths captured by CLK1! U6 _RESET         
CLK1       
CLK2       FF1 
U1 U2 
U3 U7 FF2 
U4 U5 
The same applies to hold , because there the fast slews are used in both launch and capture paths, 
whereas you should have the fast slews on the launch, and the slow slews on the capt ure path. 

Multi Scenario Optimization 
IC Compiler 1 5-28 © 2009 
28 5-/square6On Chip Variation uses slow slews for the launch path, 
and fast slews for the capture path: 
/square6For hold, it’s the opposite: 
/circle6Fast slews for launch, slow slews for capture On Chip Variation Uses Safer Slews 
U6 _RESET         
CLK1       
CLK2       FF1 
U1 U2 
U3 U7 FF2 
U4 U5 Launch Path 
Capture Path 

Multi Scenario Optimization 
IC Compiler 1 5-29 © 2009 
29 5-Hold Setup Analysis Types Summary 
Propagate slow 
slew for launch 
and capture. 
Propagate fast 
slew for launch 
and capture. Propagate 
slow slew for 
launch path. Propagate 
fast slew for 
capture path. 
Propagate 
fast slew for 
launch path. Propagate 
slow slew for 
capture path. bc_wc on_chip_variation set_operating_conditions –analysis_type …
Optimistic Safe 

Multi Scenario Optimization 
IC Compiler 1 5-30 © 2009 
30 5-On-Chip Variation: Single Library 
create_scenario func_worst_corner 
set_operating_conditions 
-analysis_type on_chip_variation 
-max WORST -min WORST 
create_scenario func_best_corner 
set_operating_conditions 
-analysis_type on_chip_variation 
-max BEST -min BEST Delay 
Operating Conditions 
~ P / -V / T BEST WORST At the very least , use OCV 
with setup and hold using 
same operating condition 
in each corner. 
/barb2right/barb2right /barb2right/barb2rightSafer than bc_wc 
Setup Hold 
Launch uses –max (WORST) 
Capture uses –min (WORST) Launch uses –min (WORST) 
Capture uses –max (WORST) 
The graphs are a symbolic depiction of the summed effect of Temperature, Voltage and Process 
variation on Delay. If all 3 were to be plotted individually, the resulting pictur e would be 4-
dimensional. 

Multi Scenario Optimization 
IC Compiler 1 5-31 © 2009 
31 5-On-Chip Variation: Multiple Libraries 
create_scenario func_worst_corner 
set_operating_conditions 
-analysis_type on_chip_variation 
-max WORST -min WORST_ocv_min 
Setup Hold 
Launch uses –max (WORST) 
Capture uses –min (WORST_ocv_min) Launch uses –min (WORST_ocv_min) 
Capture uses –max (WORST) 
So in this example, for setup :
(slow) slews on the launch path are calculated using WORST 
(fast) slews on the capture path are calculated using WORST_ocv_min Most accurate: Setup and hold 
in each corner. 
2 separate calculated OCV  
libraries WORST_ocv_min Worst corner 
Best corner WORST 
Delay 
Operating Conditions 
~ P / -V / T BEST BEST_ocv_max 
The above shows that the –min and –max PVTs here are both used to calculate setup and hold. 
This is in contrast to bc_wc, where only the –max PVT is used for setup exclusivel y, and the –min 
PVT for hold.  
This would also mean that you should never use the slowest (e.g. at 125 degrees C) and fastest  
(e.g. -40 degrees C) PVTs available together when using on-chip variation, bec ause this is very 
unrealistic. The two PVTs should describe small temperature/voltage vari ations around the slow 
and fast corner respectively. The example on the next page illustrate s this. 
To complete the example from above: 
create_scenario func_best_corner 
set_operating_conditions 
-analysis_type on_chip_variation 
-max BEST_ocv_max -min BEST 

Multi Scenario Optimization 
IC Compiler 1 5-32 © 2009 
32 5-On-Chip Variation: Single Library + Derating 
Pessimistic but safe: 
Setup and hold in each corner. 
User-specified derating Derated delays WORST 
Derated delays 
BEST Delay 
Operating Conditions 
~ P / -V / T create_scenario func_worst_corner 
set_operating_conditions 
-analysis_type on_chip_variation 
-max WORST -min WORST 
set_timing_derate ... 
Setup Hold 
Launch uses –max (WORST) 
Capture uses –min (Derated WORST) Launch uses –min (Derated WORST) 
Capture uses –max (WORST) 
This completes the example: 
create_scenario func_worst_corner 
set_operating_conditions \
-analysis_type on_chip_variation \
-max WORST -min WORST 
set_timing_derate –min –late 0.9 
create_scenario func_best_corner 
set_operating_conditions \
-analysis_type on_chip_variation \
-max BEST -min BEST 
set_timing_derate –max –late 1.1 

Multi Scenario Optimization 
IC Compiler 1 5-33 © 2009 
33 5-Applying Derating Factors 
/square6If no operating conditions exist for corners you 
wish to check, you have to derate existing PVTs 
/square6Derating factors will scale the delay values 
/square6IC Compiler allows for global or specific derating:
/circle6Cells versus nets 
/circle6Launch path versus capture path 
/circle6Timing checks 
/circle6Library cells 
/circle6Early versus late 
Clk FF2 FF1 
Derating factors are applied after slew is chosen. 
set_timing_derate    # set_timing_derate 
[-min] (specify derating factor for min operating condition) 
[-max] (specify derating factor for max operating condition) 
[-early] (specify the maximum derating factor, default is 1.0) 
[-late] (specify the maximum derating factor, default is 1.0) 
[-clock] (specify the derating factors are to apply to clock paths only) 
[-data] (specify the derating factors are to apply to data paths only) 
[-net_delay] (specify the derating factors are to apply to nets only) 
[-cell_delay] (specify the derating factors are to apply to cell delays only) 
[-cell_check] (specify the derating factors are to apply to cell timing checks only) 
derate_value (timing derate factor) 
[object_list] (list of cells and/or designs). Applies globally if not set. 

Multi Scenario Optimization 
IC Compiler 1 5-34 © 2009 
34 5-Startpoint: FF1 (rising edge-triggered flip-flop clocked by Clk) 
Endpoint: FF2 (rising edge-triggered flip-flop clocked by Clk) 
Path Group: Clk 
Path Type: max 
Max Data Paths Derating Factor  : 1.100 
Point                                    Incr       Path 
---------------------------------------------------------- 
clock Clk (rise edge)                    0.00       0.00 
clock network delay (propagated)         1.10 *     1.10 
FF1/CLK (fdef1a15)                       0.00       1.10 r 
FF1/Q (fdef1a15)                         0.50 *     1.60 r 
U2/Y  (buf1a27)                          0.11 *     1.71 r 
. . . Global Derating versus Specific Derating 
report_timing 
Point                         Derate     Incr       Path 
---------------------------------------------------------- 
clock Clk (rise edge)                    0.00       0.00 
clock source latency                     0.00       0.00 
Clk (in)                                 0.00       0.00 r 
clk_iopad/I (pc3d01)           1.00      0.05 *     0.05 r 
clk_iopad/PAD (pc3d01)         1.00      0.95 *     1.00 r 
U1/A (buf1a27)                 1.00      0.01 *     1.01 r 
U1/Y (buf1a27)                 1.00      0.08 *     1.09 r 
FF1/CLK (fdef1a15)             1.00      0.01 *     1.10 r 
FF1/Q (fdef1a15)               1.10      0.40 *     1.50 f 
U2/A (buf1a27)                 1.10      0.01 *     1.51 f 
. . . report_timing –derate 

Multi Scenario Optimization 
IC Compiler 1 5-35 © 2009 
35 5-Unit Objectives Summary 
You should now be able to: 
/square6Describe the need for Multi-Corner and 
Multi-Mode analysis and optimization 
/square6Specify a scenario in IC Compiler 
/square6Describe the advantages of and 
how to use on chip variation 
/square6Analyze the design under all or 
some scenarios 

Multi Scenario Optimization 
IC Compiler 1 5-36 © 2009 
36 5-Lab 5: Multiple Scenario Optimization 
Apply multiple 
scenarios then perform 
placement, CTS and 
hold fixing, along with 
extensive timing 
analysis. 90 minutes 
Set up 3 scenarios 
Perform placement 
Add another test 
scenario, analyze 
Add and activate the 
CTS scenario 
Perform CTS 
Perform hold fixing 

Multi Scenario Optimization 
IC Compiler 1 5-37 © 2009 
Appendix 
Library Selection and Grouping 
TLU+ Files Support 
Resistance and Capacitance Scaling 
Coupling Caps across Scenarios 
TLU+ Temperature Scaling 
Delay Scaling with k-factors 

Multi Scenario Optimization 
IC Compiler 1 5-38 © 2009 
38 5-Link Libraries &  PVT Assumptions 
/square6When linking a cell instance to the appropriate 
library for the scenario, MCMM uses the PVT of the 
cell’s max operating condition defined in the 
scenario 
/circle6Finds first library cell which matches by type with  the 
matching PVT 
/circle6If no suitable cell found in any of the specified l ibraries: 
Error: cell TEST_BUF2En_BUF1/Z (inx4) is not characterized for 
0.950000V, process 1.000000, temperature -40.000000. (MV-001) 
The link_library lists all of the libraries that are to be used for linkin g the design for all scenarios. 
Furthermore, there may be several libraries (e.g. a standard cell  library and a macro library) that 
are intended to be used for linking a particular scenario. ICC will automat ically group the libraries 
in the link_library list into several sets, and identify the set that must be  used for linking a 
scenario. 
ICC uses the nominal process, voltage, and temperature (PVT) values of eac h library in order to 
group the libraries into different sets. Libraries with the same PVT val ues are grouped in to the 
same set. The PVT of a scenario’s max operating condition is used to select t he appropriate set. 
The set_operating_conditions command is a scenario specific command which spe cifies the 
operating condition that is to be used for the design (or a hierarchical instanc e in the design) in 
each of the scenarios. 
When linking a cell instance to the appropriate library cell for a sce nario, MCMM uses the 
process, voltage, and temperature of the max operating condition associated wi th that scenario. We 
find the first library cell which matches by type (i.e. AND2_4) in the set o f libraries with matching 
nominal process, voltage and temperature. 
If no suitable cell is found in any of the specified libraries, an error is r eported and the user must 
then verify the operating condtions and library setup – these errors must not be i gnored as they 
imply that no optimization will be carried out. 

Multi Scenario Optimization 
IC Compiler 1 5-39 © 2009 
39 5-Unique Identification Of Libraries 
/square6Two libraries with the same name can be uniquely 
identified by their filenames and library names: 
/circle6foo.db:stdcell vs. bar.db:stdcell 
/square6Two libraries with same file/library names cannot b e 
resolved if they reside in different directories: 
/circle6…/lib/fast/foo.db vs. …/lib/slow/foo.db 
Currently, two libraries with the same name (e.g. “stdcell”) can be uni quely identified by their file 
names and library names (colon separated). Therefore, library foo.db:stdce ll (where foo.db is the 
name of the library file, and stdcell is the name of the library) is unique ly identified from 
bar.db:stdcell. 
However, two libraries that have the same file name and library name, but re side in different 
directories, are not uniquely distinguishable, and therefore will lead to unexpected results. 
Example: 
• /remote/snps/testcase/LIB/fast/foo.db, and 
• /remote/snps/testcase/LIB/slow/foo.db 

Multi Scenario Optimization 
IC Compiler 1 5-40 © 2009 
40 5-Library Grouping 
create_scenario s1 
set_operating_conditions –max WORST \
–library Combo_cells_slow.db 
/circle6Nominal PVT was used to group libraries into 2 sets
/circle6The –max opcon selects the set, here Set 1 
/circle6So why should you know this? Set 1 
Set 2 Link Library (in order) Nominal PVT Opconds in library (PVT) 
Combo_cells_slow.db 1.2 / 0.85 / 130 WORST (1.2 / 0.85 / 130) 
Sequentials_fast.db 0.8 / 1.30 / 25 None 
Macros_fast.db 0.8 / 1.30 / 25 None 
Macros_slow.db 1.2 / 0.85 / 130 None 
Combo_cells_fast.db 0.8 / 1.30 / 25 BEST (0.8 / 1.30 / 25) 
Sequentials_slow.db 1.2 / 0.85 / 130 None 
The term “nominal” is not to be confused with “typical” in a min/typ/max sit uation.  Nominal here 
means the values the library was characterized at. The .lib file wil l have lines similar to the 
following: 
nom_voltage     : 1.080; 
nom_temperature : 125.000; 
nom_process     : 1.200; 
In most libraries there is only one operating condition defined, which refle cts the nominal values. 
Here is an example of a worst case library. 
operating_conditions("abc_min") { 
process :       1.200; 
temperature :   125.000; 
voltage :       1.080; 
tree_type :     "worst_case_tree"; 
}
default_operating_conditions :  abc_min 

Multi Scenario Optimization 
IC Compiler 1 5-41 © 2009 
41 5-Incorrect Library Selected 
create_scenario s1 
set_operating_conditions WORST –library lib2.db 
create_scenario s2 
set_operating_conditions WORST –library lib3.db 
create_scenario s3 
set_operating_conditions WORST –library lib1.db 
create_scenario s4 
set_operating_condition \
–max WORST –max_library lib2.db \
–min BEST  –min_library lib4.db 
In this example, cell instances in scenario s2 will not be linked to 
the library cells in lib3.db (as intended). They will be linked to 
library cells in the lib1.db library (assuming that all libraries 
include the library cells required to link the design) !Link Library Nominal PVT Opconds in library (PVT) 
1. lib1.db 1 / 1.30 / 100 WORST (1 / 1.30 / 100) 
2. lib2.db 1 / 0.85 / 100 WORST (1 / 0.85 / 100) 
3. lib3.db 1 / 1.30 / 100 WORST (1 / 1.30 / 100) 
4. lib4.db 1 / 0.85 / 100 BEST (1 / 0.85 / 100) set link_library “* lib1.db lib2.db lib3.db lib4.db ”
If the max libraries associated with each corner (scenario) do not have di stinct PVT’s, then cell 
instances will be linked incorrectly, and you will observe incorrect tim ing values. 
When IC Compiler searches for cells, it searches through the link_library  from left to right, and 
stops once it finds the cell with the correct PVT. 

Multi Scenario Optimization 
IC Compiler 1 5-42 © 2009 
42 5-MCMM Supports up to 3 TLU+ Files 
/square63 TLU+ files are allowed per IC Compiler run 
/square6Assume tlupA, tlupB and tlupC 
/circle6Scenario S1 can reference tlupA and tlupB 
/circle6Scenario S2 can reference tlupA and tlupC 
/circle6Scenario S3 can reference tlupB and tlupC 
/circle6…Any combination of A, B and C is valid 
/square6Every one of the 3 TLU+ can have its resistance  
scaled using the operating condition, and this can 
be different for every scenario 

Multi Scenario Optimization 
IC Compiler 1 5-43 © 2009 
43 5-Scaling Resistance and Capacitance 
/square6You can scale resistance, capacitance, and 
coupling capacitance on a per scenario basis 
using: 
set_extraction_options 
-max / -min_res_scale 
-max / -min_cap_scale 
-max / -min_ccap_scale 
/square6To check the scaling settings, use 
report_extraction_options 
/square6After you specify the scaling values, you should ru n 
the extract_rc command to see the effect of 
scaling on the design’s parasitics. 

Multi Scenario Optimization 
IC Compiler 1 5-44 © 2009 
44 5-Filtering Coupling Capacitances 
/square6IC Compiler supports coupling capacitance filtering  across 
scenarios. 
/square6After defining each scenario along with its TLUPlus  files and 
operating conditions: 
set_si_options -delta_delay true 
route_opt 
extract_rc -coupling_cap 
report_timing -scenario [all_scenarios] 
/square6The route_opt command will take into account coupling 
capacitance effects across the nets. In multicorner -multimode 
flows, the tool’s extraction engine generates the p arasitics per 
corner from the TLUPlus and operating conditions pa ir values. 

Multi Scenario Optimization 
IC Compiler 1 5-45 © 2009 
45 5-TLU+ Temperature Scaling 
/square6If temperature derating parameters are specified in 
the TLU+ file, IC Compiler will use the operating 
temperature from the logical library (db) operating 
condition to scale resistance 
/square6Temperature Scaling of Resistance 
/circle6TLU+ (ITF) must contain 
TECHNOLOGY = 90nm_lib 
GLOBAL_TEMPERATURE = 105.0 
CONDUCTOR metal8 {THICKNESS = 0.8000…
CRT1 = 4.39e-3 CRT2 = 4.39e-7 (optional) 
…
/circle6Generate TLU+ with latest grdgenxo 
/square6If no parameters exist, no scaling is (can be) 
performed. 
To allow for temperature derating, the TLU+ must contain the GLOBAL_TEMPERATURE , CRT1 
and (optionally) CRT2 variables. 
For detailed information on these parameters, see the Interconnect Technol ogy Format File 
documentation on solvnet: 
https://solvnet.synopsys.com/dow_retrieve/Y-2006.09/strm/strm_2.html 
The TLU+ file settings, (accomplished via the set_tlu_plus_files command) must be 
made explicitly in each scenario – if the TLU+ setup is not correct, an e rror is issued: 
Error: tlu_plus files are not set in this scenario s1. RC values will be 0. 
Similarly, the design’s operating condition(s) must also be set with in each scenario – if this is not 
defined, an MV-021 warning issued: 
icc_shell> create_scenario s1 
Warning: Any existing scenario-specific constraints  are discarded. (MV-020) 
icc_shell> report_timing 
Warning: No operating condition was set in scenario  s1 (MV-021) 
icc_shell> set_operating_conditions SLOW_95 –lib max_v95_t125 

Multi Scenario Optimization 
IC Compiler 1 5-46 © 2009 
46 5-No Delay Scaling with k-factors in MCMM 
/square6k-factors are used in some libraries to scale the 
delays in a linear fashion, in order to model the 
effect of PVT 
/circle6This is not considered to be accurate any longer, s ince 
delays don’t scale linearly across all cells in mod ern 
libraries 
/square6k-factor scaling is not supported for MCMM 
/circle6Operating condition specified for each scenario mus t 
match the nominal operating condition for one of th e libs 
in the link_library list 
ICC concurrent multi-corner does not support k-factor scaling. This implies t hat the operating 
condition that is specified for each scenario must match the nominal operati ng condition for one of 
the libraries in the link_library list. 

Routing and Crosstalk 
IC Compiler 1 6-1© 2009 16-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 DAY 
33 33
Multi Scenario Optimization 5
Routing and Crosstalk 6
Chip Finishing and DFM 7
Customer Support CS 

Routing and Crosstalk 
IC Compiler 1 6-2© 2009 26-Unit Objectives 
After completing this unit, you should be able to: 
/square6Explain what each of the four Routing 
Operations accomplishes 
/square6Route the design 
/square6Perform optimizations to improve routing and  
optimize timing 
/square6Analyze and fix crosstalk violations 
/square6Perform functional ECOs 

Routing and Crosstalk 
IC Compiler 1 6-3© 2009 36-IC Compiler Flow 
Synthesis 
Unit 1 
Unit 3 
Unit 4 
Unit 6 
Unit 7 Unit 2 Design Setup 
Design Planning 
place_opt 
clock_opt 
route_opt 
Chip Finishing /checkbld/checkbld /checkbld/checkbld
/handptright/handptright /handptright/handptright/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Routing and Crosstalk 
IC Compiler 1 6-4© 2009 46-Design Status, Start of Routing Phase 
/square6Placement - completed 
/square6CTS – completed 
/square6Power and ground nets - routed 
/square6Estimated congestion - acceptable 
/square6Estimated timing - acceptable (~0ns slack) 
/square6Estimated max cap/transition – no violations 
extract_rc 
report_constraints -all 
Congestion, timing and max cap/transition are estimated based on virtua l route or a throw away 
global route. 

Routing and Crosstalk 
IC Compiler 1 6-5© 2009 56-Pre-Route Checks 
/square6Check design for routing stage readiness 
/square6There should not be: 
/circle6Ideal nets 
/circle6High fanout nets greater than 500 
/square6Use check_routeability to check a 
design’s prerequisites for detail routing 
and report a list of violations 
Fix before 
performing 
detail routing 
check_physical_design –stage pre_route_opt 
all_ideal_nets 
all_high_fanout -nets -threshold 501 
check_routeability 
The first command shown checks whether the design is ready for routing. T he following details 
are checked: 
• the design is placed and legalized 
• power/ground pins are connected to nets 
• -verbose option shows even more 
If high fanout (>500) exist, you should remove ideal net attribute if needed and then a dd buffer 
tree prior to routing the design. 
check_routeability 
Checks pin access points, cell instance wire tracks, pin out of boundaries, min-grid a nd pin design 
rules and blockages to ensure they meet the design requirements. It per forms a check of the design 
for optimization in order to substantiate any errors in the design that mi ght need to be fixed or 
what could help to improve the design. This must currently be run on a placed design. 
You can use this command at every stage between placement and detail routing. V erify errors in 
the generated error cell or log file. 
You may have to perform manual fixes, as these problems may relate to libra ry problems or issues 
with the floorplan. 

Routing and Crosstalk 
IC Compiler 1 6-6© 2009 66-Routing Fundamentals: Goal 
Routing creates physical connections to all clock a nd 
signal pins through metal interconnects 
/square6Routed paths must meet setup and hold timing, 
max cap/trans, and clock skew requirements 
/square6Metal traces must meet physical DRC requirements 

Routing and Crosstalk 
IC Compiler 1 6-7© 2009 76-Grid-Based Routing System 
/square6Metal traces (routes) are built 
along, and centered upon 
routing tracks based on a grid 
/square6Each metal layer has its own 
grid and preferred routing 
direction: 
/circle6M1: Horizontal 
/circle6M2: Vertical, etc…
/circle6Report by: 
Track Pitch Grid Point 
M1 Trace 
M2 
unitTile 
report_preferred_routing_direction 
The preferred routing direction guides IC Compiler to route as much of ea ch trace as possible in 
either an East-West or North-South direction. Some jogs in the non-preferred di rection are 
possible. 
The tracks and preferred routing directions are defined in a "unitTile" c ell in the standard cell 
library 

Routing and Crosstalk 
IC Compiler 1 6-8© 2009 86-Routing over Macros 
/square6By default IC Compiler will: 
/circle6Route over macros 
/circle6Not route where there is 
a routing blockage 
/circle6Not route through a narrow 
channel in the non-preferred 
routing direction 
You need to change the preferred routing direction!M1- M4 Routing Blockage 
M1- M4 Routing Blockage 
Macro M1- M3 Routing Blockage 
M4 has a horizontal routing channel but 
its preferred routing direction is vertical. 
There could be situations where you have to route over a macro in the non-preferr ed direction. For 
example, you have a macro that has blockages completely over metal 1, 2 and 3 wi th some 
channel space for the top most metal layer M4 and the preferred direction f or M4 is opposite to the 
direction of the channel. A non-preferred direction routing would help to utiliz e the M4 routing 
resource over the macro and avoid congestion problems; however, by default IC Com piler will not 
route over the empty channel in the non-preferred direction. 

Routing and Crosstalk 
IC Compiler 1 6-9© 2009 96-
M1- M4 Routing Blockage 
M1- M4 Routing Blockage 
Macro Change the Preferred Routing Direction 
Use Route Guide to change the 
preferred routing directions 
Select this option to change the 
preferred routing direction for an area. 
Specify the area in which to change 
the routing direction 
GUI: Floorplan /barb2right/barb2right /barb2right/barb2rightCreate Route Guide …
In this example, the preferred direction for M4 at the top-level is "Verti cal" and the macro has to 
be placed without rotating. A solution for this kind of situation would be to use a route gui de over 
the channel at the top-level. 
Command-line syntax: 
create_route_guide -name route_guide_1 \
-coordinate {{0.000 0.000} {300.000 300.000}} \
-switch_preferred_direction 
The route guide could also be created in the .FRAM view of the macro if al l of its instantiations 
are placed with the same orientation. The above technique can be used for any d esign that has 
limited routing resources and space in the preferred direction and also has som e empty channel 
space down the hierarchy that falls in the non-preferred direction at the top- level. 

Routing and Crosstalk 
IC Compiler 1 6-10 © 2009 10 6-Routing Operations 
/square6IC Compiler performs: 
/circle6Global Routing 
/circle6Track Assignment 
/circle6Detail Routing 
/circle6Search and Repair 
/square6After global routing, track 
assignment and detail routing all clock/signal nets  
will be completely routed and should meet all 
timing, and most all DRC, requirements 
/square6Any remaining DRC violations can be fixed by 
Search&Repair Track Assign Global Route 
Detail Route 
Search&Repair 
Note: This unit assumes a moderate design challenge. By definition this i mplies that all timing 
requirements will be met at the end of Search&Repair. There are additiona l optimizations that can 
be performed but they would be beyond the scope of this workshop.

Routing and Crosstalk 
IC Compiler 1 6-11 © 2009 11 6-Route Operations: Global Route 
global route 
congestion area /square6GR assigns nets to specific metal layers and 
global routing cells (Gcells) 
/square6GR tries to avoid congested Gcells while 
minimizing detours: 
/circle6Congestion exists when more tracks 
are needed than available 
/circle6Detours increase wire length (delay) 
/square6GR also avoids: 
/circle6P/G (rings/straps/rails) 
/circle6Routing blockages 
Metal traces exist after Global Route. True or Fals e? 


Routing and Crosstalk 
IC Compiler 1 6-12 © 2009 12 6-
Route Operations: Global Route Summary 
Global 
route Global 
route Preroute Preroute Answer: False! 
GR does not lay 
down any metal 
traces. 

Routing and Crosstalk 
IC Compiler 1 6-13 © 2009 13 6-
Route Operations: Track Assignment 
/square6Track Assignment (TA): 
/circle6Assigns each net to a 
specific track and lays 
down the actual metal 
traces 
/square6It also attempts to: 
/circle6Make long, straight traces 
/circle6Reduce the number 
of vias 
/square6TA does not check or 
follow physical DRC 
rules TA metal 
traces TA metal 
traces 
Preroute Preroute Jog reduces 
via count 
If track assignment can reduce the number of jogs and jumps in metal traces , this will generally 
improve timing (since each jump generally requires a via to jump to a higher  or lower level metal 
layer). Reducing the number of vias is generally a plus for reliabili ty and yield since their failure 
rate is slightly higher than that of a simple, straight metal track i n a modern, planarized process. 
Some additional DRC rules: 
Wire spacing 
Wire width 
Via rules (size, density, stackable etc…)Example of possible DRC violations after Track Assign 
Spacing violation 
Notch violation 

Routing and Crosstalk 
IC Compiler 1 6-14 © 2009 14 6-/square6Detail route attempts to clear DRC violations using  a 
fixed size Sbox 
/square6Due to the fixed Sbox size, detail route may not be  
able to clear all DRC violations Route Operations: Detail Routing 
Detail Route SBoxes 
Min 
Spacing Thin&Fat 
Spacing Notch 
Spacing 
Notch 
Spacing 
Detail route is concerned with fixing all the DRC violations after Tr ack Assignment. The detail 
router does not work on the entire chip at the same time like Track Assignment .  Instead it works 
by rerouting within the confines of a small area called an “SBox”. I t traverses the entire design box 
by box until the routing pass is complete. The router takes two passes through t he chip using a 5x9 
followed by a 9x5 GRC-sized SBox.  (GRC = Global Routing Cell) 
Sign-off DRC verification uses a complete set of design rules (like a H ercules runset). The 
technology file contains a subset of these design rules which will be used by  the Detail Router and 
Search&Repair operations. See example below. Modern processes may def ine additional 
width/space rules for “fat” wires. 
Layer "METAL3" { 
...... 
minWidth = 0.20 
minSpacing = 0.21 
pitch = 0.41 
...... 
fatTblDimension = 4 
fatTblThreshold = (  0, 0.39, 2.0, 10  ) 
fatTblSpacing = ( 0.21, 0.24, 0.28, 0.6, 
0.24, 0.24, 0.28, 0.6, 
0.28, 0.28, 0.28, 0.6, 
0.6, 0.6, 0.6, 0.6  ) 

Routing and Crosstalk 
IC Compiler 1 6-15 © 2009 15 6-/square6Search&Repair fixes remaining DRC violations throug h 
multiple loops using progressively larger SBox size s 
Note: Even if the design is DRC clean after S&R, yo u 
must still run a sign-off DRC checker (Hercules). 
/circle6Routing DRC rules are a subset of the complete tech nology 
DRC rules 
/circle6IC Compiler works on the FRAM view, not the detaile d 
transistor-level (CEL) view Route Operations: Search&Repair 
Loop1 Loop2 Loop3 Loop4 
Search and Repair divides the chip into SBoxes and works through each SBox sequentia lly trying 
to fix DRC violations by rerouting within the confines of the box. 
Search and Repair starts with smaller boxes. Since changes to the routes  are bounded by the small 
box it causes only minimum disruption to existing routes, but timing might suffer.  
Remaining DRC violations are addressed by another pass using a large r size SBox. The larger box 
potentially gives more routing resources to clear violations, but at the cost of moving routes farther 
away from ideal. This may effect the timing more significantly  than the first pass fixes. 
You can control the number of loops over the chip, but you have no simple control over the si ze of 
the SBoxes. 
If DRC violations cannot be cleared in ~50 S&R loops: 
Check the GR congestion map. 
If the DRC violations are located in congested areas, you need to fix the co ngestion first by:
• Manipulating routing obstructions 
• Changing the floorplan 
Check the log file for warnings about "unreachable pins" and fix as needed ( see the Appendix) 

Routing and Crosstalk 
IC Compiler 1 6-16 © 2009 16 6-Test for Understanding 
1. What does Global Routing do in congested areas? 
2. Assignment of nets to metal layers is done during t he 
Track Assignment stage.  T or F? 
3. When does IC Compiler use SBoxes?  Are they 
always the same size? 
4. Does IC Compiler find all the DRC violations, makin g 
a Hercules or other sign-off level DRC extraction r un 
unnecessary? 
5. Will IC Compiler route a metal trace in the “non-
preferred” direction? 1. It routes around the congestion by moving nets out of congested gcells to less conges ted gcells. 
This can result in a slight degradation of net timing due to the non-ideal, longe r route path. 
2. False. This is done during Global Route. 
3. During detail route and S & R.  Size is fixed for DR and changes for each  S & R loop.  S box 
sizes vary from design to design, and are not controllable by the user. 
4. No!  It looks only at place and route related (FRAM-level) rules.  There may  be issues within 
macros or std cells related to polysilicon, diffusion, contacts, n-wells, etc. w hich are not visible 
to IC Compiler. 
5. Not as a rule but you may see a "jog" now and again. 

Routing and Crosstalk 
IC Compiler 1 6-17 © 2009 17 6-General Flow for Routing 
Design for 
Manufacturability Route Clock Nets Placement & CTS 
Optimize Route Signal Nets 

Routing and Crosstalk 
IC Compiler 1 6-18 © 2009 18 6-Set Routing Options Prior to Routing Steps 
Options are saved in 
the Milkyway CEL 
set_route_options \
-track_assign_timing_driven true \
-same_net_notch check_and_fix \
-wire_contact_eol_rule check_and_fix 
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld/square6Enable timing-driven track 
assignment 
/square6Enable “check and fix” for: 
/circle6Check same net notch 
/circle6Wire/Contact end of the line 
rule 
GUI: Route /barb2right/barb2right /barb2right/barb2rightSet Route Options …

Routing and Crosstalk 
IC Compiler 1 6-19 © 2009 19 6-
Route Clock Nets First 
… if not already routed during clock_opt !
/checkbld/checkbld /checkbld/checkbldRoute all clock 
nets at once! Route Clock 
Nets 
Route Signal 
Nets 
Optimize 
This will give the clocks free rein. If all nets were rout ed together, 
clocks would not have any particular priority over other n ets. !route_group -all_clock_nets 
Route /barb2right/barb2right /barb2right/barb2rightNet Group Route …
All of the clocks are identified by the SDC create_clock and create_ generated_clock commands. 

Routing and Crosstalk 
IC Compiler 1 6-20 © 2009 20 6-route_opt 
-effort  low | medium | high 
-stage  global | track | detail 
-power 
-xtalk_reduction 
-initial_route_only 
-skip_initial_route 
-incremental 
-num_cpus NCore Routing: route_opt 
All in One: 
/square6global, track, and detail routing, S&R, logic and 
placement optimizations with ECO routing 
/square6End goal: Design that meets timing, crosstalk 
and route DRC rules Route Clock 
Nets 
Route Signal 
Nets 
Optimize 
Use –size_only to do only size operations. You have refined control via the -effort switch: 
-effort low : route_opt –size_only will only run footprint optimization 
-effort medium : route_opt –size_only will run in_place optimization 
-effort high : route_opt –size_only will run complete size_only optimizations 
When –size_only is specified, the freedom of the ecoRouter is also limited 
Do not confuse –incremental with –skip_initial_route 
/barb2rightUse –skip_initial_route to run the identical route_opt flow, after having routed the design 
outside of route_opt 
E.g. when first running route_auto, and maybe manually editing some wires, proceed w ith 
route_opt –skip_initial_routing 
route_opt = route_auto + route_opt –skip_initial_ro ute 
/barb2rightUse route_opt –inc when you want to incrementally improve the QoR of your design after 
running route_opt earlier. This will only run 1 loop of optimization. 
The initial_route_only option causes route_opt to stop after performing routing, it will not per form 
route optimizations. You can use this option in conjuntion with the –stage option to control up-to what 
stage to route. For example, route_opt -initial_route_only -stage global will only run 
global routing. 
In order to use the –num_cpus option, you have to first setup IC Compiler routing for m ultiple CPUs using 
the command set_distributed_route. You can use LSF as well as directly s pecify host names. 

Routing and Crosstalk 
IC Compiler 1 6-21 © 2009 21 6-First route_opt Example 
/square6Instead of running a full routing and post-route 
optimization, perform the initial route (global 
routing, track assignment, detail routing, and 
search and repair) to start out with: 
route_opt –initial_route_only route_opt –initial_route_only 
The -initial_route_only option runs global routing, track assignment, detail routing, and 
search and repair. It does not run the post-route optimization. 

Routing and Crosstalk 
IC Compiler 1 6-22 © 2009 22 6-Perform Initial Redundant Via 
/square6To get optimal double via rate, perform first a non -
timing driven double via insertion 
insert_redundant_vias -auto_mode preview 
insert_redundant_vias -auto_mode insert \
-num_cpus $ICC_NUM_CPUS 
/circle6Later on, during chip finishing, you will execute a  Timing 
Driven double via insertion 
insert_redundant_vias -auto_mode preview 
insert_redundant_vias -auto_mode insert \
-num_cpus $ICC_NUM_CPUS 

Routing and Crosstalk 
IC Compiler 1 6-23 © 2009 23 6-Post Route Optimization Examples 
/square6If post route optimization is needed 
route_opt –skip_initial_route \
-effort low -power 
route_opt –skip_initial_route \
-effort high –incremental \
–only_design_rule 
route_opt -optimize_wire_via \
-effort low \
–xtalk_reduction 
These are examples that you can run after you have analyzed the desi gn. 


Routing and Crosstalk 
IC Compiler 1 6-24 © 2009 24 6-Core Routing Strategy 
/square6The operations inside route_opt can be fine tuned 
using the command:  
set_route_opt_strategy 
/circle6Increase the number of 
/rhombus6Xtalk reduction and xtalk S&R loops 
/rhombus6Search & Repair and ECO route loops 
/rhombus6Optimize wire/via loops 
/circle6Set a runtime limit 
/circle6When to run hold time fixing 
-fix_hold_mode all | route_base 
Specifies when to fix hold inside route_opt. Inside route_opt, there are three diff erent stages to 
fix hold: pre_route, global route, detail route. With the mode all, route_opt will per form hold 
fixing with all three stages. With the mode route_base, route_opt will run only g lobal route and 
detail route based hold fix optimization. 
For a detailed list of options, refer to the man page:  man set_route_opt_strategy 


Routing and Crosstalk 
IC Compiler 1 6-25 © 2009 25 6-Analysis of the Routing DRC Errors 
verify_route Uses router DRC engine 
verify_drc Uses Hercules for DRC 


Routing and Crosstalk 
IC Compiler 1 6-26 © 2009 26 6-Fixing DRC Violations 
Use route_opt (fixes timing as well): 
route_opt -incremental Min 
Spacing Thin&Fat 
Spacing Notch 
Spacing 
Notch 
Spacing 
You can also run search and repair stand-alone: 
route_search_repair # run search and repair routing operations 
[-loop int] (number of s&r loop: Range 0 to 1000, default is 50) 
[-run_time_limit time] (cpu run time limit minutes, default is no limit) 
[-reset_width] (reset to default width) 
[-rerun_drc] (before starting s&r run the design rule checker) 
[-reset_min_max_layer] (reset min max layer setting) 
[-trim_antenna_of_user_wire] (trim wire segments of prerouted wires) 
[-dont_connect_tie_off] (do not connect pg or clock) 
[-ignore_open_nets] (do not connect partially routed wire segments) 

Routing and Crosstalk 
IC Compiler 1 6-27 © 2009 27 6-
PostRoute Delay Calculation Algorithms 
/square6After routing, detailed nets are available and 
extraction can be more accurate 
/square6By default, Elmore is still used 
/square6Arnoldi can be turned on for postroute calculations Detailed Route 
The default delay calculation algorithm in IC Compiler is Elmore.
To turn on the more accurate Arnoldi algorithm, use: 
set_delay_calculation -arnoldi 

Routing and Crosstalk 
IC Compiler 1 6-28 © 2009 28 6-Test for Understanding 
1. What are the 4 routing operations that 
route_opt performs? 
2. What happens if route_opt is invoked before clock 
nets are routed?  Why is this not recommended? 
3. When is it appropriate to do more Search&Repair? 
4. Does route_opt automatically fix cross talk 
problems? 1. Global routing, track assignment, detail routing, search & repair. 2. The clock nets would be routed at the same time as signal nets. Clock net s would have to 
compete with all other signal nets for routing resources, resulting in pos sibly less than ideal 
clock skew. 
3. After Detail route, to fix remaining DRC violations, or anytime routing  is modified thereafter, 
e.g. ECO Route. 
4. No, route_opt  –xtalk_reduction will include xtalk processing. 

Routing and Crosstalk 
IC Compiler 1 6-29 © 2009 29 6-Galaxy Crosstalk 
Crosstalk prevention 
Crosstalk correction 
Crosstalk sign-off Watch for macro placement 
congestion and utilization 
Congestion minimization, 
max_trans constr. 
NDR on clocks 
GR/TA with “Crosstalk 
Prevention” option 
Post Route Crosstalk 
optimization 
Repair flow IC Compiler 
PrimeTime-SI Star-RCXT Crosstalk Prevention 
Crosstalk Correction 
NDR – Non-Default Routing rule (variable route rules in Astro router) 

Routing and Crosstalk 
IC Compiler 1 6-30 © 2009 30 6-Cc What is Crosstalk? 
Static victim Switching victim Aggressor 
Victim net 1 
net 2 Aggressor Crosstalk is the transfer of a voltage transition from one 
switching net (aggressor) to another static or swit ching 
net (victim) through a coupling capacitance (Cc) 

Routing and Crosstalk 
IC Compiler 1 6-31 © 2009 31 6-Cc Crosstalk-Induced Noise (aka Glitches) 
Aggressor nets can create crosstalk-induced noise on 
static victim nets, also called “static noise”
Aggressor 
Victim 
“Static noise”net 1 
net 2 

Routing and Crosstalk 
IC Compiler 1 6-32 © 2009 32 6-Cc Crosstalk-Induced Delay 
Aggressor/victim nets with overlapping timing windo ws can cause 
“crosstalk-induced delay” on victim nets. 
This can lead to a speed-up or a slow-down of the v ictim net 
Aggressor 
Victim 
Delay net 1 
net 2 

Routing and Crosstalk 
IC Compiler 1 6-33 © 2009 33 6-Crosstalk Prevention in IC Compiler 
/square6During placement and optimization : 
/circle6set_max_transition 
/circle6set_congestion_options …
/circle6area_recovery_critical_range and 
power_recovery_critical_range 
/rhombus6Recommendation:  15% of main clock period 
/square6During CTS: 
/circle6Use of Non-Default Routing rules – e.g. double-spaci ng 
define_routing_rule my_route_rule -spacings {…}
set_clock_tree_options [–clock CLK]  \
-routing_rule my_route_rule 
/square6During Global Route and Track Assign : 
set_si_options – delta_delay true \
-route_xtalk_prevention true 
Non-default rules can be specified for width, spacing, shielding, min/max la yer, and special via cut 
with the following commands. 
• define_routing_rule 
• set_net_routing_rule 
• set_net_routing_layer_constraints 
• set_clock_tree_options –routing_rule 
• preroute_standard_cells –use_special_via_rule 
e.g. a non-default routing rule can also be applied to critical nets using: 
set_net_routing_rule -rule MYRULE  [get_nets CRITIC AL*] 
Non-default rules can be specified before place_opt, clock_opt or route_opt comma nds because 
they are honored by each engine. They are stored in the Milkyway databa se. Users can report 
NDRs by using: 
• report_routing_rules 
• report_net_routing_rules 
Or remove them by using: 
• remove_routing_rules 

Routing and Crosstalk 
IC Compiler 1 6-34 © 2009 34 6-Crosstalk Correction in IC Compiler 
/square6IC Compiler addresses both XDD (crosstalk delta 
delay) and Static Noise 
/square6Crosstalk correction performs both cell-based and 
route-based optimization (i.e. optimizes gate 
placement, gate logic, and routing traces) 

Routing and Crosstalk 
IC Compiler 1 6-35 © 2009 35 6-Example Full Crosstalk Flow 
place_opt 
set_clock_tree_options -max_transition 0.2 -max_fan out 32 
set_clock_tree_references -reference $CLK_BUFFER_LI ST 
define_routing_rule MYRULE -spacings {M2 0.28 M3 0. 28…}
set_clock_tree_options -routing_rule MYRULE 
clock_opt 
set_si_options -route_xtalk_prevention true \
-route_xtalk_prevention_threshold  0.35 \
-delta_delay true \
-static_noise true \
-static_noise_threshold_above_low  0.3 \
-static_noise_threshold_below_high 0.3 
route_opt -xtalk_reduction 
Optional: -optimize_wire_via –wire_size 
report_noise 
report_timing -crosstalk_delta Default: 0.35 
Unit is % Prevention 
target more 
aggressive 
Default: 0.45 
Unit is Volt. 
set_si_options 
-route_xtalk_prevention TRUE|FALSE 
-route_xtalk_prevention_threshold  <float V> 
Xtalk aware Global Route / Track-Assign 
-delta_delay TRUE|FALSE 
-static_noise TRUE|FALSE 
-static_noise_threshold_above_low  <float %> 
-static_noise_threshold_below_high <float %> 
NOTE: 
The unit for the static_noise_threshold_above_* options has changed with version 
2007.03-SP1. The values are now a percentage of the voltage, instead of absolute 
voltages. 
report_si_options 
Static Noise Thresholds : 
0.3 (0.49V) above low 
0.3 (0.49V) below high !

Routing and Crosstalk 
IC Compiler 1 6-36 © 2009 36 6-Xtalk-Reduction at Work 
Nets are spaced and 
can switch to different 
layers to reduce Xtalk 
without adding cells 

Routing and Crosstalk 
IC Compiler 1 6-37 © 2009 37 6-Wire Sizing (Aka Applying NDRs) 
/square6IC Compiler will apply the NDRs to violating nets i f this 
reduces the timing violations (e.g. double spacing rule 
for Xtalk or double width if R is dominant) 
/square6IC Compiler will use all NDRs that are defined in t he 
design (with define_routing_rule), unless certain r ules 
are defined as dont_use using: 
set_routing_rule_dont_use "rule1 rule2 …"route_opt –wire_size 
NDRs are honored during ECO routes as well (e.g. route_eco) 

Routing and Crosstalk 
IC Compiler 1 6-38 © 2009 38 6-Wire Sizing at Work 
/square6Critical wire has been made wider to solve a timing  
violation. Since R is reduced, it can benefit the 
timing. The wider spacing helps crosstalk. 
/square6Use with care, since too many NDRs can make the 
design unrouteable 
Wider spacing Timing improves on 
the paths through 
this wider net. 

Routing and Crosstalk 
IC Compiler 1 6-39 © 2009 39 6-ECOs: Making Changes Late in the Flow 
Functional changes occur late in the design cycle 
Deleted 
cell Added 
cells 
“ECO” is an old term which stands for “engineering change order”. In the  early days of circuit 
design, if a change needed to be made to a part of the design that was alrea dy defined or specified, 
you would fill out an “Engineering Change Order” form and have it signed of f before making the 
change. Even though most companies no longer use ECO forms, the term is still  used, and refers to 
design changes late, or near the end of the design phase. 

Routing and Crosstalk 
IC Compiler 1 6-40 © 2009 40 6-The Two Types of ECO Flows 
ECO netlist 
Placement 
Fixed? 
Continue with 
ECO routing Yes NO 
Freeze Silicon ECO 
Requires that no cells are 
moved or added. 
Uses  spare cells to 
perform ECO. Non-freeze Silicon ECO 
Allows new added cells. 
Does not require spare cells. Spare cells 
are required ECO placement 
derives the 
location for new 
added cell 
instances 

Routing and Crosstalk 
IC Compiler 1 6-41 © 2009 41 6-Functional ECO Flows 
1. Non-Freeze silicon ECO 
/circle6Pre-tapeout, no restriction on placement or routing 
/circle6Minimal disturbances to the existing layout 
/circle6ECO cells are placed close to their optimal locations 
2. Freeze silicon ECO 
/circle6Post-tapeout, metal masks change only using previously 
inserted spare cells 
/circle6Cell placement remains unchanged 
/circle6ECO cells are mapped to spare cells that are closest to the  
optimal location 
/circle6Deleted cells become spare cells 
Non–freeze Silicon ECO flow is also known as the “Unconstrained ECO flow”.

Routing and Crosstalk 
IC Compiler 1 6-42 © 2009 42 6-Non-Freeze Silicon ECO 
Update design with ECO 
update_mw_design_eco –library orca_lib.mw \
-change_verilog orca_eco.v 
–top_module ORCA ROUTED 
or 
read_mw_eco_list –library orca_lib.mw \
-change_file orca_eco.changefile ROUTED 
ECO placement 
legalize_placement -eco -inc 
ECO routing 
route_eco P&R Original 
netlist 
ECO 
netlist 
ECO 
change 
file 
update_mw_design_eco: This command compares the current version of the netl ist with the 
updated version of the netlist. This command works on both hierarchical and flattened des igns. 
read_mw_eco_list: This command make engineering changes to the des ign based only on the 
information provided in the ECO change file. 
When a cell is deleted form the netlist , this command deletes the cell  from the design database 
When a cell is added in the netlist , this command adds the cell in the design dat abase 
When a cell instance in the netlist is replaced with another cell (ce ll instance name being same) 
the tool replaces the cell in the design database. 
legalize_placement: This command legally places cells added to a layout b y the above 
update_mw* or read_mw* commands. 
route_eco: Performs incremental routing for the new cells after r unning the legalize_placement 
command. Executes all three phase of routing: global route, track assign and de tail route. 

Routing and Crosstalk 
IC Compiler 1 6-43 © 2009 43 6-Hierarchical ECO Change File Example 
+D Mon Oct 30 14:00:00 2006 
+T IC Compiler 
+C Invert DATA[3] 
+A ecoengineer 
+HN d3_spare 
-HC net_DATA[3] DATA_iopad_3/I 
+HI d3_spare_inv invbd7 
+HC net_DATA[3] d3_spare_inv/I 
+HC d3_spare d3_spare_inv/ZN 
+HC d3_spare DATA_iopad_3/I 
See SolvNet “IC Compiler ECO Flow Application Note”
https://solvnet.synopsys.com/retrieve/018497.html 
Date and Time (+D) This is part of header information. 
Syntax: +D dayOfWeek Month Day Time Year 
Tool (+T) This is part of header information. 
Syntax: +T Tool 
Author (+A) This is part of header information. 
Syntax: +A AuthorLoginName 
Comments (+C) This is a comment line. 
Syntax: +C Comment 
Net Creation (+HN) 
Syntax : +HN hierPath/NetName 
Net Deletion (-HN) 
Syntax : -HN hierPath/NetName 
Port Net Connection (+HC) 
Syntax : +HC hierPath/NetName [childCellInstanceName/]PortInstanceM asterName 
Port Net Disconnection (-HC) 
Syntax : -HC hierPath/NetName [childCellInstanceName /]PortInstance MasterName 
Instance Creation (+HI) 
Syntax : +HI [hierPath/]CellInstanceName CellInstanceMasterName [vi ewName]
Instance Deletion (-HI) 
Syntax : -HI [hierPath/]CellInstanceName [CellInstanceMasterName ]  [CellInstanceType] 
See the Application Note “Hierarchical ECO By Change File” for complete  details. 

Routing and Crosstalk 
IC Compiler 1 6-44 © 2009 44 6-Inserting Spare Cells for Freeze Silicon ECO 
Placement 
spread_spare_cells \
-bbox {{10 10} {80 50}} \
[get_cells spare*] 
legalize_placement -eco -inc 
CTS and Route insert_spare_cells \
–lib_cell {NOR2 NAND2} \
-num_instances 20 \
-cell_name SPARE_PREFIX_NAME \
-tie Netlist includes 
spare cells? Yes No 
set_dont_touch \
[all_spare_cells] true 
set_attribute [all_spare_cells] \
is_soft_fixed true Cells in this list 
will be placed 
close together Original 
netlist 
Spare cells are extra gates (AND,NOR,XOR,INVERTER, etc) which a re included in a layout but 
are not functionally connected and used during the initial design phase. If a  functional change is 
required late in the design cycle, the layout can be modified (routing or me tal mask changes only) 
to take advantage of these spare cells. The flow above describes how to add t hese spare cells in 
your layout, so that you can use them later, if needed, using the “freeze-s ilicon ECO flow”.
Spare cells are distributed inside the core area. 
insert_spare_cells    # insert spare cells 
-lib_cell <lib_cell_list> (ref cell name) 
-num_instances <number_of_instances> (num of instanc es: Value >= 0) 
-cell_name <cell_name> (base name of spare cell) 
[-sub_design <sub_design_name>] (name of sub_design)
[-tie] (tie input pins to logic zero) 

Routing and Crosstalk 
IC Compiler 1 6-45 © 2009 45 6-Protecting Spare Cell Placement 
/square6Spare cells are dont_touch so IC Compiler doesn’t 
remove the unconnected cells 
/square6Set the spare cells to SOFT FIXED once the spare 
cells are distributed 
/circle6Use set_attribute to set the spare cells to SOFT FIXED 
/square6Why set the spare cells to SOFT FIXED? 
/circle6Detailed placer may fail if there are too many fixe d cells 
/circle6The soft-fixed attribute prevents incremental coars e 
placement from moving spare cells 
/circle6The soft fixed cells can still be moved slightly an d 
legalized by CTS and Routing optimizations 

Routing and Crosstalk 
IC Compiler 1 6-46 © 2009 46 6-
ECO cell maps 
to spare cell Freeze Silicon ECO: Metal Change Only 
Set freeze silicon mode 
set_freeze_silicon_eco 
Update design with ECO 
update_mw_design_eco 
or 
read_mw_eco_list 
ECO placement 
place_freeze_silicon 
ECO routing 
route_eco Copy of the routed cell 
ECO 
netlist or 
change file P&R netlist 
If the “Freeze Silicon mode” is enabled , IC Compiler will not perform  any cell changes to the 
design. Any changes are “swaps”, that means that the only changes a re rewirings. 

Routing and Crosstalk 
IC Compiler 1 6-47 © 2009 47 6-ECO Routing Example 
The ECO route example below is for a minor ECO: 
Only minimal routing changes are being allowed 
route_eco -reroute modified_nets_only 
-utilize_dangling_wires 
-freeze_routing_on_layer layer 
-freeze_vias_on_frozen_metal 
Modify these options if the router 
fails to fix all violations. 

Routing and Crosstalk 
IC Compiler 1 6-48 © 2009 48 6-Zroute: Synopsys’ New Routing Technology 
IC Compiler IC Compiler 
Zroute Zroute State of the art routing 
technology 1
Concurrent DFM optimizations 2
Multi-threaded throughout 3
10X Speed 10X Speed --up, higher QoR, better manufacturability up, higher QoR, better manufacturability Available Available 
2008.09 2008.09 Architected From The Ground Up For New Challenges 
Synopsys introduced IC Compiler Zroute technology on May/27. IC Compiler custom ers will have 
a choice to use the current router or Zroute based on their needs. Zroute co-e xists with current 
router and requires a single license for 4 cores. 
Compared to traditional routers, Zroute delivers a 10X speed increase, highe r QoR and better 
DFM. 
Zroute was built from scratch to address new challenges for routing. 
It is part of IC Compiler and there are 3 key things that differentiate  it from traditional routers: 
1.State of the art routing technology. 
2.Concurrent DFM optimizations. 
3.Multi-threaded throughout. 

Routing and Crosstalk 
IC Compiler 1 6-49 © 2009 49 6-Realistic Connectivity Dynamic Maze Grid 1. State of the Art Routing Technology 
Advanced Design Rules Polygon Manager Virtual Wire 
Y
ZX
S
SSW0.6S 
Faster runtimes, improved design closure Faster runtimes, improved design closure Dynamic 
Grid 
0.6S 
Zroute includes state of the art routing technology  with the latest in routing research and routing al gorithms. 
This slides highlights some of these technologies: 
1. Realistic connectivity 
Traditional routers model the center lines of wires , rather than the complete wire. 
For two lines to connect, the center lines have to connect. 
Zroute's connectivity model uses a realistic connec tivity model. 
As long as the rectangles touch, Zroute knows there  will be electrical connectivity. 
This makes the router very flexible in the way that  it manipulates shapes. 
2.  Dynamic maze grid 
This can be thought of as a grid that can be change d on the fly in specific instances. 
It allows the router to go off-grid to connect pins , while retaining the speed advantages of gridded r outers. 
In other words Zroute is a gridded router that can behave as gridless when needed. 
3. Advanced design rules 
Zroute is architected to efficiently handle advance d design rules for 45 nm and below. 
In addition to hard rules imposed, Zroute can handl e soft, or recommended rules. 
Example shows: a “dense end of line” configuration 
4. Polygon manager 
Zroute has a built-in polygon manager. 
While it routes using rectangles, it understands th at design rule checks (DRCs) are aimed at polygons,  and it can 
recognize polygons. 
Routers that can't recognize polygons have to decom pose everything into rectangles, adding more proces sing time. 
The technologies described here as well as others i n Zroute achieve faster runtimes and improved desig n closure. 

Routing and Crosstalk 
IC Compiler 1 6-50 © 2009 50 6-Redundant Vias 2. Concurrent DFM Optimizations 
Faster runtimes, improved manufacturability Faster runtimes, improved manufacturability Soft Rules 
Antennas Wire Spreading/Widening Yield 
Spacing STS T
Gate Via1 Metal 2 
Metal 1 Via1 
Metal 1 
Another Zroute advantage compared to traditional routers is concu rrent DFM optimizations. 
By considering soft rules, antennas, vias, and wire spreading during rout ing rather than as a post-processing 
step, Zroute achieves better manufacturability. 
Here are some examples: 
1. Soft rules 
Zroute supports soft spacing rules as well as user defined soft r ules for better manufacturability and litho-
friendly routing. 
2. Antennas 
Routers supported antenna rules since 90nm. 
The difference with Zroute is that you can set the antenna rules up fron t, and the router will automatically 
take care of them without any extra checking and fixing steps. 
3-4. Redundant vias, wire spreading/widening 
By considering vias, and wire spreading during routing rather than as a post-processing step, Zroute 
achieves better manufacturability. 
Early partners are reporting 10 to 15 percent fewer vias overall, and 30 to 50 p ercent fewer single vias. 
Reducing single vias results in a higher yield. 
The technologies described here as well as others in Zroute achieve  faster runtimes and improved 
manufacturability. 

Routing and Crosstalk 
IC Compiler 1 6-51 © 2009 51 6-Larger Capacity Scalability 3. Multi-threaded Throughout 
All Routing Steps 
Transparent 
Faster runtimes, near linear scalability Faster runtimes, near linear scalability # of cores X Speedup Memory 
# of cores Native 
Ready to go 
Simple set-up 
Multi-threading is the 3 rd key thing that differentiates Zroute. 
New software has to be architected for multi-threading, and it is not a tr ivial thing to do. 
1. All routing steps 
In Zroute all routing steps – including global routing, track assignment , and detailed routing – are 
multi-threaded to take advantage of the multicore CPUs. 
2. Transparent 
Multi-threading is transparent to the user and the only thing that needs t o be done is to set the # of 
threads up front. 
3. Scalability 
Zroute delivers near linear scalability as the number of cores increas es. We will take a closer look 
at this in the next slide. 
4. Capacity 
Zroute delivers 20% smaller memory footprint than traditional routers. 
Note that there is minimal memory overhead as the number of cores incre ases. 
With multi-threading users see faster runtimes that scale as the numbe r of cores increases. 

Routing and Crosstalk
IC Compiler 16-52© 200952 6-10X Speed-Up On Mainstream Hardware
3.5X Faster 3.5X Faster ––SingleSingle --threadedthreaded
““xx””
3X Speedup 3X Speedup ––MultiMulti --threaded on Quadthreaded on Quad --CoreCore
10X Speed Up10X Speed Up
“… achieved a 10x boost in performance 
when we used it with a quad-core platform.”
Combining the latest in routing algorithms with multi-threading, achieves a 10X speed up in 
routing.
3-4X single-threaded : attributed to the changes in the core routing technology.
3X multi-threaded : additional boost with 4 threads (4-core platforms are mainstream today).
3.5X times 3X = ~10X for quad-core mainstream platforms.
This is how Zroute delivers a 10X improvement in routing runtime.

Routing and Crosstalk
IC Compiler 16-53© 200953 6-Zroute Is GA in IC Compiler 2008.09!
Available also in 
2007.12-SP5-1
Multiple on-going 
tape-outs
Multiple test chips 
at 32nmhttps://solvnet.synopsys.com/zroute/

Routing and Crosstalk
IC Compiler 16-54© 200954 6-Zroute Users Tell The Story …
“ … routing runtimes cut significantly by 
multi-threading support  … ”
5/19/08“… achieved a 10X boost in performance 
when we used it with a quad-core platform.”
5/27/08“…tapes out home networking device 
using new Zroute technology …”
9/15/08“…70% fewer narrow jogs, 
30% fewer notches ...”
9/22/08“…2-3.4X faster  single-threaded
3X scalability with 4 threads ...”
10/17/08
TapeTape --outout
TapeTape --outout

Routing and Crosstalk 
IC Compiler 1 6-55 © 2009 55 6-Routing & Crosstalk Summary 
/square6Specify common route options before 
starting route activity for clocks and signals 
/square6Route clock nets and special net groups 
first, then signal routes for the remainder 
of the design 
/square6Perform Post Route Optimizations to fix max 
cap/trans and timing violations 
/square6Perform crosstalk correction during the routing flo w 
using logic, placement and routing optimization 
/square6Implement functional ECOs with minimal changes 

Routing and Crosstalk 
IC Compiler 1 6-56 © 2009 56 6-Lab 6a: Routing & Crosstalk,   Lab 6b: ECO 
/square6Perform routing and  
optimizations 
/square6Perform crosstalk optimization 
/square6Perform freeze silicon ECO 80 minutes 
Route Setup 
Set routing options 
DRC check 
SI Analysis and 
Optimization 
ECO route_opt 

Chip Finishing and DFM 
IC Compiler 1 7-1© 2007 17-Agenda 
© 2009 Synopsys, Inc. All Rights Reserved Synopsys 20-I-071-SSG-008 DAY 
33 33
Multi Scenario Optimization 5
Routing and Crosstalk 6
Chip Finishing and DFM 7
Customer Support CS 

Chip Finishing and DFM 
IC Compiler 1 7-2© 2007 27-Unit Objectives 
After completing this unit, you should be able to: 
/square6Perform key chip finishing and design for 
manufacturing steps required after the signal 
routing is complete: 
/circle6Fix antenna violations 
/circle6Modify the routing patterns to make them more 
resistant to defects 
/circle6Add redundant contacts 
/circle6Perform metal filling and slotting 
/circle6Insert filler cells 
/circle6Run DRC and LVS operations (Lab) 

Chip Finishing and DFM 
IC Compiler 1 7-3© 2007 37-IC Compiler Flow 
Synthesis 
Unit 1 
Unit 3 
Unit 4 
Unit 6 
Unit 7 Unit 2 Design Setup 
Design Planning 
place_opt 
clock_opt 
route_opt 
Chip Finishing /checkbld/checkbld /checkbld/checkbld
/handptright/handptright /handptright/handptright/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld
/checkbld/checkbld /checkbld/checkbld/checkbld/checkbld /checkbld/checkbld

Chip Finishing and DFM 
IC Compiler 1 7-4© 2007 47-Design Status, Completion of Routing Phase 
/square6Placement - completed 
/square6CTS – completed 
/square6Power and ground nets – routed 
/square6Signal and clock nets – routed 
/square6Signal Integrity issues – fixed/acceptable 
/square6Calculated timing – acceptable (>= 0ns slack) 
/square6Logical DRC – max cap/transition – no violations 
/square6Physical DRC – no violations 

Chip Finishing and DFM 
IC Compiler 1 7-5© 2007 57-Chip Finishing Flow 
Post-Route: Timing & 
DRC clean design 
Antenna Fixing 
Wire Spreading 
Redundant Via Insertion 
Filler Cell Insertion 
Metal Fill Insertion 
Metal Slotting 

Chip Finishing and DFM 
IC Compiler 1 7-6© 2007 67-Problem: Gate Oxide Integrity 
/square6Metal wires (antennae) placed in an EM field genera te 
voltage gradients 
/square6During the metal etch stage, strong EM fields are 
used to ionize the plasma etchant 
/square6Resultant voltage gradients at MOSFET gates can 
damage the thin oxide 
Oxide Poly Metal 1 Protective coating 
Damaged Gate Oxide Oscillating charges in Plasma Etch 
Antenna            Critical Area              Redun dant Via Filler Cell            Metal Fill        M etal Slotting Antenna 

Chip Finishing and DFM 
IC Compiler 1 7-7© 2007 77-Antenna Rules 
/square6As total area (length) of wire increases during pro cessing, 
the voltage stressing the gate oxide increases 
/square6Antenna rules define acceptable total area of wires
Antenna Ratios: 
Area of Metal Connected to Gate 
Combined Area of Gate 
Or 
Area of Metal Connected to Gate 
Combined Perimeter of Gate 
poly 
diffusion gate 
The ASIC vendor will specify antenna design rules in terms of allowable rat ios of antenna metal to gate 
oxide. 
Basic Antenna rules are: 
(antenna-area) / (gate-area) < (max-antenna-ratio) 
Gate-area: 
Boolean AND (or intersection) of the ‘poly’ and the ‘diffusion’ layers 
Recognized as the gate area of the transistors by essentially all  foundries 
Antenna-area: 
Amount of metal area attached to the input pin 
Calculation method varies for different processes 
Max-antenna-ratio: 
Represents max allowed ratio of antenna area to gate area 
Calculation method varies for different processes 

Chip Finishing and DFM 
IC Compiler 1 7-8© 2007 87-Solution 1: Splitting Metal or Layer Jumping 
After layer jumping, to meet Antenna rules Before layer jumping 
Acceptable antenna area Unacceptable antenna area driver 
diffusion gate 
poly metal 1 M1 
blockage metal 3 
driver 
diffusion gate 
poly metal 1 M1 
blockage metal 3 metal 3 M1 is split 
by jumping 
to M3 and 
back 
M3 blockage M3 blockage 
Until the top metal 3 link is in place, the metal 1 wire can generate larg e voltage gradients that may 
damage the gate oxide. This method of fixing antenna rule violations uses jumps in me tal layers to keep 
the total length of lower level metal traces that are directly conn ected to polysilicon gates below 
maximum. Once the top metal ‘link’ is in place and the polysilicon gate is conne cted to its driver, it is 
relatively safe. The pn junction of the source/drain of the driver will help shunt  large voltage swings – it 
acts like a reverse-biased diode. 
This is the preferred method for fixing antenna problems. Antenna violations that  cannot be fixed by this 
method must be provided with special shunting diodes. These diodes use up additional si licon placement 
and metal routing resources, which may be challenging – diode insertion is the refore the second choice, 
over layer jumping, to address antenna violations. 
Run an Search and Repair to fix antenna violations. The search & repair engine  will reroute antenna 
violators adding multiple jumps to the long traces. 

Chip Finishing and DFM 
IC Compiler 1 7-9© 2007 97-During etch phase, the diode clamps the voltage swi ngs. Solution 2: Inserting Diodes 
Before inserting diodes 
Diode Inhibits large voltage 
swings on metal tracks 
If the antenna can not be fixed with metal jumping, add an antenna diode to shunt the  voltage. The diode 
acts like the pn-junction of a driving gate to clamp the voltage swings on the met al. A special antenna 
diode CEL is usually provided by the fab or ASIC vendor. 
During normal operation, these diodes are always reverse biased and have m odest effects on signal 
performance. 

Chip Finishing and DFM 
IC Compiler 1 7-10 © 2007 10 7-Antenna Fixing Flow 
Insert Antenna 
Diodes for all 
remaining violations 
Continue Search & Repair Set antenna rules Route DRC 
violations? 
No Yes Routing & related 
optimizations Routing & related 
optimizations Routing & related 
optimizations Routing & related 
optimizations Routing & related 
optimizations 
Search & Repair 
Performs metal splitting 
to meet antenna rules 
Command details in lab! 
IC Compiler can fix antenna violations by performing “Search & Repair” and/or  “Insert Antenna Diode”. 
For a less congested design, use “Search & Repair” before “Insert Antenn a Diode” to fix antenna 
violations and to minimize changes to the design. 
The goal is to fix as many antenna violations as possible by layer-jumpin g with “Search & Repair”, and 
then insert diodes to fix the remaining antenna violations. 
Run Hercules as final verification. 

Chip Finishing and DFM 
IC Compiler 1 7-11 © 2007 11 7-Antenna: Misc 
/square6Antenna rules (once loaded) are honored by any 
Search & Repair run, even during detailed route 
/circle6It is NOT recommended to turn on antenna rules 
during detailed route’s S&R 
/rhombus6The router may try to fix antennae and end up in 
irresolvable DRC violations 
/square6Use diodes to fix antenna that are not fixable by 
S&R 
/circle6Diodes are auto select by default 
/circle6To specify diodes, use: 
insert_diode -no_auto_cell_selection \
-diode_cells <collection_of_diode_cells> insert_diode –prefix DFM_DIODE_ 

Chip Finishing and DFM 
IC Compiler 1 7-12 © 2007 12 7-Center of conductive defects within 
critical area – causing shorts Center of non-conductive defects within 
critical area – causing opens Random Particle Defects 
/square6Random particle defects during manufacturing may 
cause shorts or opens during the fabrication process 
/circle6Wires at minimum spacing are most susceptible to sh orts 
/circle6Minimum-width wires are most susceptible to opens 
Critical Areas 
Metal 3 
Center of conductive defects 
outside critical area – no shorts Center of non-conductive defects 
outside critical area – no opens 
+
+
+
+
+
+
+
 +
Antenna          W Critical Area g           Redund ant Via  Filler Cell            Metal Fill        M etal Slotting Critical Area 
This is a process and fabrication-related defect that’s generally r andom with a level of clustering, 
depending on the defect sources. 
Random particle defects (which are usually called extra/missing ma terial random defects or  short/open 
random defects), occur because of contamination during the fabrication proc ess. 
Particles fall on the chip and result in two adjacent lines causes shorting  or a line breaking . 
Definition of Critical Area 
A critical area is a region where circuit failure will occur (yield loss) if the center  of a random defect 
falls in it 
- Critical area regions varies with defect size 
- For a particular layout, the larger the defect size, the larger the c ritical area 
- Larger defects are statistically less likely 

Chip Finishing and DFM 
IC Compiler 1 7-13 © 2007 13 7-Reporting the Critical Area 
/square6Generates both text and graphic report 
report_critical_area 
-particle_distr_func_file <file> 
-input_layers {m2 m3 m4} 
-fault_type {short|open} 
GUI: Finishing /barb2right/barb2right /barb2right/barb2rightShort Critical Area Map and Finishing /barb2right/barb2right /barb2right/barb2rightOpen Critical Area Map 
Results from critical area analysis is in the file “output_heatmap ”. Example: 
Total critical area on each layer 
Layer      Critical Area (mm2)     Critical Area (% of Chip Area)  
m1            159692.323                  20.876 
m2              41282.836                    5.397    
m3            102339.392                  13.378    
……
Critical area within each window 
Layer: m2        
window (x1, y1) (x2, y2)      Ratio         Area 
(0, 0) (5.36, 5)          0                0 
(5.36, 0) (11.12, 5)        0.0478       1.377 
(11.12, 0) (16.88, 5)        0.0253       0.728 
(16.88, 0) (22.64, 5)        0.0135       0.388 
……

Chip Finishing and DFM 
IC Compiler 1 7-14 © 2007 14 7-Solution: Wire Spreading + Widening 
/square6Spread wires to reduce short critical area 
/circle6Push routes off-track by ½ pitch 
/circle6Will not push “frozen” nets 
/square6Widen wires to reduce open critical area 
Wire Tracks 
Spreading 
off-track 
Widening route_spreadwires + route_widen_wire 
Use the following command to perform wire spreading  at post-detail route stage : 
route_spreadwires #The following options are optional 
-min_jog_length (default: 2) 
-timing_driven (default: off) 
#Preserve timing of critical nets meeting setup slac k criteria 
-setup_slack_threshold (default: 0.0) 
#Do not spread net with a worse setup slack than th is threshold 
-search_repair_loop (default: 10) 
route_widen_wire 
-search_repair_loop (default: 10) 
-nonuniform_widening 
-timing_driven (default: off) 
-setup_slack_threshold (default: 0.0) 
-hold_slack_threshold (default: 0.0) 

Chip Finishing and DFM 
IC Compiler 1 7-15 © 2007 15 7-Controlling Minimum Jog Length 
/square6Pushing wires off-track always creates a jog and 
increases wire length 
/square6Use ‘-min_jog_length’ option to control the 
minimum jog length (default: 2 pitches) 
/circle6Will not push a wire unless the available space is l arger 
than ‘-min_jog_length’
jog length jog length 

Chip Finishing and DFM 
IC Compiler 1 7-16 © 2007 16 7-Proactive: Density-Driven During GR and TA 
/square6The density-driven mode spreads wires during global  
route and track assignment to achieve more uniform 
wire distribution and fewer minimum spacing 
/square6Density-driven mode is off by default but it is ena bled 
automatically when: 
/circle6Timing-Driven global route / track assign is on, an d/or 
/circle6Crosstalk prevention is on set groute_densityDriven 1 
set trackAssign_densityDriven 1 
Increased spacing 
decreased CA 
icc_shell> set groute _densityDriven 1 
;;      range [-1,2], default=-1; 
;;      0: turn off density driven mode, 
;;      1: turn on density driven mode. 
;;      2: turn on high effort density driven mode. 
;;      -1: program to decide whether to use density driven mode. 
icc_shell> set trackAssign_densityDriven 1 
;;      range [-1,2], default=-1; 
;;     0: do not worry about spreading, 
;;      1: try to spread wires looking at 1 extra track, 
;;      2: should only be set when design is lower than x utilization, this w ill use more CPU. Misuse this when design 
is not sparse can cause negative impact, 
;;     -1: try to spread wires looking at 1 extra track if timing or xtal k is on. 

Chip Finishing and DFM 
IC Compiler 1 7-17 © 2007 17 7-Voids in Vias during Manufacturing 
/square6Voids in vias is a serious issue in manufacturing 
/square6Two solutions are available: 
/circle6Reduce via count: Via optimization techniques are 
employed in route_opt 
/circle6Add backup vias: known as redundant vias 
Connection is okay even 
if one contact defective Connection fails if 
contact defective 
Antenna            Critical Area              Redun dant Via Filler Cell            Metal Fill        M etal Slotting Redundant Via 

Chip Finishing and DFM 
IC Compiler 1 7-18 © 2007 18 7-Via Control Through Tcl Variables 
/square6Timing driven mode: 
/square6To report excluded nets based on timing thresholds set droute_optViaTimingDriven 1 (default 0) 
set droute_optViaSetupSlackThreshold 0.05 (default -0.1) 
set droute_optViaHoldTimeThreshold 0.05   (default 0.0) 
set droute_optViaReportExcludedNets 1     (default: 0) 
droute_optViaTimingDriven : The variable  specifies whether to preserve timing for critical  nets with 
timing violations. If the value is set to 0, the router does contact optimizati on for all nets. If the value is 
set to 1, the router tries to preserve timing for critical nets by  not doi ng contact optimization on those 
nets. 
droute_optViaSetupSlackThreshold : The variable specifies the setup slack threshold for contact 
optimization. If the value is set to N, the router tries to preserve setup ti me by not inserting redundant 
vias for the nets whose setup slack is worse than N. 
droute_optViaHoldTimeThreshold : The variable specifies the hold time threshold for contact 
optimization. If the  value  is set to N, the router tries to preserve hold tim e by not inserting redundant 
vias for the nets whose hold time is worse than N. 

Chip Finishing and DFM 
IC Compiler 1 7-19 © 2007 19 7-Insert Redundant Vias 
/square6Replaces single vias with multiple vias on all nets
/circle6Excludes timing critical nets identified by the thr esholds 
1X2 
2X1 
insert_redundant_vias 
-from_via “via12 via23 via34”
-to_via   “viaF12 viaF23 viaF34”
-to_via_x_size “1 1 1”
-to_via_y_size “2 2 2”
-via_array_no_swap 
-optimize_level 1 
-auto_mode (preview | insert) 
-num_cpu N 
Run the insert_redundant_vias command on a DRC clean design.  Routes should not show new mask 
design rule violations.  
insert_redundant_vias 
-from_via list_of_from_vias ;# Specifies a list of via names to be replaced. 
-to_via list_of_to_vias ;# Specifies a list of the corresponding names of the new vias to cre ate.  
The list is usually the same as the corresponding  -from_via name.  If t he list is different, the layer definition of the 
two vias must be the same. 
-to_via_x_size list_of_x-sizes ;# Specifies the list of the x-sizes for the newly created vias.  If 
this option is not specified, the default value of 1 is used for x-siz es. 
-to_via_y_size list_of_y-sizes ;# Specifies the list of the y-sizes for the newly created vias.  If 
this option is not specified, the default value of 1 is used for y-si zes.  For a via, either x-size or y-size must have the 
value equal to 1. 
-via_array_no_swap (default false) ;# Specifies not to swap row and column of via arrays. 
In other words the 1 x N and N x 1 via arrays are not considered equivalent. By def ault, row and column of via 
arrays may be swapped. 
-optimize_level int“ ;# Determines how aggressively to try different positions for line via array 
insertion.  By default, the optimize_level is 0, which will try les s positions.  The value of 1 will try more positions. 
-auto_mode preview | insert ;# Specifies the mode in which to automatically generate via lists. If 
you specify preview, all vias defined in the technology  file are lis ted, but no redundant vias are inserted. If  you  
specify  insert,  redundant  vias  that  are defined as default vias in the technology file are inserted. This option is 
mutually exclusive with the  -from_via,  -to_via, -to_via_x_size, and -to_via_y _size options. 

Chip Finishing and DFM 
IC Compiler 1 7-20 © 2007 20 7-report_design –physical 
Mask Name      Contact Code    Number Of Contacts    Percentage 
via1          VIA12A(1)              6578              14.7 
via1          VIA12B(2)             26784              59.9 
via1          VIA12f(9)                56             0.125 
via1_1x2      VIA12A(1)              2982              6.67 
via1_2x1      VIA12A(1)              8302              18.6 
Default via for layer via1:                   74.8%
Yield-optmized via for layer via1:            25.2%
via2           VIA23(3)             14334              25.2 
via2_1x2       VIA23(3)             17544              30.8 
via2_2x1       VIA23(3)             25039               44 
Default via for layer via2:                   25.2%
Yield-optmized via for layer via2:            74.8%
…………… 
Double Via rate for all layers:           58.9% 
============================================== 
Total Number of Contacts:    120119 Reporting Redundant Via Count 

Chip Finishing and DFM 
IC Compiler 1 7-21 © 2007 21 7-Redundant Via Methodologies 
/square6IC Compiler provides both a recommended and an 
optional methodology for redundant via insertion: 
/circle6In the recommended 
methodology, redundant via 
is inserted at post-detail route 
/rhombus6most of the time, more than 
90% redundant via rate 
/circle6In the optional method, 
redundant vias are inserted 
during signal routing 
/rhombus6increases redundant via rate Remove NDR Design Ready for 
Signal Routing 
Extra S&R Loops 
(DRC clean) Signal Route 
Post-Detail Route 
Contact Optimization Define NDR 
NDR = Non-Default Routing rule 
Route /barb2rightRouting Setup /barb2rightDefine Routing Rule 
Use this area to 
define an NDR rule 
with multiple vias 

Chip Finishing and DFM 
IC Compiler 1 7-22 © 2007 22 7-Why Filler Cell Insertion?
/square6For better yield, density of the chip needs to be u niform 
/square6Some placement sites remain empty on some rows 
/circle6ICC can fill such empty sites with standard cells 
Antenna            Critical Area              Redun dant Via Filler Cell            Metal Fill        M etal Slotting Filler Cell 

Chip Finishing and DFM 
IC Compiler 1 7-23 © 2007 23 7-Insert Cells to Fill Unused Placement Sites 
/square6Use insert_pad_filler to insert IO cell fillers 
/square6Use insert_stdcell_filler to insert std cell fillers 
/circle6nwell/pwell structures 
/rhombus6Automatically completes nwell/pwell structures by inse rting 
well and tap filler cells ( insert_well_filler )
/rhombus6Ensures that tap cells are placed to connect wells to r ails at 
regular distances 
insert_stdcell_filler \
–cell_with_metal “fillCap64 fillCap32” \
-connect_to_power VDD –connect_to_ground VSS 
insert_stdcell_filler \
-cell_without_metal “fill64 fill32”
-connect_to_power VDD –connect_to_ground VSS 
Accepts two lists of filler cells: with/without metal 
Cells with metal are inserted only if no DRC violations result 
Cells without metal are inserted without checking drc’s
You should insert cell with metal first then follow with cell without metal. 

Chip Finishing and DFM 
IC Compiler 1 7-24 © 2007 24 7-/square6A metal wire in low metal density region receives a  
higher ratio of etchant can get over-etched 
/square6Minimum metal density rules are used to control this 
Plasma Etchant etches away 
un-protected metal 
Less 
etchant 
per um 2 
of metal Over-etching 
due to high 
etchant density Problem: Metal Over-Etching 
Antenna            Critical Area              Redun dant Via Filler Cell            Metal Fill        M etal Slotting Metal Fill 
Too much etchant in contact with too little metal /barb2rightoveretched metal. 

Chip Finishing and DFM 
IC Compiler 1 7-25 © 2007 25 7-Solution: Metal Fill insert_metal_filler 
/square6Fills empty tracks on all layers (default) with meta l 
shapes to meet the minimum metal density rules 
/square6Recommended to save metal fill in FILL view 
(default) 
/square6Trims metal fill honoring the minDensity and 
maxDensity in each window of size windowSize 
defined under DensityRule section of techfile 
GUI: Finishing /barb2right/barb2right /barb2right/barb2rightInsert Metal Fill …
Metal filling is done to improve process planarization, 
which is important for processes with a large number 
of metal layers. 
Metal fill insertion 
Can choose to fill layers of choice including poly 
By default leaves the fill floating 
Optionally, can chose to connect to ground or 
other net 
Can choose to insert floating vias 
Can choose to do area based metal fill 
Can chose to specify required width, spacing for 
each layer 
Timing driven metal fill doesn’t fill wire tracks 
around critical nets 
area 
based 
fills 
selective 
fill tie 
off 

Chip Finishing and DFM 
IC Compiler 1 7-26 © 2007 26 7-Timing-Driven Rule-Based Metal Fill 
/square6Preserve timing on critical nets ( -timing_driven )
/square6Metal fill near critical nets on the same layer, up per 
layer, and lower layer are removed or trimmed 
Critical net Metal Fill 

Chip Finishing and DFM 
IC Compiler 1 7-27 © 2007 27 7-Problem: Metal Erosion 
/square6The wafer is made flat (planarized) by a process 
called Chemical Mechanical Polishing (CMP) 
/square6Metals are mechanically softer than dielectrics: 
/circle6CMP leaves metal tops with a concave shape - dishing 
/rhombus6The wider the metal the more pronounced the dishing 
/rhombus6Very wide traces can become quite thin – dishing this 
severe is called erosion 
/square6Maximum metal density rules are used to control 
erosion 
Antenna            Critical Area               Redu ndant Via Filler Cell            Metal Fill        M etal Slotting Metal Slotting 
Copper 
Any wafer process that effects the cross section of the conductors must  be carefully controlled. 
Erosion in wide metal traces will reduce their current carrying c apability and degrade IR drop 
characteristics. Controlling this is vital to the distribution of power supplies  and ground traces. 
Dishing affects the resistance of the signal traces and hence the ir propagation delays. Accurate modeling 
of this effect, which is a function of trace width and spacing, is one of the prim ary strengths of TLU+ 
models over TLU models. 
The wafer fabrication facility may impose maximum metal density  rules to designs to keep the level of 
dishing, and especially erosion, to acceptable levels. 

Chip Finishing and DFM 
IC Compiler 1 7-28 © 2007 28 7-Dielectric thermal expansion /square6Metal conductors and dielectrics have different 
coefficients of thermal expansion: 
/circle6Stress builds up with temperature cycling 
/circle6Metals can delaminate (lift off) with time 
/circle6Wide metal traces are more vulnerable than narrow o nes 
/square6Maximum metal density rules also address this issue
Dielectric Problem: Metal Liftoff 
Metal thermal expansion 
Metal 
Poorly resolved mechanical stresses occur at the 
corners of dies. The photo shows delamination of 
both metal and insulator thin films near a die corner 
after a temperature cycling stress test. 


Chip Finishing and DFM 
IC Compiler 1 7-29 © 2007 
29 7-Solution: Metal Slotting 
/square6Slotting wide wires reduces the metal density 
/circle6Slots minimize stress buildup, reducing liftoff ten dency 
/circle6Dielectric in wide wires improves resistance to ero sion 
/square6Primarily used on Power and Ground traces: 
/circle6Can apply to any other net if wide enough 
/square6Slotting parameters can be set globally or layer by  layer 
OpenSlot SideSpace 
EndSpace Length SideClearance 
Width 
Parameter 
entry fields 

Chip Finishing and DFM 
IC Compiler 1 7-30 © 2007 30 7-DFM Issues and Solutions Summary 
/square6Addressing issues to increase manufacturing yield: 
/circle6Gate Oxide integrity /barb2rightantenna fixing 
/circle6Via resistance and reliability /barb2rightredundant contacts 
/circle6Metal erosion /barb2rightmetal slotting 
/circle6Metal liftoff /barb2rightmetal slotting 
/circle6Metal Over-Etching /barb2rightmetal filling 
/circle6Metal open/short defects /barb2rightspread wire routing 
/square6DRC/ERC related 
/circle6notch/gap filling 
/circle6standard cell filling 
In deep submicron VLSI, some manufacturing steps, like photo-resist exposure, dev elopment and etch 
and Chemical Mechanical Polishing (CMP) have detrimental effects on inte rconnect structures. These 
effects can vary based on local characteristics of the layout. 
To make these effects predictable, the layouts must be made “uniform” with respect to certain density 
standards across very small localized areas of the die. In the past, foundri es performed the postprocessing 
needed to provide this uniformity. The techniques they used were filling (se lective insertion of shapes) or 
slotting (selective reduction of shapes). 
In today’s processes, the design tools doing RC extraction, delay calcula tion, IR drop analysis, 
timing/noise/crosstalk analysis must be aware of these slotting/fil ling activities or suffer significant 
inaccuracy. 
ICC attempts to move all these into the design stage and out of the Fab post-proce ssing regime. 
To minimize the impact of the manufacturing process on device yields, foundr ies impose various density 
rules to make the layouts more uniform. For instance, the foundry may impose a dens ity rule on an 
interconnect layer such that in any 10 um x 10 um window, there must be at least 35 um 2of metal 
features, but no greater than 70 um 2of metal. 
Spare areas must be filled, but wide metal stripes must be slotted to meet t he density rules. 

Chip Finishing and DFM 
IC Compiler 1 7-31 © 2007 31 7-Final Validation 
From DFM steps 
Write .spef file Generate 
output netlist 
PrimeTime SI Hercules 
Timing Signoff 
Detailed 
DRC & LVS Output GDS2 
Prove logical 
equivalence after 
ICC optimizations Formality 

Chip Finishing and DFM 
IC Compiler 1 7-32 © 2007 32 7-Final Validation: Parasitics (SPEF or SBPF) 
/square6Wire parasitics for PrimeTime are provided 
via a .SPEF or .SBPF file 
write_parasitics 
-output <file_name> 
-format <SPEF|SBPF> 
-compress 
-no_name_mapping 
Use Star-RCXT extraction for signoff 
GUI: Timing /barb2right/barb2right /barb2right/barb2rightWrite Parasitic 
In general, you can expect SPEF from ICC’s write_stream to be less  accurate than a SPEF from the 
StarRCXT. For signoff, you should use SPEF from StarRCXT. 

Chip Finishing and DFM 
IC Compiler 1 7-33 © 2007 33 7-Final Validation: Netlist Output 
/square6Netlists for STA (Static Timing Analysis) do not 
require output of “Physical only cells” like: 
/circle6Corner pad cells 
/circle6Pad/core filler cells 
/circle6Unconnected cell instances 
/square6Unconnected cell instances (e.g. spare cells) are 
needed for LVS 
change_names –hierarchy –rules verilog 
write -format verilog -hierarchy -output final.v 

Chip Finishing and DFM 
IC Compiler 1 7-34 © 2007 34 7-Final Validation: GDS2 Output 
/square6The GDS2 for external physical verification can be 
generated from IC Compiler 
/square6Requires output of “physical only cells” like: 
/circle6Corner pad cells 
/circle6Pad/core filler cells 
/circle6Unconnected cell instances write_stream_options …
write_stream –cells DFM_clean orca.gdsii 

Chip Finishing and DFM 
IC Compiler 1 7-35 © 2007 35 7-Hercules™ VUE Integration 
/square6Review, navigate and fix 
design violations for DRC, 
ERC, LVS 
/square6Use layout environment 
of choice 
/circle6Support available for 
/rhombus6IC Compiler & Astro 
/rhombus6Analog Design Artist 
/rhombus6ICWB-EV, CosmosEnterprise 
/circle6API available for internal solutions 
/square6Ignore / waive violations on case by case basis 


Chip Finishing and DFM 
IC Compiler 1 7-36 © 2007 36 7-Accessing VUE in IC Compiler 
/square6Set path to include both IC Compiler and Hercules t ools 
/square6Once in the ICC GUI, source the following tcl file to 
display the new Hercules menu in ICC: 
icc_shell> source "$env(HERCULES_HOME_DIR)/etc/tcl- u/IccMenu.tcl" 
/square6Open the design 
/square6In the ICC cell layout window, under the Verification 
menu, the new Hercules VUE option appears: 


Chip Finishing and DFM 
IC Compiler 1 7-37 © 2007 37 7-Running VUE 
/square6Use the normal VUE operations for viewing errors 
in the layout 
Use navigation buttons 
to scroll through errors 
Use Options to 
control visibility 


Chip Finishing and DFM 
IC Compiler 1 7-38 © 2007 38 7-Test for Understanding 
1. What problem are you trying to solve by meeting 
“metal fill” design rules? 
2. What are the two methods for fixing antenna rule 
violations? Does IC Compiler support both? 
3. Placing additional vias in nets may slightly 
improve timing performance as a side effect. Why 
does this happen? 
4. If you have a series of 50 um wide power rails, 
what manufacturability issue must you address? 1. Problem: Metal Over-etching. Metal fill is used to meet the foundry’s mi nimum metal density rules, 
which minimizes this problem. 
2. Metal layer jumping and antenna diode insertion. IC Compiler supports both 
3. Multiple vias act like parallel resistors, reducing the series impe dance of the inter-layer contact, 
which reduces the RC net delay. 
4. Metal lift-off during temperature cycling and metal erosion during C MP. Both are addressed by metal 
slotting, which introduces some hard oxide to support the metal during CMP and to reduce  stresses 
which can cause liftoff. 

Chip Finishing and DFM 
IC Compiler 1 7-39 © 2007 39 7-Summary 
You should now know more about how to: 
/square6Perform key design for manufacturing steps 
required after the signal routing is complete: 
/circle6Antenna fixing 
/circle6Modifying routing patterns to make them 
more resistant to short-causing defects 
/circle6Adding redundant contacts 
/circle6Inserting filler cells 
/circle6Metal filling and slotting 

Chip Finishing and DFM 
IC Compiler 1 7-40 © 2007 40 7-Lab 7: Chip Finishing 
/square6Fix antenna violations 
/square6Analyze critical area and use wire 
spreading/widening to improve 
manufacturing yield 
/square6Perform via optimization for timing and 
yield improvement 
/square6Perform standard cell filler insertion, as 
well as metal filling operations for metal 
density rule compliance 60 minutes 


Chip Finishing and DFM 
IC Compiler 1 7-41 © 2007 Appendix A 
Critical Area Calculations 

Chip Finishing and DFM 
IC Compiler 1 7-42 © 2007 42 7-Critical Area Definition 
/square6The region where, if the center of a random defect 
of a certain size falls on, will cause circuit fail ure 
(yield loss) 
Conductive Defect 
Causing Short Critical Area 
Non-Conductive Defect 
Causing Open No Critical 
Area for 
defects of this 
size 
IC Compiler reports the average critical area.  It uses the followi ng formula: 
Where: 
x: defect size (diameter)
f(x): defect size distribution function 
Acr(x): critical area for defect size x 
Acr: average critical area ∫= dx xfxA Acr cr )()(

Chip Finishing and DFM 
IC Compiler 1 7-43 © 2007 43 7-Discrete Defect Size Distribution 
/square6Defect size distribution function depends on the 
fabrication process 
/square6IC Compiler accepts discrete defect sizes and their  
probabilities in a table format 
/square6An example 
Defect Size       Probability 
0.20               0.002778 
0.36               0.000922 
0.52               0.000412 
0.68               0.000219 
0.84               0.000130 
… ... 
This information comes from empirical studies conducted by the fab. 
If no defect size distribution is defined, a built-in continuous function is used. 
This function is widely accepted in the industry. 
The y-axis is # of particles, the x-axis is defect diameter. 
Notice that above a certain threshold, the defect density drops very rapidly . 
The efficiency and type of filtering used in the fab sets the X0 limit. 


≥≤
=
0 300 3
0
 if      if      
)(
X xxXX x
Xx
xf
0X

Chip Finishing and DFM 
IC Compiler 1 7-44 © 2007 Appendix B 
FAQ 

Chip Finishing and DFM 
IC Compiler 1 7-45 © 2007 45 7-Wire Spreading 
/square6Why NOT run wire spreading before Antenna fixing? 
/circle6Not recommended, Antenna has the most priority after D RC 
/circle6Wire spreading (by pushing off-track) might not leave enough 
resource to fix antenna 
/square6Will wire spreading switch layers? 
/circle6Pushes wires off the track if space available, doesn’t switch 
layers to allow pushing (spreading) 
/circle6However, Search & Repair run after wire spreading ma y result in 
minimal changes to resolve DRC 
/square6Will wire spreading introduce Antenna violations? 
/circle6Antenna ratio dependant on Antenna length may change  slightly 
by wire spreading 
/circle6In most cases should NOT introduce new Antenna violat ions 
/square6Should I turn ON Antenna checking during wire sprea ding? 
/circle6Recommended 

Chip Finishing and DFM 
IC Compiler 1 7-46 © 2007 46 7-Redundant Via Insertion 1/2 
/square6Will IC Compiler try all possible combinations? 
/circle61x2 and 2x1 combinations treated same with the 
rotateLineViaArray parameter 
/circle6-optimize_level 0 tries 3 combinations of contact 
points in a double via 
/circle6-optimize_level 1 tries 5 combinations of contact 
points in a double via 
1
23
4 5Point of Contact Wire Segment 
Redundant 
Via 
The redundant via, shown on the left, is inserted at the point of contact shown on the right. Wi th 
optimize_level 0 it is inserted using the locations 1, 2 and 3. If none of the contact  points lead to a DRC-
legal connection, the double via is not inserted. Optimize_level 1 increases the num ber of contact points 
and the chance of a successful redundant-via insertion. 

Chip Finishing and DFM 
IC Compiler 1 7-47 © 2007 47 7-Redundant Via Insertion 2/2 
/square6Will redundant vias increase critical area? 
/circle6Yes, any increase in metal (route/cut layer) on layout  is bound 
to introduce critical area. But it will be very lit tle. 
/square6Will redundant vias introduce new antenna violation s? 
/circle6Redundant Vias are inserted without disturbing the rou te 
pattern 
/circle6However, later S&R runs to resolve DRC may cause anten na 
violations 
/circle6Turning ON antenna checking will roll back double to single 
vias reducing antennas 
/square6Can redundant vias be removed by the user? 
/circle6Redundant vias cannot be removed by a user command 
/square6Will S&R or ECO route remove redundant vias? 
/circle6May remove only if required to resolve any DRC viol ations 

Chip Finishing and DFM 
IC Compiler 1 7-48 © 2007 48 7-Filler Cell Insertion 
/square6How can I remove existing standard cell filler? 
/circle6remove_stdcell_filler –stdcell –pad \
–tap –bbounding_box 
/square6Is multi-height filler cell insertion supported? 
/circle6Yes 
/square6Is voltage aware filler cell insertion supported? 
/circle6Yes 

Chip Finishing and DFM 
IC Compiler 1 7-49 © 2007 49 7-Metal Fill Insertion 
/square6Can I do density checking in IC Compiler? 
/circle6verify_drc can report metal density violations 
/square6Will fill insertion result in gradient metal fill d ensity across 
windows? 
/circle6No, current implementation should not result in  larg er gradients
/circle6Track based metal fill insertion fills all empty wire t racks making it 
uniform 
/square6Is metal fill trimming possible in IC Compiler? 
/circle6Yes (trim_fill_eco )
/square6Can ICC trim fill around certain nets? 
/circle6No 
/square6How can metal density be reported? 
/circle6No standalone command available 
/circle6Metal fill insertion does not report the windows in w hich density is 
not met 
trim_fill_eco 
[-input fill_view_name] 
[-output fill_view_name] 
[-spacing_to_routing number] 
[-remove_vio_fill] 
When you have finished metal filling and the engineering change orde r has changed the routing, you can 
use this command to trim the metal fill and avoid design rule constraint violat ions. 

Chip Finishing and DFM 
IC Compiler 1 7-50 © 2007 This page was intentionally left blank. 

Customer Support CS-1© 2009 
Customer Support 
© 2009 Synopsys, Inc. All Rights Reserved 
 20090112 

Customer Support CS-2© 2009 
2CS-Synopsys Support Resources 
1. Build Your Expertise: 
Customer Education Services 
/circle6www.synopsys.com/support 
/rhombus6Workshop schedule and registration 
/rhombus6Download materials 
(SolvNet id required) 
2. Empower Yourself:  
solvnet.synopsys.com 
/circle6Online technical information and 
access to support resources 
/circle6Documentation & Media 
3. Access Synopsys Experts:   
Support Center 


Customer Support CS-3© 2009 
3CS-/square6Immediate access to 
the latest technical 
information 
/square6Product- and Release-
Specific Update Training 
/square6Thousands of expert-
authored articles, Q&As, 
scripts and tool tips 
/square6Enter-a-call online 
Support Center access 
/square6Release information 
/square6Online documentation 
/square6License keys 
/square6Electronic software 
downloads 
/square6Synopsys announcements 
(latest tool, event and 
product information) SolvNet Online Support Offers 


Customer Support CS-4© 2009 
4CS-SolvNet Registration is Easy 
1. Go to solvnet.synopsys.com/   
ProcessRegistration 
2. Pick a username and password. 
3. You will need your “Site ID” on 
the following page. 
4. Authorization typically takes 
just a few minutes. 


Customer Support CS-5© 2009 
5CS-Support Center: AE-based Support 
/square6Industry seasoned Application 
Engineers: 
/circle650% of the support staff has 
>5 years applied experience 
/circle6Many tool specialist AEs with 
>12 years industry experience 
/circle6Access to internal support 
resources 
/square6Great wealth of applied 
knowledge: 
/circle6Service >2000 issues per 
month 
/square6Remote access and debug via 
ViewConnect 
Contact us: 
Enter A Call 
www.synopsys.com/support 

Customer Support CS-6© 2009 
6CS-Other Technical Sources 
/square6Application Consultants (ACs): 
/circle6Tool and methodology pre-sales support 
/circle6Contact your Sales Account Manager for more informa tion  
/square6Synopsys Professional Services (SPS) Consultants: 
/circle6Available for in-depth, on-site, dedicated, custom consulting 
/circle6Contact your Sales Account Manager for more details
/square6SNUG (Synopsys Users Group): 
/circle6www.snug-universal.org 

Customer Support CS-7© 2009 
7CS-Summary: Getting Support 
/square6Customer Education Services 
/square6SolvNet 
/square6Support Center 
/square6SNUG 

Customer Support CS-8© 2009 
This page was intentionally left blank. 